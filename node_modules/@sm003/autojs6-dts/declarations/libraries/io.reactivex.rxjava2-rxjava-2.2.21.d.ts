declare module io {
	export module reactivex {
		export class BackpressureOverflowStrategy {
			public static class: java.lang.Class<io.reactivex.BackpressureOverflowStrategy>;
			public static ERROR: io.reactivex.BackpressureOverflowStrategy;
			public static DROP_OLDEST: io.reactivex.BackpressureOverflowStrategy;
			public static DROP_LATEST: io.reactivex.BackpressureOverflowStrategy;
			public static values(): io.reactivex.BackpressureOverflowStrategy[];
			public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
			public static valueOf(name: string): io.reactivex.BackpressureOverflowStrategy;
		}
	}
}

declare module io {
	export module reactivex {
		export class BackpressureStrategy {
			public static class: java.lang.Class<io.reactivex.BackpressureStrategy>;
			public static MISSING: io.reactivex.BackpressureStrategy;
			public static ERROR: io.reactivex.BackpressureStrategy;
			public static BUFFER: io.reactivex.BackpressureStrategy;
			public static DROP: io.reactivex.BackpressureStrategy;
			public static LATEST: io.reactivex.BackpressureStrategy;
			public static values(): io.reactivex.BackpressureStrategy[];
			public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
			public static valueOf(name: string): io.reactivex.BackpressureStrategy;
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Completable extends java.lang.Object implements io.reactivex.CompletableSource {
			public static class: java.lang.Class<io.reactivex.Completable>;
			public static complete(): io.reactivex.Completable;
			public onErrorComplete(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Completable;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.CompletableSource): io.reactivex.Completable;
			public static merge(sources: org.reactivestreams.Publisher<any>): io.reactivex.Completable;
			public static error(errorSupplier: java.util.concurrent.Callable<any>): io.reactivex.Completable;
			public doAfterTerminate(onAfterTerminate: io.reactivex.functions.Action): io.reactivex.Completable;
			public startWith(other: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public repeat(times: number): io.reactivex.Completable;
			public repeat(): io.reactivex.Completable;
			public blockingAwait(): void;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, completableFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>): io.reactivex.Completable;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, completableFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean): io.reactivex.Completable;
			public toFlowable(): io.reactivex.Flowable<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Completable;
			public constructor();
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: io.reactivex.CompletableSource): io.reactivex.Completable;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Completable;
			public startWith(other: io.reactivex.CompletableSource): io.reactivex.Completable;
			public repeatWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public test(cancelled: boolean): io.reactivex.observers.TestObserver<java.lang.Void>;
			public onTerminateDetach(): io.reactivex.Completable;
			public static error(error: java.lang.Throwable): io.reactivex.Completable;
			public static fromCallable(callable: java.util.concurrent.Callable<any>): io.reactivex.Completable;
			public static fromPublisher(publisher: org.reactivestreams.Publisher): io.reactivex.Completable;
			public static concat(sources: org.reactivestreams.Publisher<any>, prefetch: number): io.reactivex.Completable;
			public retry(): io.reactivex.Completable;
			public subscribe(observer: io.reactivex.CompletableObserver): void;
			public retry(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Completable;
			public blockingAwait(timeout: number, param1: java.util.concurrent.TimeUnit): boolean;
			public subscribe(param0: io.reactivex.CompletableObserver): void;
			public doOnEvent(onEvent: io.reactivex.functions.Consumer<any>): io.reactivex.Completable;
			public ambWith(other: io.reactivex.CompletableSource): io.reactivex.Completable;
			public retryWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public static concatArray(...sources: io.reactivex.CompletableSource[]): io.reactivex.Completable;
			public static concat(sources: java.lang.Iterable<any>): io.reactivex.Completable;
			public andThen(next: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public doOnComplete(onComplete: io.reactivex.functions.Action): io.reactivex.Completable;
			public doOnDispose(onDispose: io.reactivex.functions.Action): io.reactivex.Completable;
			public retry(times: number): io.reactivex.Completable;
			public blockingGet(timeout: number, param1: java.util.concurrent.TimeUnit): java.lang.Throwable;
			public hide(): io.reactivex.Completable;
			public static mergeArray(...sources: io.reactivex.CompletableSource[]): io.reactivex.Completable;
			public andThen(next: io.reactivex.CompletableSource): io.reactivex.Completable;
			public concatWith(other: io.reactivex.CompletableSource): io.reactivex.Completable;
			public static ambArray(...sources: io.reactivex.CompletableSource[]): io.reactivex.Completable;
			public retry(times: number, param1: io.reactivex.functions.Predicate<any>): io.reactivex.Completable;
			public static unsafeCreate(source: io.reactivex.CompletableSource): io.reactivex.Completable;
			public static fromRunnable(run: java.lang.Runnable): io.reactivex.Completable;
			public static create(source: io.reactivex.CompletableOnSubscribe): io.reactivex.Completable;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Completable;
			public static mergeDelayError(sources: org.reactivestreams.Publisher<any>): io.reactivex.Completable;
			public subscribe(): io.reactivex.disposables.Disposable;
			public static fromMaybe(maybe: io.reactivex.MaybeSource<any>): io.reactivex.Completable;
			public takeUntil(other: io.reactivex.CompletableSource): io.reactivex.Completable;
			public subscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Completable;
			public onErrorResumeNext(errorMapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public toMaybe(): io.reactivex.Maybe<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>): io.reactivex.Completable;
			public andThen(next: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public doFinally(onFinally: io.reactivex.functions.Action): io.reactivex.Completable;
			public static fromSingle(single: io.reactivex.SingleSource<any>): io.reactivex.Completable;
			public unsubscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Completable;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Completable;
			public subscribeWith(observer: io.reactivex.CompletableObserver): io.reactivex.CompletableObserver;
			public blockingGet(): java.lang.Throwable;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Completable;
			public lift(onLift: io.reactivex.CompletableOperator): io.reactivex.Completable;
			public static fromObservable(observable: io.reactivex.ObservableSource<any>): io.reactivex.Completable;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Completable;
			public compose(transformer: io.reactivex.CompletableTransformer): io.reactivex.Completable;
			public subscribeActual(param0: io.reactivex.CompletableObserver): void;
			public static merge(sources: org.reactivestreams.Publisher<any>, maxConcurrency: number): io.reactivex.Completable;
			public startWith(other: io.reactivex.Observable<any>): io.reactivex.Observable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Completable;
			public to(converter: io.reactivex.functions.Function<any,any>): any;
			public onErrorComplete(): io.reactivex.Completable;
			public toSingle(completionValueSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public materialize(): io.reactivex.Single<any>;
			public as(converter: io.reactivex.CompletableConverter<any>): any;
			public static never(): io.reactivex.Completable;
			public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Completable;
			public static fromAction(run: io.reactivex.functions.Action): io.reactivex.Completable;
			public toObservable(): io.reactivex.Observable<any>;
			public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Completable;
			public andThen(next: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public doOnTerminate(onTerminate: io.reactivex.functions.Action): io.reactivex.Completable;
			public repeatUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Completable;
			public static amb(sources: java.lang.Iterable<any>): io.reactivex.Completable;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Completable;
			public static mergeArrayDelayError(...sources: io.reactivex.CompletableSource[]): io.reactivex.Completable;
			public static merge(sources: java.lang.Iterable<any>): io.reactivex.Completable;
			public andThen(next: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher<any>, maxConcurrency: number): io.reactivex.Completable;
			public static defer(completableSupplier: java.util.concurrent.Callable<any>): io.reactivex.Completable;
			public retry(predicate: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Completable;
			public mergeWith(other: io.reactivex.CompletableSource): io.reactivex.Completable;
			public toSingleDefault(completionValue: any): io.reactivex.Single<any>;
			public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.Completable;
			public cache(): io.reactivex.Completable;
			public doOnError(onError: io.reactivex.functions.Consumer<any>): io.reactivex.Completable;
			public static concat(sources: org.reactivestreams.Publisher<any>): io.reactivex.Completable;
			public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.Completable;
			public static wrap(source: io.reactivex.CompletableSource): io.reactivex.Completable;
			public test(): io.reactivex.observers.TestObserver<java.lang.Void>;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableConverter<R>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableConverter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableConverter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Completable): R;
			});
			public constructor();
			public apply(param0: io.reactivex.Completable): R;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableEmitter extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableEmitter>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableEmitter interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onComplete(): void;
				onError(param0: java.lang.Throwable): void;
				setDisposable(param0: io.reactivex.disposables.Disposable): void;
				setCancellable(param0: io.reactivex.functions.Cancellable): void;
				isDisposed(): boolean;
				tryOnError(param0: java.lang.Throwable): boolean;
			});
			public constructor();
			public tryOnError(param0: java.lang.Throwable): boolean;
			public isDisposed(): boolean;
			public onComplete(): void;
			public setCancellable(param0: io.reactivex.functions.Cancellable): void;
			public setDisposable(param0: io.reactivex.disposables.Disposable): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableObserver extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableObserver>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableObserver interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				onComplete(): void;
				onError(param0: java.lang.Throwable): void;
			});
			public constructor();
			public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
			public onComplete(): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableOnSubscribe extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableOnSubscribe>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableOnSubscribe interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.CompletableEmitter): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.CompletableEmitter): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableOperator extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableOperator>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableOperator interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.CompletableObserver): io.reactivex.CompletableObserver;
			});
			public constructor();
			public apply(param0: io.reactivex.CompletableObserver): io.reactivex.CompletableObserver;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableSource extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableSource>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableSource interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.CompletableObserver): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.CompletableObserver): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class CompletableTransformer extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.CompletableTransformer>;
			/**
			 * Constructs a new instance of the io.reactivex.CompletableTransformer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Completable): io.reactivex.CompletableSource;
			});
			public constructor();
			public apply(param0: io.reactivex.Completable): io.reactivex.CompletableSource;
		}
	}
}

declare module io {
	export module reactivex {
		export class Emitter<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.Emitter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.Emitter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onNext(param0: T): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
			});
			public constructor();
			public onNext(param0: T): void;
			public onComplete(): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Flowable<T>  extends org.reactivestreams.Publisher<any> {
			public static class: java.lang.Class<io.reactivex.Flowable<any>>;
			public switchMap(mapper: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: boolean, scheduler: number): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any): io.reactivex.Flowable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiConsumer<any,any>, disposeState: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public mergeWith(other: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			/** @deprecated */
			public dematerialize(): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
			public timeout(firstTimeoutIndicator: org.reactivestreams.Publisher, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
			public static generate(generator: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Flowable<any>;
			public buffer(count: number, skip: number, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public toList(capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public static combineLatestDelayError(combiner: io.reactivex.functions.Function<any,any>, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public concatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean): io.reactivex.Flowable<any>;
			public static ambArray(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public onErrorReturn(valueSupplier: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public collect(initialItemSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Single<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any): io.reactivex.Flowable<any>;
			public static intervalRange(start: number, param1: number, count: number, param3: number, initialDelay: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.lang.Long>;
			public static concatDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public mergeWith(other: io.reactivex.CompletableSource): io.reactivex.Flowable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public repeatUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Flowable<any>;
			public last(defaultItem: any): io.reactivex.Single<any>;
			public publish(selector: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Flowable<any>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public timeout(itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: io.reactivex.Flowable<any>): io.reactivex.Flowable<any>;
			public static intervalRange(start: number, param1: number, count: number, param3: number, initialDelay: java.util.concurrent.TimeUnit, param5: io.reactivex.Scheduler): io.reactivex.Flowable<java.lang.Long>;
			public static combineLatest(sources: org.reactivestreams.Publisher[], combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public cacheWithInitialCapacity(initialCapacity: number): io.reactivex.Flowable<any>;
			public zipWith(other: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
			public static merge(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static sequenceEqual(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher): io.reactivex.Single<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: java.util.concurrent.Callable<any>, bufferSupplier: boolean): io.reactivex.Flowable<any>;
			public take(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, source8: org.reactivestreams.Publisher, source9: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public static range(start: number, count: number): io.reactivex.Flowable<java.lang.Integer>;
			public buffer(openingIndicator: io.reactivex.Flowable<any>, closingIndicator: io.reactivex.functions.Function<any,any>, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any): io.reactivex.Flowable<any>;
			public static concatDelayError(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public zipWith(other: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Completable;
			public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static concatDelayError(sources: org.reactivestreams.Publisher, prefetch: number, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public doOnLifecycle(onSubscribe: io.reactivex.functions.Consumer<any>, onRequest: io.reactivex.functions.LongConsumer, onCancel: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public reduce(seed: any, reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public static merge(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public concatMapEager(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public concatMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public static fromCallable(supplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, source8: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public withLatestFrom(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Flowable<any>;
			public window(openingIndicator: org.reactivestreams.Publisher, closingIndicator: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public static combineLatestDelayError(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public toList(): io.reactivex.Single<java.util.List<any>>;
			public static zip(sources: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public subscribe(): io.reactivex.disposables.Disposable;
			public switchMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public distinct(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public publish(bufferSize: number): io.reactivex.flowables.ConnectableFlowable<any>;
			public static concatArrayDelayError(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>): void;
			public ambWith(other: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Flowable<any>;
			public lift(lifter: io.reactivex.FlowableOperator<any,any>): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public subscribeWith(subscriber: org.reactivestreams.Subscriber): org.reactivestreams.Subscriber;
			public blockingIterable(): java.lang.Iterable<any>;
			public static concat(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public sorted(): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any, item9: any): io.reactivex.Flowable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public static amb(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
			public take(count: number): io.reactivex.Flowable<any>;
			public switchMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public throttleWithTimeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public skipWhile(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, source8: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
			public withLatestFrom(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public elementAt(index: number, param1: any): io.reactivex.Single<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number): io.reactivex.Flowable<any>;
			public toSortedList(comparator: java.util.Comparator<any>, capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean, delayError: number): io.reactivex.Flowable<any>;
			public static interval(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<java.lang.Long>;
			public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public subscribe(s: org.reactivestreams.Subscriber<any>): void;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, source8: org.reactivestreams.Publisher, source9: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public static combineLatestDelayError(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static concatEager(sources: java.lang.Iterable<any>, maxConcurrency: number, prefetch: number): io.reactivex.Flowable<any>;
			public collectInto(initialItem: any, collector: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Single<any>;
			public static error(throwable: java.lang.Throwable): io.reactivex.Flowable<any>;
			public static switchOnNextDelayError(sources: org.reactivestreams.Publisher, prefetch: number): io.reactivex.Flowable<any>;
			public static concatArrayEagerDelayError(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public onBackpressureBuffer(capacity: number, onOverflow: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public timestamp(unit: java.util.concurrent.TimeUnit): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, time: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public throttleLast(intervalDuration: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public window(openingIndicator: org.reactivestreams.Publisher, closingIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Flowable<any>;
			public buffer(boundaryIndicator: org.reactivestreams.Publisher, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Flowable<any>;
			public window(count: number, param1: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public test(): io.reactivex.subscribers.TestSubscriber<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public subscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean): io.reactivex.Flowable<any>;
			public replay(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): void;
			public window(boundaryIndicator: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static mergeArrayDelayError(maxConcurrency: number, bufferSize: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public onBackpressureDrop(): io.reactivex.Flowable<any>;
			public blockingSubscribe(subscriber: org.reactivestreams.Subscriber<any>): void;
			public static mergeDelayError(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public replay(scheduler: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
			public repeat(): io.reactivex.Flowable<any>;
			public safeSubscribe(s: org.reactivestreams.Subscriber<any>): void;
			public static mergeDelayError(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public flatMapMaybe(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Flowable<any>;
			public sorted(sortFunction: java.util.Comparator<any>): io.reactivex.Flowable<any>;
			public static mergeDelayError(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static switchOnNext(sources: org.reactivestreams.Publisher, bufferSize: number): io.reactivex.Flowable<any>;
			public static merge(sources: java.lang.Iterable<any>, maxConcurrency: number): io.reactivex.Flowable<any>;
			public blockingLast(): any;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Flowable<any>;
			public static fromPublisher(source: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public retryUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Flowable<any>;
			public takeLast(count: number): io.reactivex.Flowable<any>;
			public static concatArray(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public isEmpty(): io.reactivex.Single<java.lang.Boolean>;
			public onBackpressureBuffer(delayError: boolean): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public debounce(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, bufferSize: number): void;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public flatMapSingle(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Flowable<any>;
			public singleOrError(): io.reactivex.Single<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public any(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Single<java.lang.Boolean>;
			public startWith(other: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public doOnCancel(onCancel: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public concatMapIterable(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public blockingMostRecent(initialItem: any): java.lang.Iterable<any>;
			public debounce(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public blockingNext(): java.lang.Iterable<any>;
			public toFuture(): java.util.concurrent.Future<any>;
			public toSortedList(): io.reactivex.Single<java.util.List<any>>;
			public delay(itemDelayIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public startWith(value: any): io.reactivex.Flowable<any>;
			public withLatestFrom(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Flowable<any>;
			public zipWith(other: java.lang.Iterable<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.util.List<any>>;
			public cast(clazz: java.lang.Class<any>): io.reactivex.Flowable<any>;
			public concatMapEagerDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public scan(initialValue: any, accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public static concat(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public skip(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static concat(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Flowable<any>;
			public static zip(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static zipIterable(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
			public switchMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public toList(collectionSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public replay(): io.reactivex.flowables.ConnectableFlowable<any>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public static concat(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public retry(): io.reactivex.Flowable<any>;
			public switchMapDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public blockingSingle(): any;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public doAfterTerminate(onAfterTerminate: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>, collectionFactory: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static combineLatest(sources: org.reactivestreams.Publisher[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public publish(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.util.List<any>>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.lang.Long>;
			public doOnError(onError: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public concatWith(other: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static sequenceEqual(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, bufferSize: number): io.reactivex.Single<any>;
			public firstElement(): io.reactivex.Maybe<any>;
			public test(initialRequest: number): io.reactivex.subscribers.TestSubscriber<any>;
			public static fromArray(...items: any[]): io.reactivex.Flowable<any>;
			public timeout(firstTimeoutIndicator: org.reactivestreams.Publisher, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public concatMapMaybe(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public concatMapEager(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number): io.reactivex.Flowable<any>;
			public window(boundaryIndicator: org.reactivestreams.Publisher, bufferSize: number): io.reactivex.Flowable<any>;
			public flatMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static just(item: any): io.reactivex.Flowable<any>;
			public scanWith(seedSupplier: java.util.concurrent.Callable<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public blockingSubscribe(): void;
			public elementAt(index: number): io.reactivex.Maybe<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public to(converter: io.reactivex.functions.Function<any,any>): any;
			public retry(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public window(count: number, param1: number, skip: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public parallel(): io.reactivex.parallel.ParallelFlowable<any>;
			public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any): io.reactivex.Flowable<any>;
			public replay(bufferSize: number, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public onBackpressureBuffer(capacity: number): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any): io.reactivex.Flowable<any>;
			public static mergeArrayDelayError(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public withLatestFrom(other: org.reactivestreams.Publisher, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public takeUntil(stopPredicate: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public onBackpressureBuffer(capacity: number, delayError: boolean, unbounded: boolean, onOverflow: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public onErrorResumeNext(resumeFunction: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public switchMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static fromIterable(source: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public distinct(keySelector: io.reactivex.functions.Function<any,any>, collectionSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public timestamp(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public concatWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Flowable<any>;
			public blockingFirst(defaultItem: any): any;
			public repeatWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public blockingSingle(defaultItem: any): any;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Flowable<any>;
			public distinctUntilChanged(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public concatMap(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public retry(count: number): io.reactivex.Flowable<any>;
			public withLatestFrom(others: org.reactivestreams.Publisher[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public concatMapSingle(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public lastElement(): io.reactivex.Maybe<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static concatEager(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public compose(composer: io.reactivex.FlowableTransformer<any,any>): io.reactivex.Flowable<any>;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>): io.reactivex.disposables.Disposable;
			public timeInterval(): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public static mergeArray(maxConcurrency: number, bufferSize: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public toSortedList(capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public static merge(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Completable;
			public first(defaultItem: any): io.reactivex.Single<any>;
			public onErrorReturnItem(item: any): io.reactivex.Flowable<any>;
			public skip(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public withLatestFrom(others: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number): io.reactivex.Flowable<any>;
			public static concat(sources: org.reactivestreams.Publisher, prefetch: number): io.reactivex.Flowable<any>;
			public static concatEager(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public onErrorResumeNext(next: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.Flowable<java.util.List<any>>;
			public onBackpressureBuffer(capacity: number, param1: io.reactivex.functions.Action, onOverflow: io.reactivex.BackpressureOverflowStrategy): io.reactivex.Flowable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public subscribeOn(scheduler: io.reactivex.Scheduler, requestOn: boolean): io.reactivex.Flowable<any>;
			public replay(bufferSize: number): io.reactivex.flowables.ConnectableFlowable<any>;
			public concatWith(other: io.reactivex.CompletableSource): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: boolean): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public blockingLatest(): java.lang.Iterable<any>;
			public concatWith(other: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public flatMap(onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public switchMapDelayError(mapper: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public window(boundaryIndicatorSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public doOnComplete(onComplete: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public static concatArrayEager(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public static switchOnNext(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static concat(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public throttleWithTimeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
			public static mergeArray(...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public doAfterNext(onAfterNext: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public static merge(sources: org.reactivestreams.Publisher, maxConcurrency: number): io.reactivex.Flowable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean): io.reactivex.Flowable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public startWith(items: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public distinctUntilChanged(): io.reactivex.Flowable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, delayError: boolean): io.reactivex.Flowable<any>;
			public concatMapCompletable(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Completable;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, zipper: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Flowable<any>;
			public switchIfEmpty(other: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, resourceDisposer: io.reactivex.functions.Consumer<any>, eager: boolean): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Flowable<java.util.List<any>>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, bufferSize: number): void;
			public join(other: org.reactivestreams.Publisher, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public doFinally(onFinally: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: boolean, param5: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public groupJoin(other: org.reactivestreams.Publisher, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public contains(item: any): io.reactivex.Single<java.lang.Boolean>;
			public static concatArrayEager(maxConcurrency: number, prefetch: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public delaySubscription(subscriptionIndicator: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public takeUntil(other: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public sample(sampler: org.reactivestreams.Publisher, emitLast: boolean): io.reactivex.Flowable<any>;
			public buffer(boundaryIndicator: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>, prefetch: number): io.reactivex.Flowable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public timeInterval(unit: java.util.concurrent.TimeUnit): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number): io.reactivex.Flowable<java.util.List<any>>;
			public window(count: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public unsubscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static rangeLong(start: number, param1: number): io.reactivex.Flowable<java.lang.Long>;
			public static zipArray(zipper: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public blockingLast(defaultItem: any): any;
			public static error(supplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public takeWhile(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public doOnTerminate(onTerminate: io.reactivex.functions.Action): io.reactivex.Flowable<any>;
			public static never(): io.reactivex.Flowable<any>;
			public debounce(debounceIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public skip(count: number): io.reactivex.Flowable<any>;
			public concatMapIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public doOnNext(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public onBackpressureDrop(onDrop: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>, maxConcurrency: number): io.reactivex.Flowable<any>;
			public buffer(boundaryIndicatorSupplier: java.util.concurrent.Callable<any>, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public switchMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public static unsafeCreate(onSubscribe: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public timestamp(unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number): io.reactivex.Flowable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Flowable<any>;
			public onExceptionResumeNext(next: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public throttleLast(intervalDuration: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, source7: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public forEach(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public repeat(times: number): io.reactivex.Flowable<any>;
			public singleElement(): io.reactivex.Maybe<any>;
			public count(): io.reactivex.Single<java.lang.Long>;
			public static sequenceEqual(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, isEqual: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Single<any>;
			public buffer(openingIndicator: io.reactivex.Flowable<any>, closingIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public delay(subscriptionIndicator: org.reactivestreams.Publisher, itemDelayIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static merge(sources: java.lang.Iterable<any>, maxConcurrency: number, bufferSize: number): io.reactivex.Flowable<any>;
			public materialize(): io.reactivex.Flowable<io.reactivex.Notification<any>>;
			public serialize(): io.reactivex.Flowable<any>;
			public static zip(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public parallel(parallelism: number, prefetch: number): io.reactivex.parallel.ParallelFlowable<any>;
			public replay(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.flowables.ConnectableFlowable<any>;
			public share(): io.reactivex.Flowable<any>;
			public static empty(): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public static merge(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static interval(period: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.lang.Long>;
			public static combineLatest(combiner: io.reactivex.functions.Function<any,any>, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,any,any>, disposeState: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public cache(): io.reactivex.Flowable<any>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public blockingFirst(): any;
			public scan(accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public static combineLatest(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public dematerialize(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public test(initialRequest: number, param1: boolean): io.reactivex.subscribers.TestSubscriber<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, delayError: boolean): io.reactivex.Flowable<any>;
			public parallel(parallelism: number): io.reactivex.parallel.ParallelFlowable<any>;
			public doOnEach(subscriber: org.reactivestreams.Subscriber<any>): io.reactivex.Flowable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static sequenceEqual(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, isEqual: io.reactivex.functions.BiPredicate<any,any>, bufferSize: number): io.reactivex.Single<any>;
			public as(converter: io.reactivex.FlowableConverter<any,any>): any;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public timeout(itemTimeoutIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public zipWith(other: org.reactivestreams.Publisher, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean): io.reactivex.Flowable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): void;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public constructor();
			public replay(bufferSize: number, scheduler: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
			public static defer(supplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public retry(times: number, param1: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Completable;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Flowable<any>;
			public distinctUntilChanged(comparer: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Flowable<any>;
			public timestamp(): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>, prefetch: number, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public retry(predicate: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Flowable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number, evictingMapFactory: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public take(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<java.lang.Long>;
			public onBackpressureBuffer(capacity: number, delayError: boolean, unbounded: boolean): io.reactivex.Flowable<any>;
			public concatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any): io.reactivex.Flowable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public toSortedList(comparator: java.util.Comparator<any>): io.reactivex.Single<java.util.List<any>>;
			public static interval(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Flowable<java.lang.Long>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, source5: org.reactivestreams.Publisher, source6: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Flowable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Flowable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number, count: boolean): io.reactivex.Flowable<io.reactivex.Flowable<any>>;
			public doOnRequest(onRequest: io.reactivex.functions.LongConsumer): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher, maxConcurrency: number): io.reactivex.Flowable<any>;
			public reduceWith(seedSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public retryWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public blockingForEach(onNext: io.reactivex.functions.Consumer<any>): void;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public flatMap(onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>, maxConcurrency: number): io.reactivex.Flowable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler, scheduler: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public static merge(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public concatMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public distinct(): io.reactivex.Flowable<any>;
			public static combineLatestDelayError(sources: org.reactivestreams.Publisher[], combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Flowable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any, item9: any, item10: any): io.reactivex.Flowable<any>;
			public filter(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Flowable<any>;
			public lastOrError(): io.reactivex.Single<any>;
			public publish(): io.reactivex.flowables.ConnectableFlowable<any>;
			public throttleFirst(skipDuration: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public doOnEach(onNotification: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public static concatArrayEagerDelayError(maxConcurrency: number, prefetch: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>, maxConcurrency: number, bufferSize: number): io.reactivex.Flowable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Flowable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Flowable<any>;
			public rebatchRequests(n: number): io.reactivex.Flowable<any>;
			public blockingIterable(bufferSize: number): java.lang.Iterable<any>;
			public static combineLatest(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher, combiner: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Flowable<any>;
			public timeInterval(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public limit(count: number): io.reactivex.Flowable<any>;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public switchMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static combineLatest(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
			public switchMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Flowable<any>;
			public timeInterval(unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<io.reactivex.schedulers.Timed<any>>;
			public static switchOnNextDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public firstOrError(): io.reactivex.Single<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
			public onBackpressureLatest(): io.reactivex.Flowable<any>;
			public startWithArray(...items: any[]): io.reactivex.Flowable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<java.util.List<any>>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, bufferSize: number): void;
			public toObservable(): io.reactivex.Observable<any>;
			public skipUntil(other: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static interval(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit): io.reactivex.Flowable<java.lang.Long>;
			public hide(): io.reactivex.Flowable<any>;
			public buffer(count: number, skip: number): io.reactivex.Flowable<java.util.List<any>>;
			public defaultIfEmpty(defaultItem: any): io.reactivex.Flowable<any>;
			public elementAtOrError(index: number): io.reactivex.Single<any>;
			public throttleFirst(windowDuration: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public concatMapEagerDelayError(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number, tillTheEnd: boolean): io.reactivex.Flowable<any>;
			public static combineLatestDelayError(combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, ...sources: org.reactivestreams.Publisher[]): io.reactivex.Flowable<any>;
			public reduce(reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Maybe<any>;
			public window(boundaryIndicatorSupplier: java.util.concurrent.Callable<any>, bufferSize: number): io.reactivex.Flowable<any>;
			public static combineLatestDelayError(sources: org.reactivestreams.Publisher[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public onBackpressureBuffer(): io.reactivex.Flowable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, maxConcurrency: number): io.reactivex.Flowable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean, delayError: number): io.reactivex.Flowable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public buffer(boundaryIndicator: org.reactivestreams.Publisher, initialCapacity: number): io.reactivex.Flowable<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			public buffer(boundaryIndicatorSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public ofType(clazz: java.lang.Class<any>): io.reactivex.Flowable<any>;
			public replay(bufferSize: number, time: number, param2: java.util.concurrent.TimeUnit): io.reactivex.flowables.ConnectableFlowable<any>;
			public all(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Single<java.lang.Boolean>;
			public static mergeDelayError(source1: org.reactivestreams.Publisher, source2: org.reactivestreams.Publisher, source3: org.reactivestreams.Publisher, source4: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public buffer(count: number, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Flowable<any>;
			public static bufferSize(): number;
			public onTerminateDetach(): io.reactivex.Flowable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Flowable<any>;
			public sample(sampler: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public flatMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, resourceDisposer: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
			public single(defaultItem: any): io.reactivex.Single<any>;
			public ignoreElements(): io.reactivex.Completable;
			public skipLast(count: number): io.reactivex.Flowable<any>;
			public map(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public onBackpressureBuffer(capacity: number, delayError: boolean): io.reactivex.Flowable<any>;
			public static concatEager(sources: org.reactivestreams.Publisher, maxConcurrency: number, prefetch: number): io.reactivex.Flowable<any>;
			public mergeWith(other: org.reactivestreams.Publisher<any>): io.reactivex.Flowable<any>;
			public mergeWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public buffer(count: number): io.reactivex.Flowable<java.util.List<any>>;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableConverter<T, R>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.FlowableConverter<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableConverter<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Flowable<T>): R;
			});
			public constructor();
			public apply(param0: io.reactivex.Flowable<T>): R;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableEmitter<T>  extends io.reactivex.Emitter<any> {
			public static class: java.lang.Class<io.reactivex.FlowableEmitter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableEmitter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				setDisposable(param0: io.reactivex.disposables.Disposable): void;
				setCancellable(param0: io.reactivex.functions.Cancellable): void;
				requested(): number;
				isCancelled(): boolean;
				serialize(): io.reactivex.FlowableEmitter<any>;
				tryOnError(param0: java.lang.Throwable): boolean;
				onNext(param0: any): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
			});
			public constructor();
			public tryOnError(param0: java.lang.Throwable): boolean;
			public setCancellable(param0: io.reactivex.functions.Cancellable): void;
			public onComplete(): void;
			public setDisposable(param0: io.reactivex.disposables.Disposable): void;
			public isCancelled(): boolean;
			public serialize(): io.reactivex.FlowableEmitter<any>;
			public onNext(param0: any): void;
			public onError(param0: java.lang.Throwable): void;
			public requested(): number;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableOnSubscribe<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.FlowableOnSubscribe<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableOnSubscribe<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.FlowableEmitter<T>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.FlowableEmitter<T>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableOperator<Downstream, Upstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.FlowableOperator<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableOperator<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: org.reactivestreams.Subscriber<any>): org.reactivestreams.Subscriber<any>;
			});
			public constructor();
			public apply(param0: org.reactivestreams.Subscriber<any>): org.reactivestreams.Subscriber<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableSubscriber<T>  extends org.reactivestreams.Subscriber<any> {
			public static class: java.lang.Class<io.reactivex.FlowableSubscriber<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableSubscriber<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSubscribe(param0: org.reactivestreams.Subscription): void;
				onComplete(): void;
				onError(param0: java.lang.Throwable): void;
				onNext(param0: any): void;
				onSubscribe(param0: org.reactivestreams.Subscription): void;
			});
			public constructor();
			public onSubscribe(param0: org.reactivestreams.Subscription): void;
			public onComplete(): void;
			public onError(param0: java.lang.Throwable): void;
			public onNext(param0: any): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class FlowableTransformer<Upstream, Downstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.FlowableTransformer<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.FlowableTransformer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Flowable<Upstream>): org.reactivestreams.Publisher<Downstream>;
			});
			public constructor();
			public apply(param0: io.reactivex.Flowable<Upstream>): org.reactivestreams.Publisher<Downstream>;
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Maybe<T>  extends io.reactivex.MaybeSource<any> {
			public static class: java.lang.Class<io.reactivex.Maybe<any>>;
			public switchIfEmpty(other: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public repeat(): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public static concatEager(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public onErrorReturn(valueSupplier: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public flatMapSingleElement(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public map(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public static merge(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public static fromAction(run: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public ambWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static create(onSubscribe: io.reactivex.MaybeOnSubscribe<any>): io.reactivex.Maybe<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, source5: io.reactivex.MaybeSource<any>, source6: io.reactivex.MaybeSource<any>, source7: io.reactivex.MaybeSource<any>, source8: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Maybe<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Maybe<any>;
			public flattenAsFlowable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public takeUntil(other: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public doOnTerminate(onTerminate: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public static mergeArrayDelayError(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Flowable<any>;
			public static empty(): io.reactivex.Maybe<any>;
			public flatMap(onSuccessMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>): io.reactivex.Maybe<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, source5: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Maybe<any>;
			public static defer(maybeSupplier: java.util.concurrent.Callable<any>): io.reactivex.Maybe<any>;
			public static concat(sources: org.reactivestreams.Publisher, prefetch: number): io.reactivex.Flowable<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Maybe<java.lang.Long>;
			public blockingGet(): any;
			public toFlowable(): io.reactivex.Flowable<any>;
			public static error(supplier: java.util.concurrent.Callable<any>): io.reactivex.Maybe<any>;
			public static concatEager(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static fromCompletable(completableSource: io.reactivex.CompletableSource): io.reactivex.Maybe<any>;
			public static sequenceEqual(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>): io.reactivex.Single<any>;
			public static zipArray(zipper: io.reactivex.functions.Function<any,any>, ...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Maybe<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler, scheduler: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Maybe<any>;
			public ignoreElement(): io.reactivex.Completable;
			public static just(item: any): io.reactivex.Maybe<any>;
			public retry(predicate: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Maybe<any>;
			public retryWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public isEmpty(): io.reactivex.Single<java.lang.Boolean>;
			public constructor();
			public static concatDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public test(): io.reactivex.observers.TestObserver<any>;
			public compose(transformer: io.reactivex.MaybeTransformer<any,any>): io.reactivex.Maybe<any>;
			public repeatUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Flowable<any>;
			public doAfterSuccess(onAfterSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.Maybe<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public retry(): io.reactivex.Maybe<any>;
			public retry(times: number, param1: io.reactivex.functions.Predicate<any>): io.reactivex.Maybe<any>;
			public static fromRunnable(run: java.lang.Runnable): io.reactivex.Maybe<any>;
			public static merge(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public static concat(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Maybe<any>;
			public delay(delayIndicator: org.reactivestreams.Publisher): io.reactivex.Maybe<any>;
			public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
			public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Maybe<any>;
			public unsubscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public flatMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public onErrorResumeNext(next: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static error(exception: java.lang.Throwable): io.reactivex.Maybe<any>;
			public static merge(sources: org.reactivestreams.Publisher, maxConcurrency: number): io.reactivex.Flowable<any>;
			public static mergeDelayError(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, resourceDisposer: io.reactivex.functions.Consumer<any>): io.reactivex.Maybe<any>;
			public static concatDelayError(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher, maxConcurrency: number): io.reactivex.Flowable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Maybe<any>;
			public concatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public timeout(timeoutIndicator: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Maybe<any>;
			public flattenAsObservable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static merge(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public contains(item: any): io.reactivex.Single<java.lang.Boolean>;
			public static mergeDelayError(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public toSingle(defaultValue: any): io.reactivex.Single<any>;
			public zipWith(other: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Maybe<any>;
			public static sequenceEqual(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, isEqual: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Single<any>;
			public takeUntil(other: org.reactivestreams.Publisher): io.reactivex.Maybe<any>;
			public doAfterTerminate(onAfterTerminate: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public static zip(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public materialize(): io.reactivex.Single<io.reactivex.Notification<any>>;
			public ofType(clazz: java.lang.Class<any>): io.reactivex.Maybe<any>;
			public subscribe(): io.reactivex.disposables.Disposable;
			public toSingle(): io.reactivex.Single<any>;
			public doOnSuccess(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.Maybe<any>;
			public static merge(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public onErrorComplete(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Maybe<any>;
			public defaultIfEmpty(defaultItem: any): io.reactivex.Maybe<any>;
			public static mergeArray(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Flowable<any>;
			public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.Maybe<any>;
			public static concat(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public subscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public static fromSingle(singleSource: io.reactivex.SingleSource<any>): io.reactivex.Maybe<any>;
			public static merge(source: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static concatArrayDelayError(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Flowable<any>;
			public doOnDispose(onDispose: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Maybe<any>;
			public cast(clazz: java.lang.Class<any>): io.reactivex.Maybe<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Maybe<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Maybe<java.lang.Long>;
			public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
			public static concat(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public onErrorResumeNext(resumeFunction: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public timeout(timeoutIndicator: io.reactivex.MaybeSource<any>, fallback: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public delaySubscription(subscriptionIndicator: org.reactivestreams.Publisher): io.reactivex.Maybe<any>;
			public doFinally(onFinally: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public timeout(timeoutIndicator: org.reactivestreams.Publisher): io.reactivex.Maybe<any>;
			public retryUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Maybe<any>;
			public doOnComplete(onComplete: io.reactivex.functions.Action): io.reactivex.Maybe<any>;
			public toObservable(): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, source5: io.reactivex.MaybeSource<any>, source6: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Maybe<any>;
			public as(converter: io.reactivex.MaybeConverter<any,any>): any;
			public test(cancelled: boolean): io.reactivex.observers.TestObserver<any>;
			public doOnEvent(onEvent: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Maybe<any>;
			public subscribeWith(observer: io.reactivex.MaybeObserver<any>): io.reactivex.MaybeObserver<any>;
			public cache(): io.reactivex.Maybe<any>;
			public static concat(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public static fromCallable(callable: java.util.concurrent.Callable<any>): io.reactivex.Maybe<any>;
			public retry(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Maybe<any>;
			public doOnError(onError: io.reactivex.functions.Consumer<any>): io.reactivex.Maybe<any>;
			public onErrorComplete(): io.reactivex.Maybe<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.Maybe<any>;
			public timeout(timeoutIndicator: org.reactivestreams.Publisher, fallback: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static concatArrayEager(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Flowable<any>;
			public blockingGet(defaultValue: any): any;
			public flatMapPublisher(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static amb(sources: java.lang.Iterable<any>): io.reactivex.Maybe<any>;
			public onExceptionResumeNext(next: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public repeat(times: number): io.reactivex.Flowable<any>;
			public count(): io.reactivex.Single<java.lang.Long>;
			public static wrap(source: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public retry(count: number): io.reactivex.Maybe<any>;
			public hide(): io.reactivex.Maybe<any>;
			public lift(lift: io.reactivex.MaybeOperator<any,any>): io.reactivex.Maybe<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, resourceDisposer: io.reactivex.functions.Consumer<any>, eager: boolean): io.reactivex.Maybe<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, source5: io.reactivex.MaybeSource<any>, source6: io.reactivex.MaybeSource<any>, source7: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Maybe<any>;
			public flatMapObservable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public to(convert: io.reactivex.functions.Function<any,any>): any;
			public static mergeDelayError(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public static unsafeCreate(onSubscribe: io.reactivex.MaybeSource<any>): io.reactivex.Maybe<any>;
			public static never(): io.reactivex.Maybe<any>;
			public switchIfEmpty(other: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public static zip(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>, source5: io.reactivex.MaybeSource<any>, source6: io.reactivex.MaybeSource<any>, source7: io.reactivex.MaybeSource<any>, source8: io.reactivex.MaybeSource<any>, source9: io.reactivex.MaybeSource<any>, zipper: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Maybe<any>;
			public filter(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Maybe<any>;
			public concatWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public static concatArray(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Flowable<any>;
			public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public repeatWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public onErrorReturnItem(item: any): io.reactivex.Maybe<any>;
			public onTerminateDetach(): io.reactivex.Maybe<any>;
			public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
			public static merge(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static ambArray(...sources: io.reactivex.MaybeSource<any>[]): io.reactivex.Maybe<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Maybe<any>;
			public static concat(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, source3: io.reactivex.MaybeSource<any>, source4: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
			public mergeWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Flowable<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeConverter<T, R>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeConverter<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeConverter<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Maybe<T>): R;
			});
			public constructor();
			public apply(param0: io.reactivex.Maybe<T>): R;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeEmitter<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeEmitter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeEmitter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSuccess(param0: T): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
				setDisposable(param0: io.reactivex.disposables.Disposable): void;
				setCancellable(param0: io.reactivex.functions.Cancellable): void;
				isDisposed(): boolean;
				tryOnError(param0: java.lang.Throwable): boolean;
			});
			public constructor();
			public tryOnError(param0: java.lang.Throwable): boolean;
			public isDisposed(): boolean;
			public onComplete(): void;
			public setCancellable(param0: io.reactivex.functions.Cancellable): void;
			public onSuccess(param0: T): void;
			public setDisposable(param0: io.reactivex.disposables.Disposable): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeObserver<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeObserver<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeObserver<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				onSuccess(param0: T): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
			});
			public constructor();
			public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
			public onComplete(): void;
			public onSuccess(param0: T): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeOnSubscribe<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeOnSubscribe<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeOnSubscribe<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.MaybeEmitter<T>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.MaybeEmitter<T>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeOperator<Downstream, Upstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeOperator<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeOperator<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.MaybeObserver<any>): io.reactivex.MaybeObserver<any>;
			});
			public constructor();
			public apply(param0: io.reactivex.MaybeObserver<any>): io.reactivex.MaybeObserver<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeSource<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeSource<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.MaybeObserver<any>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class MaybeTransformer<Upstream, Downstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.MaybeTransformer<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.MaybeTransformer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Maybe<Upstream>): io.reactivex.MaybeSource<Downstream>;
			});
			public constructor();
			public apply(param0: io.reactivex.Maybe<Upstream>): io.reactivex.MaybeSource<Downstream>;
		}
	}
}

declare module io {
	export module reactivex {
		export class Notification<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.Notification<any>>;
			public isOnError(): boolean;
			public static createOnComplete(): io.reactivex.Notification<any>;
			public toString(): string;
			public equals(obj: any): boolean;
			public isOnNext(): boolean;
			public static createOnError(error: java.lang.Throwable): io.reactivex.Notification<any>;
			public static createOnNext(value: any): io.reactivex.Notification<any>;
			public getError(): java.lang.Throwable;
			public getValue(): T;
			public isOnComplete(): boolean;
			public hashCode(): number;
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Observable<T>  extends io.reactivex.ObservableSource<any> {
			public static class: java.lang.Class<io.reactivex.Observable<any>>;
			public buffer(boundary: io.reactivex.ObservableSource<any>, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public blockingMostRecent(initialValue: any): java.lang.Iterable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<java.util.List<any>>;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public collect(initialValueSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Single<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public throttleLast(intervalDuration: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public buffer(count: number, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public delay(itemDelay: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Observable<any>;
			public static zip(sources: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static mergeDelayError(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public publish(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public toList(capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public switchMapDelayError(mapper: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public subscribe(param0: io.reactivex.Observer<any>): void;
			public concatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public timeInterval(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public static combineLatest(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public mergeWith(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static combineLatest(sources: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public window(openingIndicator: io.reactivex.ObservableSource<any>, closingIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public static concatDelayError(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public test(): io.reactivex.observers.TestObserver<any>;
			public last(defaultItem: any): io.reactivex.Single<any>;
			public flatMapSingle(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean): io.reactivex.Observable<any>;
			public repeatUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Observable<any>;
			public switchMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public sorted(sortFunction: java.util.Comparator<any>): io.reactivex.Observable<any>;
			public distinctUntilChanged(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public zipWith(other: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public static wrap(source: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Observable<any>;
			public static mergeDelayError(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public mergeWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Observable<any>;
			public static sequenceEqual(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, bufferSize: number): io.reactivex.Single<any>;
			public concatMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public buffer(count: number, skip: number, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public debounce(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public zipWith(other: java.lang.Iterable<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public reduce(seed: any, reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public skipUntil(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public debounce(debounceSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static switchOnNext(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static concatArrayEager(maxConcurrency: number, prefetch: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public ofType(clazz: java.lang.Class<any>): io.reactivex.Observable<any>;
			public static intervalRange(start: number, param1: number, count: number, param3: number, initialDelay: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.lang.Long>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any): io.reactivex.Observable<any>;
			public concatMapEagerDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean): io.reactivex.Observable<any>;
			public share(): io.reactivex.Observable<any>;
			public toList(): io.reactivex.Single<java.util.List<any>>;
			public subscribe(): io.reactivex.disposables.Disposable;
			public switchMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static switchOnNext(sources: io.reactivex.ObservableSource<any>, bufferSize: number): io.reactivex.Observable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>): void;
			public static combineLatest(sources: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public replay(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
			public window(boundary: io.reactivex.ObservableSource<any>, bufferSize: number): io.reactivex.Observable<any>;
			public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public static combineLatestDelayError(sources: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public static zipArray(zipper: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public static fromArray(...items: any[]): io.reactivex.Observable<any>;
			public static fromCallable(supplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public startWithArray(...items: any[]): io.reactivex.Observable<any>;
			public onErrorReturnItem(item: any): io.reactivex.Observable<any>;
			public startWith(item: any): io.reactivex.Observable<any>;
			public throttleFirst(skipDuration: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, source8: io.reactivex.ObservableSource<any>, source9: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public blockingIterable(): java.lang.Iterable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public static interval(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<java.lang.Long>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public static unsafeCreate(onSubscribe: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public doOnDispose(onDispose: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
			public blockingSubscribe(observer: io.reactivex.Observer<any>): void;
			public groupJoin(other: io.reactivex.ObservableSource<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public takeWhile(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public throttleLast(intervalDuration: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static concatEager(sources: java.lang.Iterable<any>, maxConcurrency: number, prefetch: number): io.reactivex.Observable<any>;
			public distinct(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public take(count: number): io.reactivex.Observable<any>;
			public elementAt(index: number, param1: any): io.reactivex.Single<any>;
			public toSortedList(comparator: java.util.Comparator<any>, capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: boolean, param5: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public static concatDelayError(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, source8: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public switchMap(mapper: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public doOnEach(observer: io.reactivex.Observer<any>): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Observable<java.util.List<any>>;
			public window(openingIndicator: io.reactivex.ObservableSource<any>, closingIndicator: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public concatMapCompletable(mapper: io.reactivex.functions.Function<any,any>, capacityHint: number): io.reactivex.Completable;
			public throttleFirst(windowDuration: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public timeInterval(unit: java.util.concurrent.TimeUnit): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler, scheduler: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, time: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public timeout(firstTimeoutIndicator: io.reactivex.ObservableSource<any>, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public scanWith(seedSupplier: java.util.concurrent.Callable<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public static mergeArray(maxConcurrency: number, bufferSize: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public mergeWith(other: io.reactivex.CompletableSource): io.reactivex.Observable<any>;
			public map(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public buffer(boundary: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): void;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public static concat(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public static concatArrayEager(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Observable<any>;
			public doFinally(onFinally: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number, count: boolean): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public mergeWith(other: io.reactivex.SingleSource<any>): io.reactivex.Observable<any>;
			public take(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public blockingLast(): any;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public safeSubscribe(observer: io.reactivex.Observer<any>): void;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public flatMapMaybe(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean): io.reactivex.Observable<any>;
			public flatMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public throttleWithTimeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public withLatestFrom(others: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static combineLatestDelayError(combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public isEmpty(): io.reactivex.Single<java.lang.Boolean>;
			public static error(errorSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public onTerminateDetach(): io.reactivex.Observable<any>;
			public switchMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static sequenceEqual(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>): io.reactivex.Single<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.Observable<any>;
			public toMap(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public doOnComplete(onComplete: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public static interval(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Observable<java.lang.Long>;
			public singleOrError(): io.reactivex.Single<any>;
			public static concatArray(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public any(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Single<java.lang.Boolean>;
			public contains(element: any): io.reactivex.Single<java.lang.Boolean>;
			public blockingNext(): java.lang.Iterable<any>;
			public toFuture(): java.util.concurrent.Future<any>;
			public timeout(firstTimeoutIndicator: io.reactivex.ObservableSource<any>, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public toSortedList(): io.reactivex.Single<java.util.List<any>>;
			public window(boundary: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>, maxConcurrency: number, bufferSize: number): io.reactivex.Observable<any>;
			public timestamp(unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public timeout(itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public timestamp(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Observable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public unsubscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static mergeDelayError(sources: io.reactivex.ObservableSource<any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public serialize(): io.reactivex.Observable<any>;
			public sample(sampler: io.reactivex.ObservableSource<any>, emitLast: boolean): io.reactivex.Observable<any>;
			public retry(times: number): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number): io.reactivex.Observable<java.util.List<any>>;
			public static combineLatest(combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public toList(collectionSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public static concat(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<java.lang.Long>;
			public static concat(sources: io.reactivex.ObservableSource<any>, prefetch: number): io.reactivex.Observable<any>;
			public concatMapIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static merge(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public blockingSingle(): any;
			public flatMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, mapSupplier: java.util.concurrent.Callable<any>, collectionFactory: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public startWith(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static zip(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public distinct(): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public collectInto(initialValue: any, collector: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Single<any>;
			public takeUntil(stopPredicate: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any): io.reactivex.Observable<any>;
			public firstElement(): io.reactivex.Maybe<any>;
			public onErrorResumeNext(next: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public switchMapDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.Observable<java.util.List<any>>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public subscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public concatMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public concatWith(other: io.reactivex.CompletableSource): io.reactivex.Observable<any>;
			public hide(): io.reactivex.Observable<any>;
			public concatWith(other: io.reactivex.SingleSource<any>): io.reactivex.Observable<any>;
			public blockingSubscribe(): void;
			public elementAt(index: number): io.reactivex.Maybe<any>;
			public to(converter: io.reactivex.functions.Function<any,any>): any;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public test(dispose: boolean): io.reactivex.observers.TestObserver<any>;
			public withLatestFrom(o1: io.reactivex.ObservableSource<any>, o2: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Observable<any>;
			public buffer(openingIndicator: io.reactivex.ObservableSource<any>, closingIndicator: io.reactivex.functions.Function<any,any>, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public cacheWithInitialCapacity(initialCapacity: number): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: java.util.concurrent.Callable<any>, bufferSupplier: boolean): io.reactivex.Observable<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public timeout(itemTimeoutIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static interval(period: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.lang.Long>;
			public withLatestFrom(o1: io.reactivex.ObservableSource<any>, o2: io.reactivex.ObservableSource<any>, o3: io.reactivex.ObservableSource<any>, o4: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
			public flatMap(onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public static mergeArray(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public doOnNext(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public retryWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public retryUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Observable<any>;
			public static zipIterable(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
			public toFlowable(strategy: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
			public skip(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any): io.reactivex.Observable<any>;
			public static concatEager(sources: io.reactivex.ObservableSource<any>, maxConcurrency: number, prefetch: number): io.reactivex.Observable<any>;
			public static range(start: number, count: number): io.reactivex.Observable<java.lang.Integer>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean): io.reactivex.Completable;
			public static just(item1: any, item2: any, item3: any): io.reactivex.Observable<any>;
			public blockingFirst(defaultItem: any): any;
			public blockingSingle(defaultItem: any): any;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any, item9: any): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.util.List<any>>;
			public static merge(sources: io.reactivex.ObservableSource<any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public lastElement(): io.reactivex.Maybe<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Observable<any>;
			public sorted(): io.reactivex.Observable<any>;
			public static merge(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public replay(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.observables.ConnectableObservable<any>;
			public static rangeLong(start: number, param1: number): io.reactivex.Observable<java.lang.Long>;
			public publish(): io.reactivex.observables.ConnectableObservable<any>;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>): io.reactivex.disposables.Disposable;
			public toSortedList(capacityHint: number): io.reactivex.Single<java.util.List<any>>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Observable<any>;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Observable<any>;
			public distinctUntilChanged(): io.reactivex.Observable<any>;
			public compose(composer: io.reactivex.ObservableTransformer<any,any>): io.reactivex.Observable<any>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Completable;
			public concatMapSingle(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Observable<any>;
			public first(defaultItem: any): io.reactivex.Single<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, source8: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public concatWith(other: io.reactivex.MaybeSource<any>): io.reactivex.Observable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.lang.Long>;
			public static fromPublisher(publisher: org.reactivestreams.Publisher): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public static combineLatestDelayError(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public blockingLatest(): java.lang.Iterable<any>;
			public sample(sampler: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static merge(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public replay(bufferSize: number, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
			public takeLast(count: number): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public scan(initialValue: any, accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public timestamp(): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public concatMapEagerDelayError(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public onErrorReturn(valueSupplier: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public filter(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public retry(predicate: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Observable<any>;
			public distinct(keySelector: io.reactivex.functions.Function<any,any>, collectionSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public static concat(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static concatArrayEagerDelayError(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public static intervalRange(start: number, param1: number, count: number, param3: number, initialDelay: java.util.concurrent.TimeUnit, param5: io.reactivex.Scheduler): io.reactivex.Observable<java.lang.Long>;
			public concatMapEager(mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number): io.reactivex.Observable<any>;
			public subscribeWith(observer: io.reactivex.Observer<any>): io.reactivex.Observer<any>;
			public switchIfEmpty(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, source8: io.reactivex.ObservableSource<any>, source9: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.util.List<any>>;
			public static merge(sources: java.lang.Iterable<any>, maxConcurrency: number): io.reactivex.Observable<any>;
			public repeat(times: number): io.reactivex.Observable<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean): io.reactivex.Observable<any>;
			public timeInterval(): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public retry(times: number, param1: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public timeInterval(unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public static fromIterable(source: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public static merge(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public cast(clazz: java.lang.Class<any>): io.reactivex.Observable<any>;
			public static combineLatest(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public buffer(count: number): io.reactivex.Observable<java.util.List<any>>;
			public doOnTerminate(onTerminate: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public dematerialize(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public subscribeActual(param0: io.reactivex.Observer<any>): void;
			public switchMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static switchOnNextDelayError(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: boolean, scheduler: number): io.reactivex.Observable<any>;
			public blockingLast(defaultItem: any): any;
			public join(other: io.reactivex.ObservableSource<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public window(count: number, param1: number, skip: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public throttleWithTimeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public static concatArrayEagerDelayError(maxConcurrency: number, prefetch: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			/** @deprecated */
			public dematerialize(): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, source5: io.reactivex.ObservableSource<any>, source6: io.reactivex.ObservableSource<any>, source7: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Observable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Observable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static combineLatestDelayError(sources: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public retry(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean): io.reactivex.Observable<any>;
			public concatMapEager(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static concatArrayDelayError(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public replay(scheduler: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
			public doAfterNext(onAfterNext: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public switchMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public concatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public window(boundary: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public zipWith(other: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean): io.reactivex.Observable<any>;
			public repeatWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static never(): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean): io.reactivex.Observable<any>;
			public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static empty(): io.reactivex.Observable<any>;
			public buffer(openingIndicator: io.reactivex.ObservableSource<any>, closingIndicator: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public forEach(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public singleElement(): io.reactivex.Maybe<any>;
			public static switchOnNextDelayError(sources: io.reactivex.ObservableSource<any>, prefetch: number): io.reactivex.Observable<any>;
			public count(): io.reactivex.Single<java.lang.Long>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, delayError: boolean): io.reactivex.Observable<any>;
			public static ambArray(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public concatWith(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static generate(generator: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any): io.reactivex.Observable<any>;
			public static mergeDelayError(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public skipWhile(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Observable<any>;
			public static concat(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public sample(period: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Observable<any>;
			public static combineLatest(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Observable<any>;
			public window(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public delaySubscription(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean, delayError: number): io.reactivex.Observable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean, delayError: number): io.reactivex.Observable<any>;
			public window(count: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public concatMapMaybe(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Observable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public zipWith(other: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public ambWith(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public blockingFirst(): any;
			public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean): io.reactivex.Observable<any>;
			public static combineLatestDelayError(sources: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number): io.reactivex.Observable<any>;
			public buffer(timespan: number, param1: number, timeskip: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler, unit: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public window(count: number, param1: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public static just(item1: any, item2: any): io.reactivex.Observable<any>;
			public doOnLifecycle(onSubscribe: io.reactivex.functions.Consumer<any>, onDispose: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public static error(exception: java.lang.Throwable): io.reactivex.Observable<any>;
			public replay(bufferSize: number): io.reactivex.observables.ConnectableObservable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any, item9: any, item10: any): io.reactivex.Observable<any>;
			public toMultimap(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Observable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, delayError: boolean): io.reactivex.Observable<any>;
			public static concatEager(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public withLatestFrom(o1: io.reactivex.ObservableSource<any>, o2: io.reactivex.ObservableSource<any>, o3: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Observable<any>;
			public lift(lifter: io.reactivex.ObservableOperator<any,any>): io.reactivex.Observable<any>;
			public blockingSubscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): void;
			public constructor();
			public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>, prefetch: number, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public concatMapCompletableDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Completable;
			public buffer(boundarySupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public concatMapIterable(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Observable<any>;
			public defaultIfEmpty(defaultItem: any): io.reactivex.Observable<any>;
			public static concatEager(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static just(item1: any, item2: any, item3: any, item4: any, item5: any, item6: any, item7: any, item8: any): io.reactivex.Observable<any>;
			public static merge(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public materialize(): io.reactivex.Observable<io.reactivex.Notification<any>>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Observable<any>;
			public retry(): io.reactivex.Observable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, count: boolean): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public buffer(boundarySupplier: java.util.concurrent.Callable<any>, bufferSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public flatMapIterable(mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public takeLast(count: number, param1: number, time: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public takeUntil(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public onExceptionResumeNext(next: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public startWith(items: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public static just(item: any): io.reactivex.Observable<any>;
			public take(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public withLatestFrom(other: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public static sequenceEqual(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, isEqual: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Single<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public toSortedList(comparator: java.util.Comparator<any>): io.reactivex.Single<java.util.List<any>>;
			public skipLast(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
			public switchMapSingle(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiConsumer<any,any>, disposeState: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public reduceWith(seedSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public flatMap(onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public replay(bufferSize: number, time: number, param2: java.util.concurrent.TimeUnit): io.reactivex.observables.ConnectableObservable<any>;
			public blockingForEach(onNext: io.reactivex.functions.Consumer<any>): void;
			public cache(): io.reactivex.Observable<any>;
			public lastOrError(): io.reactivex.Single<any>;
			public onErrorResumeNext(resumeFunction: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static mergeArrayDelayError(maxConcurrency: number, bufferSize: number, ...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public window(boundary: java.util.concurrent.Callable<any>, bufferSize: number): io.reactivex.Observable<any>;
			public concatMapSingleDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public doAfterTerminate(onFinally: io.reactivex.functions.Action): io.reactivex.Observable<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public blockingIterable(bufferSize: number): java.lang.Iterable<any>;
			public concatMapMaybeDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean, prefetch: number): io.reactivex.Observable<any>;
			public static zip(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, zipper: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number): io.reactivex.Observable<any>;
			public doOnError(onError: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public debounce(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static mergeDelayError(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>, source4: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public delaySubscription(other: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public forEachWhile(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
			public switchMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public concatMap(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.Observable<any>;
			public static mergeArrayDelayError(...sources: io.reactivex.ObservableSource<any>[]): io.reactivex.Observable<any>;
			public throttleLatest(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Observable<any>;
			public static concatDelayError(sources: io.reactivex.ObservableSource<any>, prefetch: number, tillTheEnd: boolean): io.reactivex.Observable<any>;
			public firstOrError(): io.reactivex.Single<any>;
			public skip(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public subscribe(observer: io.reactivex.Observer<any>): void;
			public repeat(): io.reactivex.Observable<any>;
			public delay(delay: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Observable<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number): io.reactivex.Observable<any>;
			public elementAtOrError(index: number): io.reactivex.Single<any>;
			public groupBy(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public buffer(boundary: io.reactivex.ObservableSource<any>, initialCapacity: number): io.reactivex.Observable<any>;
			public distinctUntilChanged(comparer: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Observable<any>;
			public reduce(reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Maybe<any>;
			public skipLast(count: number): io.reactivex.Observable<any>;
			public window(timespan: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.Observable<io.reactivex.Observable<any>>;
			public static generate(initialState: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,any,any>, disposeState: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public delay(subscriptionDelay: io.reactivex.ObservableSource<any>, itemDelay: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public takeLast(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			public replay(bufferSize: number, scheduler: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
			public scan(accumulator: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Observable<any>;
			public static interval(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit): io.reactivex.Observable<java.lang.Long>;
			public static amb(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public doOnEach(onNotification: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
			public all(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Single<java.lang.Boolean>;
			public replay(): io.reactivex.observables.ConnectableObservable<any>;
			public buffer(count: number, skip: number): io.reactivex.Observable<java.util.List<any>>;
			public static bufferSize(): number;
			public withLatestFrom(others: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static defer(supplier: java.util.concurrent.Callable<any>): io.reactivex.Observable<any>;
			public timestamp(unit: java.util.concurrent.TimeUnit): io.reactivex.Observable<io.reactivex.schedulers.Timed<any>>;
			public single(defaultItem: any): io.reactivex.Single<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number): io.reactivex.Observable<any>;
			public ignoreElements(): io.reactivex.Completable;
			public skip(count: number): io.reactivex.Observable<any>;
			public static concat(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, source3: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, timeUnit: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>): io.reactivex.Observable<any>;
			public static merge(sources: java.lang.Iterable<any>, maxConcurrency: number, bufferSize: number): io.reactivex.Observable<any>;
			public replay(selector: io.reactivex.functions.Function<any,any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
			public static sequenceEqual(source1: io.reactivex.ObservableSource<any>, source2: io.reactivex.ObservableSource<any>, isEqual: io.reactivex.functions.BiPredicate<any,any>, bufferSize: number): io.reactivex.Single<any>;
			public as(converter: io.reactivex.ObservableConverter<any,any>): any;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableConverter<T, R>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.ObservableConverter<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableConverter<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Observable<T>): R;
			});
			public constructor();
			public apply(param0: io.reactivex.Observable<T>): R;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableEmitter<T>  extends io.reactivex.Emitter<any> {
			public static class: java.lang.Class<io.reactivex.ObservableEmitter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableEmitter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				setDisposable(param0: io.reactivex.disposables.Disposable): void;
				setCancellable(param0: io.reactivex.functions.Cancellable): void;
				isDisposed(): boolean;
				serialize(): io.reactivex.ObservableEmitter<any>;
				tryOnError(param0: java.lang.Throwable): boolean;
				onNext(param0: any): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
			});
			public constructor();
			public tryOnError(param0: java.lang.Throwable): boolean;
			public isDisposed(): boolean;
			public setCancellable(param0: io.reactivex.functions.Cancellable): void;
			public serialize(): io.reactivex.ObservableEmitter<any>;
			public onComplete(): void;
			public setDisposable(param0: io.reactivex.disposables.Disposable): void;
			public onNext(param0: any): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableOnSubscribe<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.ObservableOnSubscribe<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableOnSubscribe<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.ObservableEmitter<T>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.ObservableEmitter<T>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableOperator<Downstream, Upstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.ObservableOperator<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableOperator<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Observer<any>): io.reactivex.Observer<any>;
			});
			public constructor();
			public apply(param0: io.reactivex.Observer<any>): io.reactivex.Observer<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableSource<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.ObservableSource<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.Observer<any>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.Observer<any>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class ObservableTransformer<Upstream, Downstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.ObservableTransformer<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.ObservableTransformer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Observable<Upstream>): io.reactivex.ObservableSource<Downstream>;
			});
			public constructor();
			public apply(param0: io.reactivex.Observable<Upstream>): io.reactivex.ObservableSource<Downstream>;
		}
	}
}

declare module io {
	export module reactivex {
		export class Observer<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.Observer<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.Observer<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				onNext(param0: T): void;
				onError(param0: java.lang.Throwable): void;
				onComplete(): void;
			});
			public constructor();
			public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
			public onNext(param0: T): void;
			public onComplete(): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Scheduler extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.Scheduler>;
			public static clockDriftTolerance(): number;
			public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
			public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
			public constructor();
			public shutdown(): void;
			public start(): void;
			public createWorker(): io.reactivex.Scheduler.Worker;
			public now(unit: java.util.concurrent.TimeUnit): number;
			public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
			public when(combine: io.reactivex.functions.Function<any,any>): io.reactivex.Scheduler;
		}
		export module Scheduler {
			export class DisposeTask extends java.lang.Object implements io.reactivex.disposables.Disposable, java.lang.Runnable, io.reactivex.schedulers.SchedulerRunnableIntrospection {
				public static class: java.lang.Class<io.reactivex.Scheduler.DisposeTask>;
				public run(): void;
				public getWrappedRunnable(): java.lang.Runnable;
				public dispose(): void;
				public isDisposed(): boolean;
			}
			export class PeriodicDirectTask extends java.lang.Object implements io.reactivex.disposables.Disposable, java.lang.Runnable, io.reactivex.schedulers.SchedulerRunnableIntrospection {
				public static class: java.lang.Class<io.reactivex.Scheduler.PeriodicDirectTask>;
				public run(): void;
				public getWrappedRunnable(): java.lang.Runnable;
				public dispose(): void;
				public isDisposed(): boolean;
			}
			export abstract class Worker extends java.lang.Object implements io.reactivex.disposables.Disposable {
				public static class: java.lang.Class<io.reactivex.Scheduler.Worker>;
				public schedulePeriodically(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				public dispose(): void;
				public isDisposed(): boolean;
				public now(unit: java.util.concurrent.TimeUnit): number;
				public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
				public constructor();
			}
			export module Worker {
				export class PeriodicTask extends java.lang.Object implements java.lang.Runnable, io.reactivex.schedulers.SchedulerRunnableIntrospection {
					public static class: java.lang.Class<io.reactivex.Scheduler.Worker.PeriodicTask>;
					public run(): void;
					public getWrappedRunnable(): java.lang.Runnable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export abstract class Single<T>  extends io.reactivex.SingleSource<any> {
			public static class: java.lang.Class<io.reactivex.Single<any>>;
			public zipWith(other: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public repeat(): io.reactivex.Flowable<any>;
			public static error(exception: java.lang.Throwable): io.reactivex.Single<any>;
			public static mergeDelayError(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public static concatEager(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public doOnTerminate(onTerminate: io.reactivex.functions.Action): io.reactivex.Single<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, source5: io.reactivex.SingleSource<any>, source6: io.reactivex.SingleSource<any>, source7: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.Single<any>;
			public hide(): io.reactivex.Single<any>;
			public cast(clazz: java.lang.Class<any>): io.reactivex.Single<any>;
			public mergeWith(other: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static defer(singleSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public doAfterSuccess(onAfterSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.Single<any>;
			public flattenAsFlowable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public retry(times: number, param1: io.reactivex.functions.Predicate<any>): io.reactivex.Single<any>;
			public retry(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Single<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.Single<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Single<any>;
			public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
			public delaySubscription(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Single<any>;
			public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public takeUntil(other: org.reactivestreams.Publisher): io.reactivex.Single<any>;
			public static concat(sources: org.reactivestreams.Publisher, prefetch: number): io.reactivex.Flowable<any>;
			public blockingGet(): any;
			public toFlowable(): io.reactivex.Flowable<any>;
			public delaySubscription(other: io.reactivex.CompletableSource): io.reactivex.Single<any>;
			public map(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static concatEager(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public ignoreElement(): io.reactivex.Completable;
			public delaySubscription(other: org.reactivestreams.Publisher): io.reactivex.Single<any>;
			public ambWith(other: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public static amb(sources: java.lang.Iterable<any>): io.reactivex.Single<any>;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, singleFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean): io.reactivex.Single<any>;
			public cache(): io.reactivex.Single<any>;
			public constructor();
			public retryWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static merge(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static wrap(source: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public test(): io.reactivex.observers.TestObserver<any>;
			public dematerialize(selector: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public doOnEvent(onEvent: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.Single<any>;
			public repeatUntil(stop: io.reactivex.functions.BooleanSupplier): io.reactivex.Flowable<any>;
			public static concat(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static mergeDelayError(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.Single<any>;
			public static mergeDelayError(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public flatMapCompletable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Completable;
			public static concat(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public toFuture(): java.util.concurrent.Future<any>;
			public doFinally(onFinally: io.reactivex.functions.Action): io.reactivex.Single<any>;
			public static zipArray(zipper: io.reactivex.functions.Function<any,any>, ...sources: io.reactivex.SingleSource<any>[]): io.reactivex.Single<any>;
			public contains(value: any): io.reactivex.Single<java.lang.Boolean>;
			public onErrorResumeNext(resumeFunctionInCaseOfError: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static just(item: any): io.reactivex.Single<any>;
			public static concatArray(...sources: io.reactivex.SingleSource<any>[]): io.reactivex.Flowable<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.Single<any>;
			public static concat(sources: io.reactivex.ObservableSource<any>): io.reactivex.Observable<any>;
			public retry(predicate: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Single<any>;
			public static concat(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public flattenAsObservable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public static merge(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public delay(time: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Single<any>;
			public onTerminateDetach(): io.reactivex.Single<any>;
			public static unsafeCreate(onSubscribe: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.Single<any>;
			public as(converter: io.reactivex.SingleConverter<any,any>): any;
			public subscribe(observer: io.reactivex.SingleObserver<any>): void;
			public materialize(): io.reactivex.Single<io.reactivex.Notification<any>>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Single<java.lang.Long>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public subscribe(): io.reactivex.disposables.Disposable;
			public doOnDispose(onDispose: io.reactivex.functions.Action): io.reactivex.Single<any>;
			public static mergeDelayError(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public compose(transformer: io.reactivex.SingleTransformer<any,any>): io.reactivex.Single<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public static equals(first: io.reactivex.SingleSource<any>, second: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			/** @deprecated */
			public toCompletable(): io.reactivex.Completable;
			public delay(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public delaySubscription(other: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public delaySubscription(other: io.reactivex.ObservableSource<any>): io.reactivex.Single<any>;
			public subscribe(param0: io.reactivex.SingleObserver<any>): void;
			public static using(resourceSupplier: java.util.concurrent.Callable<any>, singleFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>): io.reactivex.Single<any>;
			public doOnError(onError: io.reactivex.functions.Consumer<any>): io.reactivex.Single<any>;
			public onErrorReturnItem(value: any): io.reactivex.Single<any>;
			public static mergeDelayError(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static fromObservable(observableSource: io.reactivex.ObservableSource<any>): io.reactivex.Single<any>;
			public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.Single<any>;
			public onErrorReturn(resumeFunction: io.reactivex.functions.Function<java.lang.Throwable,any>): io.reactivex.Single<any>;
			public static fromCallable(callable: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public doOnSuccess(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.Single<any>;
			public static concat(sources: java.lang.Iterable<any>): io.reactivex.Flowable<any>;
			public concatWith(other: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, source5: io.reactivex.SingleSource<any>, source6: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.Single<any>;
			public static concatArrayEager(...sources: io.reactivex.SingleSource<any>[]): io.reactivex.Flowable<any>;
			public contains(value: any, comparer: io.reactivex.functions.BiPredicate<any,any>): io.reactivex.Single<java.lang.Boolean>;
			public static merge(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public static create(source: io.reactivex.SingleOnSubscribe<any>): io.reactivex.Single<any>;
			public static never(): io.reactivex.Single<any>;
			public flatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static error(errorSupplier: java.util.concurrent.Callable<any>): io.reactivex.Single<any>;
			public takeUntil(other: io.reactivex.CompletableSource): io.reactivex.Single<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Single<any>;
			public toObservable(): io.reactivex.Observable<any>;
			public test(cancelled: boolean): io.reactivex.observers.TestObserver<any>;
			public static merge(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public retry(times: number): io.reactivex.Single<any>;
			public takeUntil(other: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public subscribeWith(observer: io.reactivex.SingleObserver<any>): io.reactivex.SingleObserver<any>;
			public static zip(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>): io.reactivex.Single<any>;
			public static fromFuture(future: java.util.concurrent.Future<any>, scheduler: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public delay(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean): io.reactivex.Single<any>;
			public static timer(delay: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Single<java.lang.Long>;
			public flatMapPublisher(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, source5: io.reactivex.SingleSource<any>, source6: io.reactivex.SingleSource<any>, source7: io.reactivex.SingleSource<any>, source8: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.Single<any>;
			public delaySubscription(time: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public repeat(times: number): io.reactivex.Flowable<any>;
			public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
			public delay(time: number, param1: java.util.concurrent.TimeUnit, unit: boolean): io.reactivex.Single<any>;
			public onErrorResumeNext(resumeSingleInCaseOfError: io.reactivex.Single<any>): io.reactivex.Single<any>;
			public flatMapObservable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
			public to(convert: io.reactivex.functions.Function<any,any>): any;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, source5: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.Single<any>;
			public static zip(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>, source3: io.reactivex.SingleSource<any>, source4: io.reactivex.SingleSource<any>, source5: io.reactivex.SingleSource<any>, source6: io.reactivex.SingleSource<any>, source7: io.reactivex.SingleSource<any>, source8: io.reactivex.SingleSource<any>, source9: io.reactivex.SingleSource<any>, zipper: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.Single<any>;
			public static fromPublisher(publisher: org.reactivestreams.Publisher): io.reactivex.Single<any>;
			public lift(lift: io.reactivex.SingleOperator<any,any>): io.reactivex.Single<any>;
			public filter(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.Maybe<any>;
			public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
			public static fromFuture(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public retry(): io.reactivex.Single<any>;
			public repeatWhen(handler: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
			public doAfterTerminate(onAfterTerminate: io.reactivex.functions.Action): io.reactivex.Single<any>;
			public timeout(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public toMaybe(): io.reactivex.Maybe<any>;
			public static merge(sources: org.reactivestreams.Publisher): io.reactivex.Flowable<any>;
			public static concat(source1: io.reactivex.SingleSource<any>, source2: io.reactivex.SingleSource<any>): io.reactivex.Flowable<any>;
			public equals(obj: any): boolean;
			public static merge(source: io.reactivex.SingleSource<any>): io.reactivex.Single<any>;
			public flatMapMaybe(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Maybe<any>;
			public static ambArray(...sources: io.reactivex.SingleSource<any>[]): io.reactivex.Single<any>;
			public subscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Single<any>;
			public unsubscribeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Single<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleConverter<T, R>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleConverter<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleConverter<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Single<T>): R;
			});
			public constructor();
			public apply(param0: io.reactivex.Single<T>): R;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleEmitter<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleEmitter<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleEmitter<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSuccess(param0: T): void;
				onError(param0: java.lang.Throwable): void;
				setDisposable(param0: io.reactivex.disposables.Disposable): void;
				setCancellable(param0: io.reactivex.functions.Cancellable): void;
				isDisposed(): boolean;
				tryOnError(param0: java.lang.Throwable): boolean;
			});
			public constructor();
			public tryOnError(param0: java.lang.Throwable): boolean;
			public isDisposed(): boolean;
			public setCancellable(param0: io.reactivex.functions.Cancellable): void;
			public onSuccess(param0: T): void;
			public setDisposable(param0: io.reactivex.disposables.Disposable): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleObserver<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleObserver<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleObserver<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				onSuccess(param0: T): void;
				onError(param0: java.lang.Throwable): void;
			});
			public constructor();
			public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
			public onSuccess(param0: T): void;
			public onError(param0: java.lang.Throwable): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleOnSubscribe<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleOnSubscribe<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleOnSubscribe<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.SingleEmitter<T>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.SingleEmitter<T>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleOperator<Downstream, Upstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleOperator<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleOperator<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.SingleObserver<any>): io.reactivex.SingleObserver<any>;
			});
			public constructor();
			public apply(param0: io.reactivex.SingleObserver<any>): io.reactivex.SingleObserver<any>;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleSource<T>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleSource<any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				subscribe(param0: io.reactivex.SingleObserver<any>): void;
			});
			public constructor();
			public subscribe(param0: io.reactivex.SingleObserver<any>): void;
		}
	}
}

declare module io {
	export module reactivex {
		export class SingleTransformer<Upstream, Downstream>  extends java.lang.Object {
			public static class: java.lang.Class<io.reactivex.SingleTransformer<any,any>>;
			/**
			 * Constructs a new instance of the io.reactivex.SingleTransformer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
			 */
			public constructor(implementation: {
				apply(param0: io.reactivex.Single<Upstream>): io.reactivex.SingleSource<Downstream>;
			});
			public constructor();
			public apply(param0: io.reactivex.Single<Upstream>): io.reactivex.SingleSource<Downstream>;
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class BackpressureKind {
				public static class: java.lang.Class<io.reactivex.annotations.BackpressureKind>;
				public static PASS_THROUGH: io.reactivex.annotations.BackpressureKind;
				public static FULL: io.reactivex.annotations.BackpressureKind;
				public static SPECIAL: io.reactivex.annotations.BackpressureKind;
				public static UNBOUNDED_IN: io.reactivex.annotations.BackpressureKind;
				public static ERROR: io.reactivex.annotations.BackpressureKind;
				public static NONE: io.reactivex.annotations.BackpressureKind;
				public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
				public static valueOf(name: string): io.reactivex.annotations.BackpressureKind;
				public static values(): io.reactivex.annotations.BackpressureKind[];
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class BackpressureSupport extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.BackpressureSupport>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.BackpressureSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					value(): io.reactivex.annotations.BackpressureKind;
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public value(): io.reactivex.annotations.BackpressureKind;
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class Beta extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.Beta>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.Beta interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class CheckReturnValue extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.CheckReturnValue>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.CheckReturnValue interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class Experimental extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.Experimental>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.Experimental interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class NonNull extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.NonNull>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.NonNull interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class Nullable extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.Nullable>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.Nullable interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public equals(obj: any): boolean;
				public hashCode(): number;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module annotations {
			export class SchedulerSupport extends java.lang.Object implements java.lang.annotation.Annotation {
				public static class: java.lang.Class<io.reactivex.annotations.SchedulerSupport>;
				/**
				 * Constructs a new instance of the io.reactivex.annotations.SchedulerSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					value(): string;
					equals(param0: any): boolean;
					hashCode(): number;
					toString(): string;
					annotationType(): java.lang.Class<any>;
				});
				public constructor();
				public static SINGLE: string;
				public static NEW_THREAD: string;
				public static IO: string;
				public static CUSTOM: string;
				public static COMPUTATION: string;
				public static NONE: string;
				public static TRAMPOLINE: string;
				public equals(obj: any): boolean;
				public hashCode(): number;
				public value(): string;
				public equals(param0: any): boolean;
				public annotationType(): java.lang.Class<any>;
				public toString(): string;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class ActionDisposable extends io.reactivex.disposables.ReferenceDisposable<io.reactivex.functions.Action> {
				public static class: java.lang.Class<io.reactivex.disposables.ActionDisposable>;
				public dispose(): void;
				public isDisposed(): boolean;
				public onDisposed(value: io.reactivex.functions.Action): void;
				public onDisposed(param0: any): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class CompositeDisposable extends java.lang.Object implements io.reactivex.disposables.Disposable, io.reactivex.internal.disposables.DisposableContainer {
				public static class: java.lang.Class<io.reactivex.disposables.CompositeDisposable>;
				public add(disposable: io.reactivex.disposables.Disposable): boolean;
				public isDisposed(): boolean;
				public constructor(disposables: java.lang.Iterable<any>);
				public remove(disposable: io.reactivex.disposables.Disposable): boolean;
				public add(param0: io.reactivex.disposables.Disposable): boolean;
				public constructor();
				public size(): number;
				public delete(param0: io.reactivex.disposables.Disposable): boolean;
				public dispose(): void;
				public clear(): void;
				public remove(param0: io.reactivex.disposables.Disposable): boolean;
				public constructor(...disposables: io.reactivex.disposables.Disposable[]);
				public delete(disposable: io.reactivex.disposables.Disposable): boolean;
				public addAll(...disposables: io.reactivex.disposables.Disposable[]): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class Disposable extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.disposables.Disposable>;
				/**
				 * Constructs a new instance of the io.reactivex.disposables.Disposable interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					dispose(): void;
					isDisposed(): boolean;
				});
				public constructor();
				public dispose(): void;
				public isDisposed(): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class Disposables extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.disposables.Disposables>;
				public static empty(): io.reactivex.disposables.Disposable;
				public static disposed(): io.reactivex.disposables.Disposable;
				public static fromAction(run: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public static fromFuture(future: java.util.concurrent.Future<any>, allowInterrupt: boolean): io.reactivex.disposables.Disposable;
				public static fromSubscription(subscription: org.reactivestreams.Subscription): io.reactivex.disposables.Disposable;
				public static fromRunnable(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
				public static fromFuture(future: java.util.concurrent.Future<any>): io.reactivex.disposables.Disposable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class FutureDisposable extends java.util.concurrent.atomic.AtomicReference<java.util.concurrent.Future<any>> implements io.reactivex.disposables.Disposable  {
				public static class: java.lang.Class<io.reactivex.disposables.FutureDisposable>;
				public isDisposed(): boolean;
				public dispose(): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export abstract class ReferenceDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<any> implements io.reactivex.disposables.Disposable  {
				public static class: java.lang.Class<io.reactivex.disposables.ReferenceDisposable<any>>;
				public dispose(): void;
				public isDisposed(): boolean;
				public onDisposed(param0: any): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class RunnableDisposable extends io.reactivex.disposables.ReferenceDisposable<java.lang.Runnable> {
				public static class: java.lang.Class<io.reactivex.disposables.RunnableDisposable>;
				public onDisposed(value: java.lang.Runnable): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public toString(): string;
				public onDisposed(param0: any): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class SerialDisposable extends java.lang.Object implements io.reactivex.disposables.Disposable {
				public static class: java.lang.Class<io.reactivex.disposables.SerialDisposable>;
				public set(next: io.reactivex.disposables.Disposable): boolean;
				public dispose(): void;
				public isDisposed(): boolean;
				public constructor(initialDisposable: io.reactivex.disposables.Disposable);
				public get(): io.reactivex.disposables.Disposable;
				public constructor();
				public replace(next: io.reactivex.disposables.Disposable): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module disposables {
			export class SubscriptionDisposable extends io.reactivex.disposables.ReferenceDisposable<org.reactivestreams.Subscription> {
				public static class: java.lang.Class<io.reactivex.disposables.SubscriptionDisposable>;
				public dispose(): void;
				public isDisposed(): boolean;
				public onDisposed(value: org.reactivestreams.Subscription): void;
				public onDisposed(param0: any): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class CompositeException extends java.lang.RuntimeException {
				public static class: java.lang.Class<io.reactivex.exceptions.CompositeException>;
				public constructor(cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable);
				public printStackTrace(s: java.io.PrintWriter): void;
				public constructor(message: string);
				public constructor(message: string, cause: java.lang.Throwable, enableSuppression: boolean, writableStackTrace: boolean);
				public getCause(): java.lang.Throwable;
				public constructor(...exceptions: java.lang.Throwable[]);
				public constructor();
				public size(): number;
				public constructor(errors: java.lang.Iterable<any>);
				public getExceptions(): java.util.List<java.lang.Throwable>;
				public getMessage(): string;
				public printStackTrace(s: java.io.PrintStream): void;
				public printStackTrace(): void;
			}
			export module CompositeException {
				export class CompositeExceptionCausalChain extends java.lang.RuntimeException {
					public static class: java.lang.Class<io.reactivex.exceptions.CompositeException.CompositeExceptionCausalChain>;
					public getMessage(): string;
				}
				export abstract class PrintStreamOrWriter extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.exceptions.CompositeException.PrintStreamOrWriter>;
				}
				export class WrappedPrintStream extends io.reactivex.exceptions.CompositeException.PrintStreamOrWriter {
					public static class: java.lang.Class<io.reactivex.exceptions.CompositeException.WrappedPrintStream>;
				}
				export class WrappedPrintWriter extends io.reactivex.exceptions.CompositeException.PrintStreamOrWriter {
					public static class: java.lang.Class<io.reactivex.exceptions.CompositeException.WrappedPrintWriter>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class Exceptions extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.exceptions.Exceptions>;
				public static throwIfFatal(t: java.lang.Throwable): void;
				public static propagate(t: java.lang.Throwable): java.lang.RuntimeException;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class MissingBackpressureException extends java.lang.RuntimeException {
				public static class: java.lang.Class<io.reactivex.exceptions.MissingBackpressureException>;
				public constructor(cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable);
				public constructor(message: string);
				public constructor(message: string, cause: java.lang.Throwable, enableSuppression: boolean, writableStackTrace: boolean);
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class OnErrorNotImplementedException extends java.lang.RuntimeException {
				public static class: java.lang.Class<io.reactivex.exceptions.OnErrorNotImplementedException>;
				public constructor(cause: java.lang.Throwable);
				public constructor(message: string, e: java.lang.Throwable);
				public constructor(e: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable);
				public constructor(message: string);
				public constructor(message: string, cause: java.lang.Throwable, enableSuppression: boolean, writableStackTrace: boolean);
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class ProtocolViolationException extends java.lang.IllegalStateException {
				public static class: java.lang.Class<io.reactivex.exceptions.ProtocolViolationException>;
				public constructor(s: string);
				public constructor(cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable, enableSuppression: boolean, writableStackTrace: boolean);
				public constructor(message: string);
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module exceptions {
			export class UndeliverableException extends java.lang.IllegalStateException {
				public static class: java.lang.Class<io.reactivex.exceptions.UndeliverableException>;
				public constructor(s: string);
				public constructor(cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable);
				public constructor(message: string, cause: java.lang.Throwable, enableSuppression: boolean, writableStackTrace: boolean);
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module flowables {
			export abstract class ConnectableFlowable<T>  extends io.reactivex.Flowable<any> {
				public static class: java.lang.Class<io.reactivex.flowables.ConnectableFlowable<any>>;
				public refCount(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
				public connect(param0: io.reactivex.functions.Consumer<any>): void;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public refCount(): io.reactivex.Flowable<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public refCount(subscriberCount: number, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
				public refCount(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
				public autoConnect(): io.reactivex.Flowable<any>;
				public autoConnect(numberOfSubscribers: number, connection: io.reactivex.functions.Consumer<any>): io.reactivex.Flowable<any>;
				public refCount(subscriberCount: number): io.reactivex.Flowable<any>;
				public autoConnect(numberOfSubscribers: number): io.reactivex.Flowable<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public connect(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public refCount(subscriberCount: number, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Flowable<any>;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module flowables {
			export abstract class GroupedFlowable<K, T>  extends io.reactivex.Flowable<any> {
				public static class: java.lang.Class<io.reactivex.flowables.GroupedFlowable<any,any>>;
				public getKey(): any;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public constructor(key: any);
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Action extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Action>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Action interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					run(): void;
				});
				public constructor();
				public run(): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class BiConsumer<T1, T2>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.BiConsumer<any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.BiConsumer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					accept(param0: T1, param1: T2): void;
				});
				public constructor();
				public accept(param0: T1, param1: T2): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class BiFunction<T1, T2, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.BiFunction<any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.BiFunction<any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class BiPredicate<T1, T2>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.BiPredicate<any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.BiPredicate<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					test(param0: T1, param1: T2): boolean;
				});
				public constructor();
				public test(param0: T1, param1: T2): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class BooleanSupplier extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.BooleanSupplier>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.BooleanSupplier interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					getAsBoolean(): boolean;
				});
				public constructor();
				public getAsBoolean(): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Cancellable extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Cancellable>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Cancellable interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					cancel(): void;
				});
				public constructor();
				public cancel(): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Consumer<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Consumer<any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Consumer<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					accept(param0: T): void;
				});
				public constructor();
				public accept(param0: T): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function<T, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function<any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T): R;
				});
				public constructor();
				public apply(param0: T): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function3<T1, T2, T3, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function3<any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function3<any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function4<T1, T2, T3, T4, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function4<any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function4<any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function5<T1, T2, T3, T4, T5, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function5<any,any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function5<any,any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function6<T1, T2, T3, T4, T5, T6, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function6<any,any,any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function6<any,any,any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function7<T1, T2, T3, T4, T5, T6, T7, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function7<any,any,any,any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7, param7: T8): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7, param7: T8): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7, param7: T8, param8: T9): R;
				});
				public constructor();
				public apply(param0: T1, param1: T2, param2: T3, param3: T4, param4: T5, param5: T6, param6: T7, param7: T8, param8: T9): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class IntFunction<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.IntFunction<any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.IntFunction<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: number): T;
				});
				public constructor();
				public apply(param0: number): T;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class LongConsumer extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.LongConsumer>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.LongConsumer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					accept(param0: number): void;
				});
				public constructor();
				public accept(param0: number): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module functions {
			export class Predicate<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.functions.Predicate<any>>;
				/**
				 * Constructs a new instance of the io.reactivex.functions.Predicate<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					test(param0: T): boolean;
				});
				public constructor();
				public test(param0: T): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class ArrayCompositeDisposable extends java.util.concurrent.atomic.AtomicReferenceArray<io.reactivex.disposables.Disposable> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.internal.disposables.ArrayCompositeDisposable>;
					public constructor(length: number);
					public constructor(array: any[]);
					public constructor(capacity: number);
					public isDisposed(): boolean;
					public dispose(): void;
					public setResource(index: number, resource: io.reactivex.disposables.Disposable): boolean;
					public replaceResource(index: number, resource: io.reactivex.disposables.Disposable): io.reactivex.disposables.Disposable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class CancellableDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.functions.Cancellable> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.internal.disposables.CancellableDisposable>;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public constructor(cancellable: io.reactivex.functions.Cancellable);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class DisposableContainer extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.disposables.DisposableContainer>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.disposables.DisposableContainer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						add(param0: io.reactivex.disposables.Disposable): boolean;
						remove(param0: io.reactivex.disposables.Disposable): boolean;
						delete(param0: io.reactivex.disposables.Disposable): boolean;
					});
					public constructor();
					public delete(param0: io.reactivex.disposables.Disposable): boolean;
					public remove(param0: io.reactivex.disposables.Disposable): boolean;
					public add(param0: io.reactivex.disposables.Disposable): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class DisposableHelper extends io.reactivex.disposables.Disposable {
					public static class: java.lang.Class<io.reactivex.internal.disposables.DisposableHelper>;
					public static DISPOSED: io.reactivex.internal.disposables.DisposableHelper;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static reportDisposableSet(): void;
					public dispose(): void;
					public static valueOf(name: string): io.reactivex.internal.disposables.DisposableHelper;
					public static set(field: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, d: io.reactivex.disposables.Disposable): boolean;
					public static setOnce(field: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, d: io.reactivex.disposables.Disposable): boolean;
					public static validate(current: io.reactivex.disposables.Disposable, next: io.reactivex.disposables.Disposable): boolean;
					public isDisposed(): boolean;
					public static trySet(field: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, d: io.reactivex.disposables.Disposable): boolean;
					public static isDisposed(d: io.reactivex.disposables.Disposable): boolean;
					public static values(): io.reactivex.internal.disposables.DisposableHelper[];
					public static dispose(field: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>): boolean;
					public static replace(field: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, d: io.reactivex.disposables.Disposable): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class EmptyDisposable extends io.reactivex.internal.fuseable.QueueDisposable<any> {
					public static class: java.lang.Class<io.reactivex.internal.disposables.EmptyDisposable>;
					public static INSTANCE: io.reactivex.internal.disposables.EmptyDisposable;
					public static NEVER: io.reactivex.internal.disposables.EmptyDisposable;
					public static error(e: java.lang.Throwable, observer: io.reactivex.Observer<any>): void;
					public static values(): io.reactivex.internal.disposables.EmptyDisposable[];
					public offer(v1: any, v2: any): boolean;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public isEmpty(): boolean;
					public static valueOf(name: string): io.reactivex.internal.disposables.EmptyDisposable;
					public static error(e: java.lang.Throwable, observer: io.reactivex.CompletableObserver): void;
					public dispose(): void;
					public offer(value: any): boolean;
					public static error(e: java.lang.Throwable, observer: io.reactivex.MaybeObserver<any>): void;
					public isDisposed(): boolean;
					public poll(): any;
					public static complete(observer: io.reactivex.MaybeObserver<any>): void;
					public requestFusion(mode: number): number;
					public static complete(observer: io.reactivex.Observer<any>): void;
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public static complete(observer: io.reactivex.CompletableObserver): void;
					public static error(e: java.lang.Throwable, observer: io.reactivex.SingleObserver<any>): void;
					public requestFusion(param0: number): number;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class ListCompositeDisposable extends java.lang.Object implements io.reactivex.disposables.Disposable, io.reactivex.internal.disposables.DisposableContainer {
					public static class: java.lang.Class<io.reactivex.internal.disposables.ListCompositeDisposable>;
					public delete(d: io.reactivex.disposables.Disposable): boolean;
					public constructor(...resources: io.reactivex.disposables.Disposable[]);
					public remove(param0: io.reactivex.disposables.Disposable): boolean;
					public dispose(): void;
					public add(param0: io.reactivex.disposables.Disposable): boolean;
					public isDisposed(): boolean;
					public delete(param0: io.reactivex.disposables.Disposable): boolean;
					public addAll(...ds: io.reactivex.disposables.Disposable[]): boolean;
					public constructor();
					public add(d: io.reactivex.disposables.Disposable): boolean;
					public clear(): void;
					public constructor(resources: java.lang.Iterable<any>);
					public remove(d: io.reactivex.disposables.Disposable): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class ResettableConnectable extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.disposables.ResettableConnectable>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.disposables.ResettableConnectable interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						resetIf(param0: io.reactivex.disposables.Disposable): void;
					});
					public constructor();
					public resetIf(param0: io.reactivex.disposables.Disposable): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module disposables {
				export class SequentialDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.internal.disposables.SequentialDisposable>;
					public isDisposed(): boolean;
					public update(next: io.reactivex.disposables.Disposable): boolean;
					public constructor(initialValue: any);
					public constructor();
					public replace(next: io.reactivex.disposables.Disposable): boolean;
					public dispose(): void;
					public constructor(initial: io.reactivex.disposables.Disposable);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module functions {
				export class Functions extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.functions.Functions>;
					public static EMPTY_RUNNABLE: java.lang.Runnable;
					public static EMPTY_ACTION: io.reactivex.functions.Action;
					public static ERROR_CONSUMER: io.reactivex.functions.Consumer<java.lang.Throwable>;
					public static ON_ERROR_MISSING: io.reactivex.functions.Consumer<java.lang.Throwable>;
					public static EMPTY_LONG_CONSUMER: io.reactivex.functions.LongConsumer;
					public static REQUEST_MAX: io.reactivex.functions.Consumer<org.reactivestreams.Subscription>;
					public static naturalComparator(): java.util.Comparator<any>;
					public static boundedConsumer(bufferSize: number): io.reactivex.functions.Consumer<any>;
					public static createArrayList(capacity: number): java.util.concurrent.Callable<any>;
					public static toFunction(f: io.reactivex.functions.Function5<any,any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static toMapKeyValueSelector(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>): io.reactivex.functions.BiConsumer<any,any>;
					public static toFunction(f: io.reactivex.functions.Function3<any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static createHashSet(): java.util.concurrent.Callable<any>;
					public static toFunction(f: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.functions.Function<any,any>;
					public static futureAction(future: java.util.concurrent.Future<any>): io.reactivex.functions.Action;
					public static alwaysFalse(): io.reactivex.functions.Predicate<any>;
					public static justFunction(value: any): io.reactivex.functions.Function<any,any>;
					public static toFunction(f: io.reactivex.functions.Function7<any,any,any,any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static notificationOnError(onNotification: io.reactivex.functions.Consumer<any>): io.reactivex.functions.Consumer<any>;
					public static toFunction(f: io.reactivex.functions.Function9<any,any,any,any,any,any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static naturalOrder(): java.util.Comparator<any>;
					public static actionConsumer(action: io.reactivex.functions.Action): io.reactivex.functions.Consumer<any>;
					public static listSorter(comparator: java.util.Comparator<any>): io.reactivex.functions.Function<any,any>;
					public static notificationOnComplete(onNotification: io.reactivex.functions.Consumer<any>): io.reactivex.functions.Action;
					public static timestampWith(unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler): io.reactivex.functions.Function<any,any>;
					public static notificationOnNext(onNotification: io.reactivex.functions.Consumer<any>): io.reactivex.functions.Consumer<any>;
					public static nullSupplier(): java.util.concurrent.Callable<any>;
					public static toFunction(f: io.reactivex.functions.Function4<any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static identity(): io.reactivex.functions.Function<any,any>;
					public static equalsWith(value: any): io.reactivex.functions.Predicate<any>;
					public static emptyConsumer(): io.reactivex.functions.Consumer<any>;
					public static toMapKeySelector(keySelector: io.reactivex.functions.Function<any,any>): io.reactivex.functions.BiConsumer<any,any>;
					public static alwaysTrue(): io.reactivex.functions.Predicate<any>;
					public static toFunction(f: io.reactivex.functions.Function6<any,any,any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static toMultimapKeyValueSelector(keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, collectionFactory: io.reactivex.functions.Function<any,any>): io.reactivex.functions.BiConsumer<any,any>;
					public static toFunction(f: io.reactivex.functions.Function8<any,any,any,any,any,any,any,any,any>): io.reactivex.functions.Function<any,any>;
					public static predicateReverseFor(supplier: io.reactivex.functions.BooleanSupplier): io.reactivex.functions.Predicate<any>;
					public static castFunction(target: java.lang.Class<any>): io.reactivex.functions.Function<any,any>;
					public static justCallable(value: any): java.util.concurrent.Callable<any>;
					public static isInstanceOf(clazz: java.lang.Class<any>): io.reactivex.functions.Predicate<any>;
				}
				export module Functions {
					export class ActionConsumer<T>  extends io.reactivex.functions.Consumer<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ActionConsumer<any>>;
						public accept(param0: any): void;
						public accept(t: any): void;
					}
					export class Array2Func<T1, T2, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array2Func<any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array3Func<T1, T2, T3, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array3Func<any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array4Func<T1, T2, T3, T4, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array4Func<any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array5Func<T1, T2, T3, T4, T5, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array5Func<any,any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array6Func<T1, T2, T3, T4, T5, T6, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array6Func<any,any,any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array7Func<T1, T2, T3, T4, T5, T6, T7, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array7Func<any,any,any,any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array8Func<T1, T2, T3, T4, T5, T6, T7, T8, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array8Func<any,any,any,any,any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class Array9Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>  extends io.reactivex.functions.Function<any[],any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Array9Func<any,any,any,any,any,any,any,any,any,any>>;
						public apply(a: any[]): any;
						public apply(param0: any): any;
					}
					export class ArrayListCapacityCallable<T>  extends java.util.concurrent.Callable<java.util.List<any>> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ArrayListCapacityCallable<any>>;
						public call(): java.util.List<any>;
						public call(): any;
					}
					export class BooleanSupplierPredicateReverse<T>  extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.BooleanSupplierPredicateReverse<any>>;
						public test(param0: any): boolean;
						public test(t: any): boolean;
					}
					export class BoundedConsumer extends io.reactivex.functions.Consumer<org.reactivestreams.Subscription> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.BoundedConsumer>;
						public accept(param0: any): void;
						public accept(s: org.reactivestreams.Subscription): void;
					}
					export class CastToClass<T, U>  extends io.reactivex.functions.Function<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.CastToClass<any,any>>;
						public apply(t: any): any;
						public apply(param0: any): any;
					}
					export class ClassFilter<T, U>  extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ClassFilter<any,any>>;
						public test(param0: any): boolean;
						public test(t: any): boolean;
					}
					export class EmptyAction extends java.lang.Object implements io.reactivex.functions.Action {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.EmptyAction>;
						public run(): void;
						public toString(): string;
					}
					export class EmptyConsumer extends io.reactivex.functions.Consumer<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.EmptyConsumer>;
						public accept(param0: any): void;
						public accept(v: any): void;
						public toString(): string;
					}
					export class EmptyLongConsumer extends java.lang.Object implements io.reactivex.functions.LongConsumer {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.EmptyLongConsumer>;
						public accept(v: number): void;
						public accept(param0: number): void;
					}
					export class EmptyRunnable extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.EmptyRunnable>;
						public run(): void;
						public toString(): string;
					}
					export class EqualsPredicate<T>  extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.EqualsPredicate<any>>;
						public test(param0: any): boolean;
						public test(t: any): boolean;
					}
					export class ErrorConsumer extends io.reactivex.functions.Consumer<java.lang.Throwable> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ErrorConsumer>;
						public accept(param0: any): void;
						public accept(error: java.lang.Throwable): void;
					}
					export class FalsePredicate extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.FalsePredicate>;
						public test(o: any): boolean;
						public test(param0: any): boolean;
					}
					export class FutureAction extends java.lang.Object implements io.reactivex.functions.Action {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.FutureAction>;
						public run(): void;
					}
					export class HashSetCallable extends java.util.concurrent.Callable<java.util.Set<any>> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.HashSetCallable>;
						public static INSTANCE: io.reactivex.internal.functions.Functions.HashSetCallable;
						public static valueOf(name: string): io.reactivex.internal.functions.Functions.HashSetCallable;
						public call(): java.util.Set<any>;
						public static values(): io.reactivex.internal.functions.Functions.HashSetCallable[];
						public call(): any;
						public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					}
					export class Identity extends io.reactivex.functions.Function<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.Identity>;
						public apply(v: any): any;
						public apply(param0: any): any;
						public toString(): string;
					}
					export class JustValue<T, U>  extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.JustValue<any,any>>;
						public apply(t: T): U;
						public call(): U;
						public call(): any;
						public apply(param0: T): any;
					}
					export class ListSorter<T>  extends io.reactivex.functions.Function<java.util.List<any>,java.util.List<any>> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ListSorter<any>>;
						public apply(v: java.util.List<any>): java.util.List<any>;
						public apply(param0: any): any;
					}
					export class MaxRequestSubscription extends io.reactivex.functions.Consumer<org.reactivestreams.Subscription> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.MaxRequestSubscription>;
						public accept(t: org.reactivestreams.Subscription): void;
						public accept(param0: any): void;
					}
					export class NaturalComparator extends java.util.Comparator<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NaturalComparator>;
						public static INSTANCE: io.reactivex.internal.functions.Functions.NaturalComparator;
						public compare(o1: any, o2: any): number;
						public equals(other: any): boolean;
						public static nullsLast(comparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public equals(param0: any): boolean;
						public static values(): io.reactivex.internal.functions.Functions.NaturalComparator[];
						public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
						public thenComparing(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static reverseOrder(): java.util.Comparator<any>;
						public thenComparingLong(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparingDouble(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static valueOf(name: string): io.reactivex.internal.functions.Functions.NaturalComparator;
						public reversed(): java.util.Comparator<any>;
						public thenComparingInt(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public thenComparingDouble(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparing(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparing(keyExtractor: any /* any*/, keyComparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public thenComparing(keyExtractor: any /* any*/, keyComparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public static nullsFirst(comparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public static naturalOrder(): java.util.Comparator<any>;
						public compare(param0: any, param1: any): number;
						public thenComparing(other: java.util.Comparator<any>): java.util.Comparator<any>;
						public static comparingLong(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparingInt(keyExtractor: any /* any*/): java.util.Comparator<any>;
					}
					export class NaturalObjectComparator extends java.util.Comparator<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NaturalObjectComparator>;
						public equals(obj: any): boolean;
						public static nullsLast(comparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public equals(param0: any): boolean;
						public thenComparing(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static reverseOrder(): java.util.Comparator<any>;
						public thenComparingLong(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparingDouble(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public reversed(): java.util.Comparator<any>;
						public thenComparingInt(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public thenComparingDouble(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparing(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public compare(a: any, b: any): number;
						public static comparing(keyExtractor: any /* any*/, keyComparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public thenComparing(keyExtractor: any /* any*/, keyComparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public static nullsFirst(comparator: java.util.Comparator<any>): java.util.Comparator<any>;
						public static naturalOrder(): java.util.Comparator<any>;
						public compare(param0: any, param1: any): number;
						public thenComparing(other: java.util.Comparator<any>): java.util.Comparator<any>;
						public static comparingLong(keyExtractor: any /* any*/): java.util.Comparator<any>;
						public static comparingInt(keyExtractor: any /* any*/): java.util.Comparator<any>;
					}
					export class NotificationOnComplete<T>  extends io.reactivex.functions.Action {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NotificationOnComplete<any>>;
						public run(): void;
					}
					export class NotificationOnError<T>  extends io.reactivex.functions.Consumer<java.lang.Throwable> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NotificationOnError<any>>;
						public accept(param0: any): void;
						public accept(v: java.lang.Throwable): void;
					}
					export class NotificationOnNext<T>  extends io.reactivex.functions.Consumer<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NotificationOnNext<any>>;
						public accept(param0: any): void;
						public accept(v: any): void;
					}
					export class NullCallable extends java.util.concurrent.Callable<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.NullCallable>;
						public call(): any;
					}
					export class OnErrorMissingConsumer extends io.reactivex.functions.Consumer<java.lang.Throwable> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.OnErrorMissingConsumer>;
						public accept(param0: any): void;
						public accept(error: java.lang.Throwable): void;
					}
					export class TimestampFunction<T>  extends io.reactivex.functions.Function<any,io.reactivex.schedulers.Timed<any>> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.TimestampFunction<any>>;
						public apply(t: any): io.reactivex.schedulers.Timed<any>;
						public apply(param0: any): any;
					}
					export class ToMapKeySelector<K, T>  extends io.reactivex.functions.BiConsumer<java.util.Map<any,any>,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ToMapKeySelector<any,any>>;
						public accept(param0: any, param1: any): void;
						public accept(m: java.util.Map<any,any>, t: any): void;
					}
					export class ToMapKeyValueSelector<K, V, T>  extends io.reactivex.functions.BiConsumer<java.util.Map<any,any>,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ToMapKeyValueSelector<any,any,any>>;
						public accept(param0: any, param1: any): void;
						public accept(m: java.util.Map<any,any>, t: any): void;
					}
					export class ToMultimapKeyValueSelector<K, V, T>  extends io.reactivex.functions.BiConsumer<java.util.Map<any,java.util.Collection<any>>,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.ToMultimapKeyValueSelector<any,any,any>>;
						public accept(param0: any, param1: any): void;
						public accept(m: java.util.Map<any,java.util.Collection<any>>, t: any): void;
					}
					export class TruePredicate extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.Functions.TruePredicate>;
						public test(o: any): boolean;
						public test(param0: any): boolean;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module functions {
				export class ObjectHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.functions.ObjectHelper>;
					public equals(obj: any): boolean;
					public static compare(v1: number, v2: number): number;
					public static equalsPredicate(): io.reactivex.functions.BiPredicate<any,any>;
					public static compare(v1: number, param1: number): number;
					public static requireNonNull(object: any, message: string): any;
					public static equals(o1: any, o2: any): boolean;
					public hashCode(): number;
					public static verifyPositive(value: number, param1: string): number;
					public static hashCode(o: any): number;
					public static verifyPositive(value: number, paramName: string): number;
					/** @deprecated */
					public static requireNonNull(value: number, param1: string): number;
				}
				export module ObjectHelper {
					export class BiObjectPredicate extends io.reactivex.functions.BiPredicate<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.functions.ObjectHelper.BiObjectPredicate>;
						public test(o1: any, o2: any): boolean;
						public test(param0: any, param1: any): boolean;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class ConditionalSubscriber<T>  extends io.reactivex.FlowableSubscriber<any> {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.ConditionalSubscriber<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.ConditionalSubscriber<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						tryOnNext(param0: any): boolean;
						onSubscribe(param0: org.reactivestreams.Subscription): void;
						onComplete(): void;
						onError(param0: java.lang.Throwable): void;
						onNext(param0: any): void;
						onSubscribe(param0: org.reactivestreams.Subscription): void;
					});
					public constructor();
					public tryOnNext(param0: any): boolean;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class FuseToFlowable<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.FuseToFlowable<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.FuseToFlowable<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						fuseToFlowable(): io.reactivex.Flowable<T>;
					});
					public constructor();
					public fuseToFlowable(): io.reactivex.Flowable<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class FuseToMaybe<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.FuseToMaybe<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.FuseToMaybe<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						fuseToMaybe(): io.reactivex.Maybe<T>;
					});
					public constructor();
					public fuseToMaybe(): io.reactivex.Maybe<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class FuseToObservable<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.FuseToObservable<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.FuseToObservable<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						fuseToObservable(): io.reactivex.Observable<T>;
					});
					public constructor();
					public fuseToObservable(): io.reactivex.Observable<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class HasUpstreamCompletableSource extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.HasUpstreamCompletableSource>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.HasUpstreamCompletableSource interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						source(): io.reactivex.CompletableSource;
					});
					public constructor();
					public source(): io.reactivex.CompletableSource;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class HasUpstreamMaybeSource<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						source(): io.reactivex.MaybeSource<T>;
					});
					public constructor();
					public source(): io.reactivex.MaybeSource<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class HasUpstreamObservableSource<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.HasUpstreamObservableSource<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.HasUpstreamObservableSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						source(): io.reactivex.ObservableSource<T>;
					});
					public constructor();
					public source(): io.reactivex.ObservableSource<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class HasUpstreamPublisher<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.HasUpstreamPublisher<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.HasUpstreamPublisher<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						source(): org.reactivestreams.Publisher<T>;
					});
					public constructor();
					public source(): org.reactivestreams.Publisher<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class HasUpstreamSingleSource<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.HasUpstreamSingleSource<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.HasUpstreamSingleSource<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						source(): io.reactivex.SingleSource<T>;
					});
					public constructor();
					public source(): io.reactivex.SingleSource<T>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class QueueDisposable<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.QueueDisposable<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.QueueDisposable<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						requestFusion(param0: number): number;
						dispose(): void;
						isDisposed(): boolean;
						offer(param0: T): boolean;
						offer(param0: T, param1: T): boolean;
						poll(): T;
						isEmpty(): boolean;
						clear(): void;
					});
					public constructor();
					public static BOUNDARY: number;
					public static NONE: number;
					public static SYNC: number;
					public static ANY: number;
					public static ASYNC: number;
					public offer(param0: T): boolean;
					public isDisposed(): boolean;
					public isEmpty(): boolean;
					public dispose(): void;
					public clear(): void;
					public requestFusion(param0: number): number;
					public poll(): T;
					public offer(param0: T, param1: T): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class QueueFuseable<T>  extends io.reactivex.internal.fuseable.SimpleQueue<any> {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.QueueFuseable<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.QueueFuseable<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						requestFusion(param0: number): number;
						offer(param0: any): boolean;
						offer(param0: any, param1: any): boolean;
						poll(): any;
						isEmpty(): boolean;
						clear(): void;
					});
					public constructor();
					public static BOUNDARY: number;
					public static NONE: number;
					public static SYNC: number;
					public static ANY: number;
					public static ASYNC: number;
					public poll(): any;
					public isEmpty(): boolean;
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public requestFusion(param0: number): number;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class QueueSubscription<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.QueueSubscription<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.QueueSubscription<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						requestFusion(param0: number): number;
						cancel(): void;
						request(param0: number): void;
						offer(param0: T): boolean;
						offer(param0: T, param1: T): boolean;
						poll(): T;
						isEmpty(): boolean;
						clear(): void;
					});
					public constructor();
					public static BOUNDARY: number;
					public static NONE: number;
					public static SYNC: number;
					public static ANY: number;
					public static ASYNC: number;
					public offer(param0: T): boolean;
					public isEmpty(): boolean;
					public clear(): void;
					public cancel(): void;
					public requestFusion(param0: number): number;
					public poll(): T;
					public request(param0: number): void;
					public offer(param0: T, param1: T): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class ScalarCallable<T>  extends java.util.concurrent.Callable<any> {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.ScalarCallable<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.ScalarCallable<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						call(): any;
						call(): any;
					});
					public constructor();
					public call(): any;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class SimplePlainQueue<T>  extends io.reactivex.internal.fuseable.SimpleQueue<any> {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.SimplePlainQueue<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.SimplePlainQueue<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						poll(): any;
						offer(param0: any): boolean;
						offer(param0: any, param1: any): boolean;
						poll(): any;
						isEmpty(): boolean;
						clear(): void;
					});
					public constructor();
					public poll(): any;
					public isEmpty(): boolean;
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module fuseable {
				export class SimpleQueue<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.fuseable.SimpleQueue<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.fuseable.SimpleQueue<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						offer(param0: T): boolean;
						offer(param0: T, param1: T): boolean;
						poll(): T;
						isEmpty(): boolean;
						clear(): void;
					});
					public constructor();
					public offer(param0: T): boolean;
					public isEmpty(): boolean;
					public clear(): void;
					public poll(): T;
					public offer(param0: T, param1: T): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class BasicFuseableObserver<T, R>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.observers.BasicFuseableObserver<any,any>>;
					public downstream: io.reactivex.Observer<any>;
					public upstream: io.reactivex.disposables.Disposable;
					public qd: io.reactivex.internal.fuseable.QueueDisposable<T>;
					public done: boolean;
					public sourceMode: number;
					public constructor(downstream: io.reactivex.Observer<any>);
					public onError(t: java.lang.Throwable): void;
					public isEmpty(): boolean;
					public fail(t: java.lang.Throwable): void;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onNext(param0: T): void;
					public onError(param0: java.lang.Throwable): void;
					public offer(param0: T): boolean;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public beforeDownstream(): boolean;
					public afterDownstream(): void;
					public isDisposed(): boolean;
					public transitiveBoundaryFusion(mode: number): number;
					public clear(): void;
					public requestFusion(param0: number): number;
					public poll(): T;
					public offer(param0: T, param1: T): boolean;
					public offer(v1: R, v2: R): boolean;
					public offer(e: R): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class BasicIntQueueDisposable<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.internal.fuseable.QueueDisposable<any>  {
					public static class: java.lang.Class<io.reactivex.internal.observers.BasicIntQueueDisposable<any>>;
					public constructor(initialValue: number);
					public offer(v1: any, v2: any): boolean;
					public isDisposed(): boolean;
					public poll(): any;
					public isEmpty(): boolean;
					public constructor();
					public dispose(): void;
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public requestFusion(param0: number): number;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class BasicQueueDisposable<T>  extends io.reactivex.internal.fuseable.QueueDisposable<any> {
					public static class: java.lang.Class<io.reactivex.internal.observers.BasicQueueDisposable<any>>;
					public offer(v1: any, v2: any): boolean;
					public isDisposed(): boolean;
					public poll(): any;
					public isEmpty(): boolean;
					public constructor();
					public dispose(): void;
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public requestFusion(param0: number): number;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class BiConsumerSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.BiConsumerSingleObserver<any>>;
					public onError(e: java.lang.Throwable): void;
					public onSuccess(value: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public constructor(onCallback: io.reactivex.functions.BiConsumer<any,any>);
					public onError(param0: java.lang.Throwable): void;
					public onSuccess(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class BlockingBaseObserver<T>  extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.observers.BlockingBaseObserver<any>>;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public constructor();
					public constructor(count: number);
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public blockingGet(): any;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class BlockingFirstObserver<T>  extends io.reactivex.internal.observers.BlockingBaseObserver<any> {
					public static class: java.lang.Class<io.reactivex.internal.observers.BlockingFirstObserver<any>>;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public constructor();
					public constructor(count: number);
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class BlockingLastObserver<T>  extends io.reactivex.internal.observers.BlockingBaseObserver<any> {
					public static class: java.lang.Class<io.reactivex.internal.observers.BlockingLastObserver<any>>;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public constructor();
					public constructor(count: number);
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class BlockingMultiObserver<T>  extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.observers.BlockingMultiObserver<any>>;
					public onSuccess(value: any): void;
					public blockingAwait(timeout: number, param1: java.util.concurrent.TimeUnit): boolean;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onSuccess(param0: any): void;
					public blockingGetError(timeout: number, param1: java.util.concurrent.TimeUnit): java.lang.Throwable;
					public onError(e: java.lang.Throwable): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public constructor();
					public constructor(count: number);
					public blockingGetError(): java.lang.Throwable;
					public blockingGet(defaultValue: any): any;
					public blockingGet(): any;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class BlockingObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.BlockingObserver<any>>;
					public static TERMINATED: any;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public constructor(initialValue: any);
					public constructor();
					public constructor(queue: java.util.Queue<any>);
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class CallbackCompletableObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.CallbackCompletableObserver>;
					public accept(param0: any): void;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onError(e: java.lang.Throwable): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public constructor(onComplete: io.reactivex.functions.Action);
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public accept(e: java.lang.Throwable): void;
					public constructor(onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action);
					public hasCustomOnError(): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class ConsumerSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.ConsumerSingleObserver<any>>;
					public constructor(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>);
					public onError(e: java.lang.Throwable): void;
					public onSuccess(value: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onError(param0: java.lang.Throwable): void;
					public hasCustomOnError(): boolean;
					public onSuccess(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class DeferredScalarDisposable<T>  extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> {
					public static class: java.lang.Class<io.reactivex.internal.observers.DeferredScalarDisposable<any>>;
					public downstream: io.reactivex.Observer<any>;
					public value: any;
					public constructor(downstream: io.reactivex.Observer<any>);
					public constructor(initialValue: number);
					public isEmpty(): boolean;
					public dispose(): void;
					public complete(value: any): void;
					public error(t: java.lang.Throwable): void;
					public poll(): any;
					public isDisposed(): boolean;
					public requestFusion(mode: number): number;
					public tryDispose(): boolean;
					public constructor();
					public clear(): void;
					public complete(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class DeferredScalarObserver<T, R>  extends io.reactivex.internal.observers.DeferredScalarDisposable<any> implements io.reactivex.Observer<any>  {
					public static class: java.lang.Class<io.reactivex.internal.observers.DeferredScalarObserver<any,any>>;
					public upstream: io.reactivex.disposables.Disposable;
					public constructor(downstream: io.reactivex.Observer<any>);
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public constructor(initialValue: number);
					public onError(t: java.lang.Throwable): void;
					public constructor();
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class DisposableLambdaObserver<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.observers.DisposableLambdaObserver<any>>;
					public constructor(actual: io.reactivex.Observer<any>, onSubscribe: io.reactivex.functions.Consumer<any>, onDispose: io.reactivex.functions.Action);
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onNext(param0: T): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: T): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class EmptyCompletableObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.EmptyCompletableObserver>;
					public onError(e: java.lang.Throwable): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public hasCustomOnError(): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class ForEachWhileObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.ForEachWhileObserver<any>>;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public constructor(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action);
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class FutureObserver<T>  extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.observers.FutureObserver<any>>;
					public onError(t: java.lang.Throwable): void;
					public isCancelled(): boolean;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public cancel(param0: boolean): boolean;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public get(): any;
					public isDone(): boolean;
					public constructor();
					public constructor(count: number);
					public get(param0: number, param1: java.util.concurrent.TimeUnit): any;
					public get(timeout: number, param1: java.util.concurrent.TimeUnit): any;
					public cancel(mayInterruptIfRunning: boolean): boolean;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class FutureSingleObserver<T>  extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.observers.FutureSingleObserver<any>>;
					public onError(t: java.lang.Throwable): void;
					public isCancelled(): boolean;
					public onSuccess(t: any): void;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public cancel(param0: boolean): boolean;
					public onError(param0: java.lang.Throwable): void;
					public onSuccess(param0: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public get(): any;
					public isDone(): boolean;
					public constructor();
					public constructor(count: number);
					public get(param0: number, param1: java.util.concurrent.TimeUnit): any;
					public get(timeout: number, param1: java.util.concurrent.TimeUnit): any;
					public cancel(mayInterruptIfRunning: boolean): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class InnerQueuedObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.InnerQueuedObserver<any>>;
					public setDone(): void;
					public onError(t: java.lang.Throwable): void;
					public queue(): io.reactivex.internal.fuseable.SimpleQueue<any>;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public fusionMode(): number;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public constructor(parent: io.reactivex.internal.observers.InnerQueuedObserverSupport<any>, prefetch: number);
					public isDone(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class InnerQueuedObserverSupport<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.observers.InnerQueuedObserverSupport<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.observers.InnerQueuedObserverSupport<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						innerNext(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>, param1: T): void;
						innerError(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>, param1: java.lang.Throwable): void;
						innerComplete(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>): void;
						drain(): void;
					});
					public constructor();
					public innerComplete(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>): void;
					public drain(): void;
					public innerError(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>, param1: java.lang.Throwable): void;
					public innerNext(param0: io.reactivex.internal.observers.InnerQueuedObserver<T>, param1: T): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class LambdaObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.observers.LambdaObserver<any>>;
					public onError(t: java.lang.Throwable): void;
					public dispose(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public constructor(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>);
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public hasCustomOnError(): boolean;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export abstract class QueueDrainObserver<T, U, V>  extends io.reactivex.internal.observers.QueueDrainSubscriberPad2 {
					public static class: java.lang.Class<io.reactivex.internal.observers.QueueDrainObserver<any,any,any>>;
					public downstream: io.reactivex.Observer<any>;
					public queue: io.reactivex.internal.fuseable.SimplePlainQueue<any>;
					public fastPathEmit(value: any, delayError: boolean, dispose: io.reactivex.disposables.Disposable): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public leave(param0: number): number;
					public leave(m: number): number;
					public onComplete(): void;
					public fastPathOrderedEmit(value: any, delayError: boolean, disposable: io.reactivex.disposables.Disposable): void;
					public onError(param0: java.lang.Throwable): void;
					public accept(param0: io.reactivex.Observer<any>, param1: any): void;
					public done(): boolean;
					public enter(): boolean;
					public constructor(actual: io.reactivex.Observer<any>, queue: io.reactivex.internal.fuseable.SimplePlainQueue<any>);
					public fastEnter(): boolean;
					public cancelled(): boolean;
					public error(): java.lang.Throwable;
					public accept(a: io.reactivex.Observer<any>, v: any): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class QueueDrainSubscriberPad0 extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.observers.QueueDrainSubscriberPad0>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class QueueDrainSubscriberPad2 extends io.reactivex.internal.observers.QueueDrainSubscriberWip {
					public static class: java.lang.Class<io.reactivex.internal.observers.QueueDrainSubscriberPad2>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class QueueDrainSubscriberWip extends io.reactivex.internal.observers.QueueDrainSubscriberPad0 {
					public static class: java.lang.Class<io.reactivex.internal.observers.QueueDrainSubscriberWip>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class ResumeSingleObserver<T>  extends io.reactivex.SingleObserver<any> {
					public static class: java.lang.Class<io.reactivex.internal.observers.ResumeSingleObserver<any>>;
					public onSuccess(value: any): void;
					public onError(e: java.lang.Throwable): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public constructor(parent: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, downstream: io.reactivex.SingleObserver<any>);
					public onError(param0: java.lang.Throwable): void;
					public onSuccess(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module observers {
				export class SubscriberCompletableObserver<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.observers.SubscriberCompletableObserver<any>>;
					public onError(e: java.lang.Throwable): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public request(n: number): void;
					public constructor(subscriber: org.reactivestreams.Subscriber<any>);
					public cancel(): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onError(param0: java.lang.Throwable): void;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableAmb extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableAmb>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public constructor(sources: io.reactivex.CompletableSource[], sourcesIterable: java.lang.Iterable<any>);
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableAmb {
						export class Amb extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableAmb.Amb>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableAndThenCompletable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableAndThenCompletable>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.CompletableSource, next: io.reactivex.CompletableSource);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableAndThenCompletable {
						export class NextObserver extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableAndThenCompletable.NextObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SourceObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableAndThenCompletable.SourceObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableCache extends io.reactivex.Completable implements io.reactivex.CompletableObserver {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableCache>;
						public constructor();
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public constructor(source: io.reactivex.CompletableSource);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public onError(param0: java.lang.Throwable): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public onError(e: java.lang.Throwable): void;
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public onComplete(): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableCache {
						export class InnerCompletableCache extends java.util.concurrent.atomic.AtomicBoolean implements io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableCache.InnerCompletableCache>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableConcat extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcat>;
						public constructor(sources: org.reactivestreams.Publisher<any>, prefetch: number);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableConcat {
						export class CompletableConcatSubscriber extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcat.CompletableConcatSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: io.reactivex.CompletableSource): void;
						}
						export module CompletableConcatSubscriber {
							export class ConcatInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcat.CompletableConcatSubscriber.ConcatInnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableConcatArray extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcatArray>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.CompletableSource[]);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableConcatArray {
						export class ConcatInnerObserver extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcatArray.ConcatInnerObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableConcatIterable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcatIterable>;
						public constructor(sources: java.lang.Iterable<any>);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableConcatIterable {
						export class ConcatInnerObserver extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableConcatIterable.ConcatInnerObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableCreate extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableCreate>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableOnSubscribe);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableCreate {
						export class Emitter extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableCreate.Emitter>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onComplete(): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public dispose(): void;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public isDisposed(): boolean;
							public toString(): string;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDefer extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDefer>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(completableSupplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDelay extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDelay>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, delay: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableDelay {
						export class Delay extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDelay.Delay>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDetach extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDetach>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableDetach {
						export class DetachCompletableObserver extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDetach.DetachCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDisposeOn extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDisposeOn>;
						public constructor(source: io.reactivex.CompletableSource, scheduler: io.reactivex.Scheduler);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableDisposeOn {
						export class DisposeOnObserver extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable, java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDisposeOn.DisposeOnObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDoFinally extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDoFinally>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, onFinally: io.reactivex.functions.Action);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableDoFinally {
						export class DoFinallyObserver extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDoFinally.DoFinallyObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableDoOnEvent extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDoOnEvent>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, onEvent: io.reactivex.functions.Consumer<any>);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableDoOnEvent {
						export class DoOnEvent extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableDoOnEvent.DoOnEvent>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableEmpty extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableEmpty>;
						public static INSTANCE: io.reactivex.Completable;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableError extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableError>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(error: java.lang.Throwable);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableErrorSupplier extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableErrorSupplier>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public constructor(errorSupplier: java.util.concurrent.Callable<any>);
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromAction extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromAction>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(run: io.reactivex.functions.Action);
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromCallable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromCallable>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(callable: java.util.concurrent.Callable<any>);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromObservable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromObservable<any>>;
						public constructor(observable: io.reactivex.ObservableSource<any>);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableFromObservable {
						export class CompletableFromObservableObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromObservable.CompletableFromObservableObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromPublisher<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromPublisher<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(flowable: org.reactivestreams.Publisher<any>);
						public subscribeActual(downstream: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableFromPublisher {
						export class FromPublisherSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromPublisher.FromPublisherSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromRunnable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromRunnable>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(runnable: java.lang.Runnable);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromSingle<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromSingle<any>>;
						public constructor(single: io.reactivex.SingleSource<any>);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableFromSingle {
						export class CompletableFromSingleObserver<T>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromSingle.CompletableFromSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableFromUnsafeSource extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableFromUnsafeSource>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableHide extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableHide>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableHide {
						export class HideCompletableObserver extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableHide.HideCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableLift extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableLift>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, onLift: io.reactivex.CompletableOperator);
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMaterialize<T>  extends io.reactivex.Single<io.reactivex.Notification<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMaterialize<any>>;
						public constructor(source: io.reactivex.Completable);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMerge extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMerge>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: org.reactivestreams.Publisher<any>, maxConcurrency: number, delayErrors: boolean);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableMerge {
						export class CompletableMergeSubscriber extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMerge.CompletableMergeSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: io.reactivex.CompletableSource): void;
						}
						export module CompletableMergeSubscriber {
							export class MergeInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMerge.CompletableMergeSubscriber.MergeInnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMergeArray extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeArray>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.CompletableSource[]);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableMergeArray {
						export class InnerCompletableObserver extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeArray.InnerCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMergeDelayErrorArray extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.CompletableSource[]);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableMergeDelayErrorArray {
						export class MergeInnerCompletableObserver extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray.MergeInnerCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMergeDelayErrorIterable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeDelayErrorIterable>;
						public constructor(sources: java.lang.Iterable<any>);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableMergeIterable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeIterable>;
						public constructor(sources: java.lang.Iterable<any>);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableMergeIterable {
						export class MergeCompletableObserver extends java.util.concurrent.atomic.AtomicBoolean implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableMergeIterable.MergeCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableNever extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableNever>;
						public static INSTANCE: io.reactivex.Completable;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableObserveOn extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableObserveOn>;
						public constructor(source: io.reactivex.CompletableSource, scheduler: io.reactivex.Scheduler);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableObserveOn {
						export class ObserveOnCompletableObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableObserveOn.ObserveOnCompletableObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableOnErrorComplete extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableOnErrorComplete>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableOnErrorComplete {
						export class OnError extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableOnErrorComplete.OnError>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletablePeek extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletablePeek>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.CompletableSource, onSubscribe: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onTerminate: io.reactivex.functions.Action, onAfterTerminate: io.reactivex.functions.Action, onDispose: io.reactivex.functions.Action);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletablePeek {
						export class CompletableObserverImplementation extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletablePeek.CompletableObserverImplementation>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableResumeNext extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableResumeNext>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.CompletableSource, errorMapper: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableResumeNext {
						export class ResumeNextObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableResumeNext.ResumeNextObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableSubscribeOn extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableSubscribeOn>;
						public constructor(source: io.reactivex.CompletableSource, scheduler: io.reactivex.Scheduler);
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableSubscribeOn {
						export class SubscribeOnObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableSubscribeOn.SubscribeOnObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableTakeUntilCompletable extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTakeUntilCompletable>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.Completable, other: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableTakeUntilCompletable {
						export class TakeUntilMainObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTakeUntilCompletable.TakeUntilMainObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module TakeUntilMainObserver {
							export class OtherObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTakeUntilCompletable.TakeUntilMainObserver.OtherObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableTimeout extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimeout>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.CompletableSource, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: io.reactivex.CompletableSource);
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableTimeout {
						export class DisposeTask extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimeout.DisposeTask>;
							public run(): void;
						}
						export module DisposeTask {
							export class DisposeObserver extends java.lang.Object implements io.reactivex.CompletableObserver {
								public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimeout.DisposeTask.DisposeObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
						export class TimeOutObserver extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimeout.TimeOutObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableTimer extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimer>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableTimer {
						export class TimerDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableTimer.TimerDisposable>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableToFlowable<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableToFlowable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.CompletableSource);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableToObservable<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableToObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.CompletableSource);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module CompletableToObservable {
						export class ObserverCompletableObserver extends io.reactivex.internal.observers.BasicQueueDisposable<java.lang.Void> implements io.reactivex.CompletableObserver  {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableToObservable.ObserverCompletableObserver>;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public onError(param0: java.lang.Throwable): void;
							public poll(): java.lang.Void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableToSingle<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableToSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.CompletableSource, completionValueSupplier: java.util.concurrent.Callable<any>, completionValue: any);
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module CompletableToSingle {
						export class ToSingle extends java.lang.Object implements io.reactivex.CompletableObserver {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableToSingle.ToSingle>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module completable {
					export class CompletableUsing<R>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableUsing<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(resourceSupplier: java.util.concurrent.Callable<any>, completableFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module CompletableUsing {
						export class UsingObserver<R>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.completable.CompletableUsing.UsingObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export abstract class AbstractFlowableWithUpstream<T, R>  extends io.reactivex.Flowable<any> implements io.reactivex.internal.fuseable.HasUpstreamPublisher<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class BlockingFlowableIterable<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableIterable<any>>;
						public constructor(source: io.reactivex.Flowable<any>, bufferSize: number);
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public forEach(action: any /* any*/): void;
					}
					export module BlockingFlowableIterable {
						export class BlockingFlowableIterator<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableIterable.BlockingFlowableIterator<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public hasNext(): boolean;
							public remove(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public next(): any;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class BlockingFlowableLatest<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableLatest<any>>;
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public constructor(source: org.reactivestreams.Publisher<any>);
						public forEach(action: any /* any*/): void;
					}
					export module BlockingFlowableLatest {
						export class LatestSubscriberIterator<T>  extends io.reactivex.subscribers.DisposableSubscriber<io.reactivex.Notification<any>> implements java.util.Iterator<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableLatest.LatestSubscriberIterator<any>>;
							public onNext(args: io.reactivex.Notification<any>): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public hasNext(): boolean;
							public remove(): void;
							public isDisposed(): boolean;
							public next(): any;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class BlockingFlowableMostRecent<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent<any>>;
						public constructor(source: io.reactivex.Flowable<any>, initialValue: any);
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public forEach(action: any /* any*/): void;
					}
					export module BlockingFlowableMostRecent {
						export class MostRecentSubscriber<T>  extends io.reactivex.subscribers.DefaultSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent.MostRecentSubscriber<any>>;
							public onComplete(): void;
							public onNext(args: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public getIterable(): io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent.MostRecentSubscriber.Iterator;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(e: java.lang.Throwable): void;
						}
						export module MostRecentSubscriber {
							export class Iterator extends java.util.Iterator<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent.MostRecentSubscriber.Iterator>;
								public next(): any;
								public hasNext(): boolean;
								public remove(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class BlockingFlowableNext<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableNext<any>>;
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public constructor(source: org.reactivestreams.Publisher<any>);
						public forEach(action: any /* any*/): void;
					}
					export module BlockingFlowableNext {
						export class NextIterator<T>  extends java.util.Iterator<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextIterator<any>>;
							public hasNext(): boolean;
							public remove(): void;
							public next(): any;
						}
						export class NextSubscriber<T>  extends io.reactivex.subscribers.DisposableSubscriber<io.reactivex.Notification<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextSubscriber<any>>;
							public onNext(args: io.reactivex.Notification<any>): void;
							public onComplete(): void;
							public takeNext(): io.reactivex.Notification<any>;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAll<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAll<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableAll {
						export class AllSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<java.lang.Boolean> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAll.AllSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAllSingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToFlowable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAllSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<java.lang.Boolean>;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableAllSingle {
						export class AllSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAllSingle.AllSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAmb<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAmb<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(sources: org.reactivestreams.Publisher<any>[], sourcesIterable: java.lang.Iterable<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableAmb {
						export class AmbCoordinator<T>  extends org.reactivestreams.Subscription {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAmb.AmbCoordinator<any>>;
							public cancel(): void;
							public request(n: number): void;
							public subscribe(sources: org.reactivestreams.Publisher<any>[]): void;
							public request(param0: number): void;
							public win(index: number): boolean;
						}
						export class AmbInnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAmb.AmbInnerSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAny<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAny<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableAny {
						export class AnySubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<java.lang.Boolean> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAny.AnySubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAnySingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToFlowable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAnySingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<java.lang.Boolean>;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableAnySingle {
						export class AnySubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAnySingle.AnySubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableAutoConnect<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableAutoConnect<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribeActual(child: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.flowables.ConnectableFlowable<any>, numberOfSubscribers: number, connection: io.reactivex.functions.Consumer<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBlockingSubscribe extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBlockingSubscribe>;
						public static subscribe(o: org.reactivestreams.Publisher, subscriber: org.reactivestreams.Subscriber): void;
						public static subscribe(o: org.reactivestreams.Publisher): void;
						public static subscribe(o: org.reactivestreams.Publisher, onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, bufferSize: number): void;
						public static subscribe(o: org.reactivestreams.Publisher, onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBuffer<T, C>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBuffer<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, size: number, skip: number, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableBuffer {
						export class PublisherBufferExactSubscriber<T, C>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferExactSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class PublisherBufferOverlappingSubscriber<T, C>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferOverlappingSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public getAsBoolean(): boolean;
						}
						export class PublisherBufferSkipSubscriber<T, C>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferSkipSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBufferBoundary<T, U, Open, Close>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundary<any,any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, bufferOpen: org.reactivestreams.Publisher<any>, bufferClose: io.reactivex.functions.Function<any,any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableBufferBoundary {
						export class BufferBoundarySubscriber<T, C, Open, Close>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferBoundarySubscriber<any,any,any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module BufferBoundarySubscriber {
							export class BufferOpenSubscriber<Open>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferBoundarySubscriber.BufferOpenSubscriber<any>>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public dispose(): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public isDisposed(): boolean;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onNext(param0: any): void;
							}
						}
						export class BufferCloseSubscriber<T, C>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferCloseSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBufferBoundarySupplier<T, U, B>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, boundarySupplier: java.util.concurrent.Callable<any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableBufferBoundarySupplier {
						export class BufferBoundarySubscriber<T, U, B>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier.BufferBoundarySubscriber<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class BufferBoundarySupplierSubscriber<T, U, B>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier.BufferBoundarySupplierSubscriber<any,any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public dispose(): void;
							public isDisposed(): boolean;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBufferExactBoundary<T, U, B>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, boundary: org.reactivestreams.Publisher<any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableBufferExactBoundary {
						export class BufferBoundarySubscriber<T, U, B>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary.BufferBoundarySubscriber<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class BufferExactBoundarySubscriber<T, U, B>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary.BufferExactBoundarySubscriber<any,any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public dispose(): void;
							public isDisposed(): boolean;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableBufferTimed<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferTimed<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, timespan: number, param2: number, timeskip: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: java.util.concurrent.Callable<any>, scheduler: number, bufferSupplier: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableBufferTimed {
						export class BufferExactBoundedSubscriber<T, U>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferExactBoundedSubscriber<any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public dispose(): void;
							public isDisposed(): boolean;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
							public run(): void;
						}
						export class BufferExactUnboundedSubscriber<T, U>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferExactUnboundedSubscriber<any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public dispose(): void;
							public isDisposed(): boolean;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
							public run(): void;
						}
						export class BufferSkipBoundedSubscriber<T, U>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferSkipBoundedSubscriber<any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
							public run(): void;
						}
						export module BufferSkipBoundedSubscriber {
							export class RemoveFromBuffer extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferSkipBoundedSubscriber.RemoveFromBuffer>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCache<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> implements io.reactivex.FlowableSubscriber<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCache<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public onSubscribe(param0: org.reactivestreams.Subscription): void;
						public onNext(param0: any): void;
						public onNext(t: any): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public onError(param0: java.lang.Throwable): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, capacityHint: number);
						public onComplete(): void;
						public source(): org.reactivestreams.Publisher<any>;
						public onError(t: java.lang.Throwable): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public onSubscribe(s: org.reactivestreams.Subscription): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableCache {
						export class CacheSubscription<T>  extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCache.CacheSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
						export class Node<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCache.Node<any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCollect<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCollect<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, initialSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableCollect {
						export class CollectSubscriber<T, U>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCollect.CollectSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCollectSingle<T, U>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCollectSingle<any,any>>;
						public constructor(source: io.reactivex.Flowable<any>, initialSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableCollectSingle {
						export class CollectSubscriber<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCollectSingle.CollectSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCombineLatest<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCombineLatest<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(iterable: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, delayErrors: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(array: org.reactivestreams.Publisher<any>[], combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, delayErrors: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableCombineLatest {
						export class CombineLatestCoordinator<T, R>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCombineLatest.CombineLatestCoordinator<any,any>>;
							public cancel(): void;
							public requestFusion(requestedMode: number): number;
							public request(n: number): void;
							public clear(): void;
							public poll(): any;
							public isEmpty(): boolean;
						}
						export class CombineLatestInnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCombineLatest.CombineLatestInnerSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public requestOne(): void;
							public onNext(t: any): void;
						}
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCombineLatest.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatArray<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatArray<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(sources: org.reactivestreams.Publisher<any>[], delayError: boolean);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatArray {
						export class ConcatArraySubscriber<T>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatArray.ConcatArraySubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatMap<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public static subscribe(s: org.reactivestreams.Subscriber, mapper: io.reactivex.functions.Function<any,any>, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode): org.reactivestreams.Subscriber;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
					}
					export module FlowableConcatMap {
						export abstract class BaseConcatMapSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.BaseConcatMapSubscriber<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public innerNext(param0: any): void;
						}
						export class ConcatMapDelayed<T, R>  extends io.reactivex.internal.operators.flowable.FlowableConcatMap.BaseConcatMapSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapDelayed<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(): void;
							public request(param0: number): void;
							public innerError(e: java.lang.Throwable): void;
							public innerNext(value: any): void;
							public innerNext(param0: any): void;
						}
						export class ConcatMapImmediate<T, R>  extends io.reactivex.internal.operators.flowable.FlowableConcatMap.BaseConcatMapSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapImmediate<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(): void;
							public request(param0: number): void;
							public innerError(e: java.lang.Throwable): void;
							public innerNext(value: any): void;
							public innerNext(param0: any): void;
						}
						export class ConcatMapInner<R>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapInner<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export class ConcatMapSupport<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapSupport<any>>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableConcatMap$ConcatMapSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								innerNext(param0: T): void;
								innerComplete(): void;
								innerError(param0: java.lang.Throwable): void;
							});
							public constructor();
							public innerNext(param0: T): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(): void;
						}
						export class SimpleScalarSubscription<T>  extends java.util.concurrent.atomic.AtomicBoolean implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMap.SimpleScalarSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatMapEager<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMapEager<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatMapEager {
						export class ConcatMapEagerDelayErrorSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMapEager.ConcatMapEagerDelayErrorSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public innerNext(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>, param1: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public drain(): void;
							public innerError(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>, param1: java.lang.Throwable): void;
							public innerError(inner: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>, e: java.lang.Throwable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public innerNext(inner: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>, value: any): void;
							public innerComplete(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>): void;
							public innerComplete(inner: io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatMapEagerPublisher<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMapEagerPublisher<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, mapper: io.reactivex.functions.Function<any,any>, maxConcurrency: number, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatMapPublisher<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatMapPublisher<any,any>>;
						public constructor(source: org.reactivestreams.Publisher<any>, mapper: io.reactivex.functions.Function<any,any>, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatWithCompletable<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithCompletable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.CompletableSource);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatWithCompletable {
						export class ConcatWithSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithCompletable.ConcatWithSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatWithMaybe<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithMaybe<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.MaybeSource<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatWithMaybe {
						export class ConcatWithSubscriber<T>  extends io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithMaybe.ConcatWithSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onSuccess(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableConcatWithSingle<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithSingle<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.SingleSource<any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatWithSingle {
						export class ConcatWithSubscriber<T>  extends io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,any> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableConcatWithSingle.ConcatWithSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onSuccess(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCount<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCount<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableCount {
						export class CountSubscriber extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<java.lang.Long> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCount.CountSubscriber>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCountSingle<T>  extends io.reactivex.Single<java.lang.Long> implements io.reactivex.internal.fuseable.FuseToFlowable<java.lang.Long>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCountSingle<any>>;
						public constructor();
						public fuseToFlowable(): io.reactivex.Flowable<java.lang.Long>;
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>);
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableCountSingle {
						export class CountSubscriber extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCountSingle.CountSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableCreate<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.FlowableOnSubscribe<any>, backpressure: io.reactivex.BackpressureStrategy);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableCreate {
						export abstract class BaseEmitter<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter<any>>;
							public cancel(): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public request(n: number): void;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public toString(): string;
							public request(param0: number): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public requested(): number;
							public tryOnError(e: java.lang.Throwable): boolean;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public complete(): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public error(e: java.lang.Throwable): boolean;
						}
						export class BufferAsyncEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.BufferAsyncEmitter<any>>;
							public cancel(): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public request(n: number): void;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public requested(): number;
							public tryOnError(e: java.lang.Throwable): boolean;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
						export class DropAsyncEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.NoOverflowBaseAsyncEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.DropAsyncEmitter<any>>;
							public cancel(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public requested(): number;
							public request(n: number): void;
							public tryOnError(e: java.lang.Throwable): boolean;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
						}
						export class ErrorAsyncEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.NoOverflowBaseAsyncEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.ErrorAsyncEmitter<any>>;
							public cancel(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public requested(): number;
							public request(n: number): void;
							public tryOnError(e: java.lang.Throwable): boolean;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
						}
						export class LatestAsyncEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.LatestAsyncEmitter<any>>;
							public cancel(): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public request(n: number): void;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public requested(): number;
							public tryOnError(e: java.lang.Throwable): boolean;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
						export class MissingEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.MissingEmitter<any>>;
							public cancel(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public request(n: number): void;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public requested(): number;
							public tryOnError(e: java.lang.Throwable): boolean;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
						export abstract class NoOverflowBaseAsyncEmitter<T>  extends io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.NoOverflowBaseAsyncEmitter<any>>;
							public cancel(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public request(n: number): void;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public requested(): number;
							public tryOnError(e: java.lang.Throwable): boolean;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
						export class SerializedEmitter<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableEmitter<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableCreate.SerializedEmitter<any>>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public isCancelled(): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public toString(): string;
							public onNext(t: any): void;
							public serialize(): io.reactivex.FlowableEmitter<any>;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public requested(): number;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDebounce<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounce<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, debounceSelector: io.reactivex.functions.Function<any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDebounce {
						export class DebounceSubscriber<T, U>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounce.DebounceSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module DebounceSubscriber {
							export class DebounceInnerSubscriber<T, U>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounce.DebounceSubscriber.DebounceInnerSubscriber<any,any>>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public dispose(): void;
								public onNext(t: any): void;
								public isDisposed(): boolean;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDebounceTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounceTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDebounceTimed {
						export class DebounceEmitter<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounceTimed.DebounceEmitter<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
						export class DebounceTimedSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDebounceTimed.DebounceTimedSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDefer<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDefer<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(supplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDelay<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelay<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, delay: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDelay {
						export class DelaySubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelay.DelaySubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export module DelaySubscriber {
							export class OnComplete extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelay.DelaySubscriber.OnComplete>;
								public run(): void;
							}
							export class OnError extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelay.DelaySubscriber.OnError>;
								public run(): void;
							}
							export class OnNext extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelay.DelaySubscriber.OnNext>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDelaySubscriptionOther<T, U>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribeActual(child: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(main: org.reactivestreams.Publisher<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDelaySubscriptionOther {
						export class MainSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther.MainSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module MainSubscriber {
							export class OtherSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther.MainSubscriber.OtherSubscriber>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDematerialize<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDematerialize<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, selector: io.reactivex.functions.Function<any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDematerialize {
						export class DematerializeSubscriber<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDematerialize.DematerializeSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(item: T): void;
							public onNext(param0: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDetach<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDetach<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDetach {
						export class DetachSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDetach.DetachSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDistinct<T, K>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDistinct<any,any>>;
						public constructor(source: io.reactivex.Flowable<any>, keySelector: io.reactivex.functions.Function<any,any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDistinct {
						export class DistinctSubscriber<T, K>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDistinct.DistinctSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onError(e: java.lang.Throwable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDistinctUntilChanged<T, K>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, keySelector: io.reactivex.functions.Function<any,any>, comparer: io.reactivex.functions.BiPredicate<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDistinctUntilChanged {
						export class DistinctUntilChangedConditionalSubscriber<T, K>  extends io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber<any,any>>;
							public requestFusion(mode: number): number;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class DistinctUntilChangedSubscriber<T, K>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> implements io.reactivex.internal.fuseable.ConditionalSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged.DistinctUntilChangedSubscriber<any,any>>;
							public requestFusion(mode: number): number;
							public onComplete(): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDoAfterNext<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoAfterNext<any>>;
						public constructor(source: io.reactivex.Flowable<any>, onAfterNext: io.reactivex.functions.Consumer<any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDoAfterNext {
						export class DoAfterConditionalSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoAfterNext.DoAfterConditionalSubscriber<any>>;
							public requestFusion(mode: number): number;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class DoAfterSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoAfterNext.DoAfterSubscriber<any>>;
							public requestFusion(mode: number): number;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDoFinally<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoFinally<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, onFinally: io.reactivex.functions.Action);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDoFinally {
						export class DoFinallyConditionalSubscriber<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.internal.fuseable.ConditionalSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoFinally.DoFinallyConditionalSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public isEmpty(): boolean;
						}
						export class DoFinallySubscriber<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoFinally.DoFinallySubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDoOnEach<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoOnEach<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onAfterTerminate: io.reactivex.functions.Action);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDoOnEach {
						export class DoOnEachConditionalSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoOnEach.DoOnEachConditionalSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class DoOnEachSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoOnEach.DoOnEachSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableDoOnLifecycle<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, onSubscribe: io.reactivex.functions.Consumer<any>, onRequest: io.reactivex.functions.LongConsumer, onCancel: io.reactivex.functions.Action);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableDoOnLifecycle {
						export class SubscriptionLambdaSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle.SubscriptionLambdaSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableElementAt<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAt<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, index: number, param2: any, defaultValue: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableElementAt {
						export class ElementAtSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAt.ElementAtSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableElementAtMaybe<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAtMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, index: number);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableElementAtMaybe {
						export class ElementAtSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAtMaybe.ElementAtSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableElementAtSingle<T>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAtSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, index: number, param2: any);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableElementAtSingle {
						export class ElementAtSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableElementAtSingle.ElementAtSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableEmpty extends io.reactivex.Flowable<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableEmpty>;
						public static INSTANCE: io.reactivex.Flowable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public call(): any;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableError<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableError<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(errorSupplier: java.util.concurrent.Callable<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFilter<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFilter<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFilter {
						export class FilterConditionalSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFilter.FilterConditionalSubscriber<any>>;
							public requestFusion(mode: number): number;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class FilterSubscriber<T>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> implements io.reactivex.internal.fuseable.ConditionalSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFilter.FilterSubscriber<any>>;
							public requestFusion(mode: number): number;
							public onComplete(): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMap<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMap<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public static subscribe(s: org.reactivestreams.Subscriber, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number): io.reactivex.FlowableSubscriber<any>;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlatMap {
						export class InnerSubscriber<T, U>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMap.InnerSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class MergeSubscriber<T, U>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMap.MergeSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMapCompletable<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlatMapCompletable {
						export class FlatMapCompletableMainSubscriber<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable.FlatMapCompletableMainSubscriber<any>>;
							public cancel(): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onNext(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
						export module FlatMapCompletableMainSubscriber {
							export class InnerConsumer extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable.FlatMapCompletableMainSubscriber.InnerConsumer>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMapCompletableCompletable<T>  extends io.reactivex.Completable implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlatMapCompletableCompletable {
						export class FlatMapCompletableMainSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable.FlatMapCompletableMainSubscriber<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onNext(value: any): void;
						}
						export module FlatMapCompletableMainSubscriber {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable.FlatMapCompletableMainSubscriber.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMapMaybe<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayError: boolean, maxConcurrency: number);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlatMapMaybe {
						export class FlatMapMaybeSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe.FlatMapMaybeSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module FlatMapMaybeSubscriber {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe.FlatMapMaybeSubscriber.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMapPublisher<T, U>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapPublisher<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: org.reactivestreams.Publisher<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlatMapSingle<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapSingle<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayError: boolean, maxConcurrency: number);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlatMapSingle {
						export class FlatMapSingleSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapSingle.FlatMapSingleSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module FlatMapSingleSubscriber {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlatMapSingle.FlatMapSingleSubscriber.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFlattenIterable<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlattenIterable<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, prefetch: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFlattenIterable {
						export class FlattenIterableSubscriber<T, R>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFlattenIterable.FlattenIterableSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(requestedMode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromArray<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromArray<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(array: any[]);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFromArray {
						export class ArrayConditionalSubscription<T>  extends io.reactivex.internal.operators.flowable.FlowableFromArray.BaseArraySubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromArray.ArrayConditionalSubscription<any>>;
						}
						export class ArraySubscription<T>  extends io.reactivex.internal.operators.flowable.FlowableFromArray.BaseArraySubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromArray.ArraySubscription<any>>;
						}
						export abstract class BaseArraySubscription<T>  extends io.reactivex.internal.subscriptions.BasicQueueSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromArray.BaseArraySubscription<any>>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public clear(): void;
							public poll(): any;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromCallable<T>  extends io.reactivex.Flowable<any> implements java.util.concurrent.Callable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromCallable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public constructor(callable: java.util.concurrent.Callable<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromFuture<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromFuture<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromIterable<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromIterable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: java.lang.Iterable<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public static subscribe(s: org.reactivestreams.Subscriber, it: java.util.Iterator<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFromIterable {
						export abstract class BaseRangeSubscription<T>  extends io.reactivex.internal.subscriptions.BasicQueueSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromIterable.BaseRangeSubscription<any>>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public clear(): void;
							public poll(): any;
							public isEmpty(): boolean;
						}
						export class IteratorConditionalSubscription<T>  extends io.reactivex.internal.operators.flowable.FlowableFromIterable.BaseRangeSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromIterable.IteratorConditionalSubscription<any>>;
						}
						export class IteratorSubscription<T>  extends io.reactivex.internal.operators.flowable.FlowableFromIterable.BaseRangeSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromIterable.IteratorSubscription<any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromObservable<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(upstream: io.reactivex.Observable<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableFromObservable {
						export class SubscriberObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromObservable.SubscriberObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(value: T): void;
							public request(n: number): void;
							public onNext(param0: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableFromPublisher<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableFromPublisher<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(publisher: org.reactivestreams.Publisher<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableGenerate<T, S>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGenerate<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(stateSupplier: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any>, disposeState: io.reactivex.functions.Consumer<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableGenerate {
						export class GeneratorSubscription<T, S>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGenerate.GeneratorSubscription<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableGroupBy<T, K, V>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.flowables.GroupedFlowable<any,any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupBy<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean, mapFactory: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableGroupBy {
						export class EvictionAction<K, V>  extends io.reactivex.functions.Consumer<io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupBy.EvictionAction<any,any>>;
							public accept(value: io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>): void;
							public accept(param0: any): void;
						}
						export class GroupBySubscriber<T, K, V>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<io.reactivex.flowables.GroupedFlowable<any,any>> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber<any,any,any>>;
							public constructor();
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): io.reactivex.flowables.GroupedFlowable<any,any>;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public constructor(actual: org.reactivestreams.Subscriber<any>, keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean, groups: java.util.Map<any,io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>>, evictedGroups: java.util.Queue<io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>>);
							public cancel(key: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public constructor(initialValue: number);
							public isEmpty(): boolean;
						}
						export class GroupedUnicast<K, T>  extends io.reactivex.flowables.GroupedFlowable<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>>;
							public constructor();
							public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
							public onComplete(): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public constructor(key: any, state: io.reactivex.internal.operators.flowable.FlowableGroupBy.State<any,any>);
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public onNext(t: any): void;
							public constructor(key: any);
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
							public static createWith(key: any, bufferSize: number, parent: io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber<any,any,any>, delayError: boolean): io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast<any,any>;
							public onError(e: java.lang.Throwable): void;
						}
						export class State<T, K>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements org.reactivestreams.Publisher<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupBy.State<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public clear(): void;
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public poll(): any;
							public isEmpty(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupJoin<any,any,any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableGroupJoin {
						export class GroupJoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupJoin.GroupJoinSubscription<any,any,any,any,any>>;
							public cancel(): void;
							public innerComplete(param0: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
							public request(n: number): void;
							public innerClose(isLeft: boolean, index: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
							public innerValue(isLeft: boolean, o: any): void;
							public innerCloseError(ex: java.lang.Throwable): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(sender: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
							public request(param0: number): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerCloseError(param0: java.lang.Throwable): void;
							public innerError(ex: java.lang.Throwable): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
						}
						export class JoinSupport extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupJoin.JoinSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableGroupJoin$JoinSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								innerError(param0: java.lang.Throwable): void;
								innerComplete(param0: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
								innerValue(param0: boolean, param1: any): void;
								innerClose(param0: boolean, param1: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
								innerCloseError(param0: java.lang.Throwable): void;
							});
							public constructor();
							public innerComplete(param0: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerCloseError(param0: java.lang.Throwable): void;
						}
						export class LeftRightEndSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class LeftRightSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableHide<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableHide<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableHide {
						export class HideSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableHide.HideSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableIgnoreElements<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIgnoreElements<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableIgnoreElements {
						export class IgnoreElementsSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIgnoreElements.IgnoreElementsSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public offer(e: T): boolean;
							public requestFusion(mode: number): number;
							public offer(param0: T, param1: T): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public offer(param0: T): boolean;
							public clear(): void;
							public offer(v1: T, v2: T): boolean;
							public request(param0: number): void;
							public onError(param0: java.lang.Throwable): void;
							public poll(): T;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public requestFusion(param0: number): number;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableIgnoreElementsCompletable<T>  extends io.reactivex.Completable implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(t: io.reactivex.CompletableObserver): void;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module FlowableIgnoreElementsCompletable {
						export class IgnoreElementsSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable.IgnoreElementsSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableInternalHelper extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper>;
						public static simpleBiGenerator(consumer: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.functions.BiFunction<any,any,any>;
						public static flatMapWithCombiner(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.functions.Function<any,any>;
						public static subscriberOnComplete(subscriber: org.reactivestreams.Subscriber): io.reactivex.functions.Action;
						public static subscriberOnError(subscriber: org.reactivestreams.Subscriber): io.reactivex.functions.Consumer<any>;
						public static zipIterable(zipper: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
						public static replayCallable(parent: io.reactivex.Flowable<any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): java.util.concurrent.Callable<any>;
						public static replayCallable(parent: io.reactivex.Flowable<any>, bufferSize: number): java.util.concurrent.Callable<any>;
						public static replayCallable(parent: io.reactivex.Flowable<any>): java.util.concurrent.Callable<any>;
						public static replayFunction(selector: io.reactivex.functions.Function<any,any>, scheduler: io.reactivex.Scheduler): io.reactivex.functions.Function<any,any>;
						public static simpleGenerator(consumer: io.reactivex.functions.Consumer<any>): io.reactivex.functions.BiFunction<any,any,any>;
						public static replayCallable(parent: io.reactivex.Flowable<any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): java.util.concurrent.Callable<any>;
						public static subscriberOnNext(subscriber: org.reactivestreams.Subscriber): io.reactivex.functions.Consumer<any>;
						public static itemDelay(itemDelay: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
						public static flatMapIntoIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
					}
					export module FlowableInternalHelper {
						export class BufferedReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.flowables.ConnectableFlowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.BufferedReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.flowables.ConnectableFlowable<any>;
						}
						export class BufferedTimedReplay<T>  extends java.util.concurrent.Callable<io.reactivex.flowables.ConnectableFlowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.BufferedTimedReplay<any>>;
							public call(): any;
							public call(): io.reactivex.flowables.ConnectableFlowable<any>;
						}
						export class FlatMapIntoIterable<T, U>  extends io.reactivex.functions.Function<any,org.reactivestreams.Publisher<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapIntoIterable<any,any>>;
							public apply(param0: any): any;
							public apply(t: any): org.reactivestreams.Publisher<any>;
						}
						export class FlatMapWithCombinerInner<U, R, T>  extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapWithCombinerInner<any,any,any>>;
							public apply(w: any): any;
							public apply(param0: any): any;
						}
						export class FlatMapWithCombinerOuter<T, R, U>  extends io.reactivex.functions.Function<any,org.reactivestreams.Publisher<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapWithCombinerOuter<any,any,any>>;
							public apply(param0: any): any;
							public apply(t: any): org.reactivestreams.Publisher<any>;
						}
						export class ItemDelayFunction<T, U>  extends io.reactivex.functions.Function<any,org.reactivestreams.Publisher<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.ItemDelayFunction<any,any>>;
							public apply(v: any): org.reactivestreams.Publisher<any>;
							public apply(param0: any): any;
						}
						export class ReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.flowables.ConnectableFlowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.ReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.flowables.ConnectableFlowable<any>;
						}
						export class ReplayFunction<T, R>  extends io.reactivex.functions.Function<io.reactivex.Flowable<any>,org.reactivestreams.Publisher<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.ReplayFunction<any,any>>;
							public apply(t: io.reactivex.Flowable<any>): org.reactivestreams.Publisher<any>;
							public apply(param0: any): any;
						}
						export class RequestMax extends io.reactivex.functions.Consumer<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.RequestMax>;
							public static INSTANCE: io.reactivex.internal.operators.flowable.FlowableInternalHelper.RequestMax;
							public static values(): io.reactivex.internal.operators.flowable.FlowableInternalHelper.RequestMax[];
							public accept(t: org.reactivestreams.Subscription): void;
							public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
							public accept(param0: any): void;
							public static valueOf(name: string): io.reactivex.internal.operators.flowable.FlowableInternalHelper.RequestMax;
						}
						export class SimpleBiGenerator<T, S>  extends io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.SimpleBiGenerator<any,any>>;
							public apply(t1: any, t2: io.reactivex.Emitter<any>): any;
							public apply(param0: any, param1: any): any;
						}
						export class SimpleGenerator<T, S>  extends io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.SimpleGenerator<any,any>>;
							public apply(t1: any, t2: io.reactivex.Emitter<any>): any;
							public apply(param0: any, param1: any): any;
						}
						export class SubscriberOnComplete<T>  extends io.reactivex.functions.Action {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnComplete<any>>;
							public run(): void;
						}
						export class SubscriberOnError<T>  extends io.reactivex.functions.Consumer<java.lang.Throwable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnError<any>>;
							public accept(v: java.lang.Throwable): void;
							public accept(param0: any): void;
						}
						export class SubscriberOnNext<T>  extends io.reactivex.functions.Consumer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnNext<any>>;
							public accept(param0: any): void;
							public accept(v: any): void;
						}
						export class TimedReplay<T>  extends java.util.concurrent.Callable<io.reactivex.flowables.ConnectableFlowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.TimedReplay<any>>;
							public call(): any;
							public call(): io.reactivex.flowables.ConnectableFlowable<any>;
						}
						export class ZipIterableFunction<T, R>  extends io.reactivex.functions.Function<java.util.List<org.reactivestreams.Publisher<any>>,org.reactivestreams.Publisher<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInternalHelper.ZipIterableFunction<any,any>>;
							public apply(list: java.util.List<org.reactivestreams.Publisher<any>>): org.reactivestreams.Publisher<any>;
							public apply(param0: any): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableInterval extends io.reactivex.Flowable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInterval>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableInterval {
						export class IntervalSubscriber extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription, java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableInterval.IntervalSubscriber>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableIntervalRange extends io.reactivex.Flowable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIntervalRange>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(start: number, param1: number, end: number, param3: number, initialDelay: java.util.concurrent.TimeUnit, param5: io.reactivex.Scheduler);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableIntervalRange {
						export class IntervalRangeSubscriber extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription, java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableIntervalRange.IntervalRangeSubscriber>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableJoin<any,any,any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableJoin {
						export class JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableJoin.JoinSubscription<any,any,any,any,any>>;
							public cancel(): void;
							public innerComplete(param0: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
							public request(n: number): void;
							public innerClose(isLeft: boolean, index: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
							public innerValue(isLeft: boolean, o: any): void;
							public innerCloseError(ex: java.lang.Throwable): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerComplete(sender: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightSubscriber): void;
							public request(param0: number): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerCloseError(param0: java.lang.Throwable): void;
							public innerError(ex: java.lang.Throwable): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.flowable.FlowableGroupJoin.LeftRightEndSubscriber): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableJust<T>  extends io.reactivex.Flowable<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableJust<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(value: any);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableLastMaybe<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLastMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: org.reactivestreams.Publisher<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module FlowableLastMaybe {
						export class LastSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLastMaybe.LastSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableLastSingle<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLastSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, defaultItem: any);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module FlowableLastSingle {
						export class LastSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLastSingle.LastSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableLift<R, T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLift<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, operator: io.reactivex.FlowableOperator<any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableLimit<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLimit<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, n: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableLimit {
						export class LimitSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableLimit.LimitSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMap<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMap<any,any>>;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMap {
						export class MapConditionalSubscriber<T, U>  extends io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMap.MapConditionalSubscriber<any,any>>;
							public requestFusion(mode: number): number;
							public poll(): any;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class MapSubscriber<T, U>  extends io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMap.MapSubscriber<any,any>>;
							public requestFusion(mode: number): number;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMapNotification<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMapNotification<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMapNotification {
						export class MapNotificationSubscriber<T, R>  extends io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMapNotification.MapNotificationSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMapPublisher<T, U>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMapPublisher<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMaterialize<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Notification<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMaterialize<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMaterialize {
						export class MaterializeSubscriber<T>  extends io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,io.reactivex.Notification<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMaterialize.MaterializeSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onDrop(n: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onDrop(n: io.reactivex.Notification<any>): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMergeWithCompletable<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithCompletable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.CompletableSource);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMergeWithCompletable {
						export class MergeWithSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithCompletable.MergeWithSubscriber<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(ex: java.lang.Throwable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module MergeWithSubscriber {
							export class OtherObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithCompletable.MergeWithSubscriber.OtherObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMergeWithMaybe<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.MaybeSource<any>);
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMergeWithMaybe {
						export class MergeWithObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe.MergeWithObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(ex: java.lang.Throwable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module MergeWithObserver {
							export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe.MergeWithObserver.OtherObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableMergeWithSingle<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithSingle<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, other: io.reactivex.SingleSource<any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableMergeWithSingle {
						export class MergeWithObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithSingle.MergeWithObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(ex: java.lang.Throwable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module MergeWithObserver {
							export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableMergeWithSingle.MergeWithObserver.OtherObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableNever extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableNever>;
						public static INSTANCE: io.reactivex.Flowable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableObserveOn<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableObserveOn<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, scheduler: io.reactivex.Scheduler, delayError: boolean, prefetch: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableObserveOn {
						export abstract class BaseObserveOnSubscriber<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(requestedMode: number): number;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public clear(): void;
							public isEmpty(): boolean;
							public onNext(t: any): void;
							public run(): void;
						}
						export class ObserveOnConditionalSubscriber<T>  extends io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableObserveOn.ObserveOnConditionalSubscriber<any>>;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public run(): void;
						}
						export class ObserveOnSubscriber<T>  extends io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableObserveOn.ObserveOnSubscriber<any>>;
							public onComplete(): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public poll(): any;
							public onNext(t: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnBackpressureBuffer<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, bufferSize: number, unbounded: boolean, delayError: boolean, onOverflow: io.reactivex.functions.Action);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnBackpressureBuffer {
						export class BackpressureBufferSubscriber<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer.BackpressureBufferSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public clear(): void;
							public poll(): any;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnBackpressureBufferStrategy<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, bufferSize: number, param2: io.reactivex.functions.Action, onOverflow: io.reactivex.BackpressureOverflowStrategy);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnBackpressureBufferStrategy {
						export class OnBackpressureBufferStrategySubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy.OnBackpressureBufferStrategySubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnBackpressureDrop<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> implements io.reactivex.functions.Consumer<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public accept(param0: any): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public accept(t: any): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, onDrop: io.reactivex.functions.Consumer<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnBackpressureDrop {
						export class BackpressureDropSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop.BackpressureDropSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnBackpressureError<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureError<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnBackpressureError {
						export class BackpressureErrorSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureError.BackpressureErrorSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnBackpressureLatest<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnBackpressureLatest {
						export class BackpressureLatestSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest.BackpressureLatestSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnErrorNext<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnErrorNext<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, nextSupplier: io.reactivex.functions.Function<any,any>, allowFatal: boolean);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnErrorNext {
						export class OnErrorNextSubscriber<T>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnErrorNext.OnErrorNextSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableOnErrorReturn<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnErrorReturn<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, valueSupplier: io.reactivex.functions.Function<any,any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableOnErrorReturn {
						export class OnErrorReturnSubscriber<T>  extends io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableOnErrorReturn.OnErrorReturnSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowablePublish<T>  extends io.reactivex.flowables.ConnectableFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublish<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public connect(): io.reactivex.disposables.Disposable;
						public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public publishBufferSize(): number;
						public static create(source: io.reactivex.Flowable<any>, bufferSize: number): io.reactivex.flowables.ConnectableFlowable<any>;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public publishSource(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowablePublish {
						export class FlowablePublisher<T>  extends org.reactivestreams.Publisher<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublish.FlowablePublisher<any>>;
							public subscribe(child: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						}
						export class InnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublish.InnerSubscriber<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
						export class PublishSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublish.PublishSubscriber<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowablePublishAlt<T>  extends io.reactivex.flowables.ConnectableFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishAlt<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public connect(): io.reactivex.disposables.Disposable;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: org.reactivestreams.Publisher<any>, bufferSize: number);
						public resetIf(param0: io.reactivex.disposables.Disposable): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public publishBufferSize(): number;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public resetIf(connection: io.reactivex.disposables.Disposable): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowablePublishAlt {
						export class InnerSubscription<T>  extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishAlt.InnerSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public isCancelled(): boolean;
							public request(param0: number): void;
						}
						export class PublishConnection<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishAlt.PublishConnection<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowablePublishClassic<T>  extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishClassic<any>>;
						/**
						 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowablePublishClassic<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
						 */
						public constructor(implementation: {
							publishSource(): org.reactivestreams.Publisher<T>;
							publishBufferSize(): number;
						});
						public constructor();
						public publishBufferSize(): number;
						public publishSource(): org.reactivestreams.Publisher<T>;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowablePublishMulticast<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishMulticast<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, selector: io.reactivex.functions.Function<any,any>, prefetch: number, delayError: boolean);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowablePublishMulticast {
						export class MulticastProcessor<T>  extends io.reactivex.Flowable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishMulticast.MulticastProcessor<any>>;
							public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public isDisposed(): boolean;
							public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						}
						export class MulticastSubscription<T>  extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishMulticast.MulticastSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public isCancelled(): boolean;
							public request(param0: number): void;
						}
						export class OutputCanceller<R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowablePublishMulticast.OutputCanceller<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: R): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRange extends io.reactivex.Flowable<java.lang.Integer> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRange>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(start: number, count: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRange {
						export abstract class BaseRangeSubscription extends io.reactivex.internal.subscriptions.BasicQueueSubscription<java.lang.Integer> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRange.BaseRangeSubscription>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public clear(): void;
							public isEmpty(): boolean;
							public poll(): java.lang.Integer;
						}
						export class RangeConditionalSubscription extends io.reactivex.internal.operators.flowable.FlowableRange.BaseRangeSubscription {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRange.RangeConditionalSubscription>;
						}
						export class RangeSubscription extends io.reactivex.internal.operators.flowable.FlowableRange.BaseRangeSubscription {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRange.RangeSubscription>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRangeLong extends io.reactivex.Flowable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRangeLong>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(start: number, param1: number);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRangeLong {
						export abstract class BaseRangeSubscription extends io.reactivex.internal.subscriptions.BasicQueueSubscription<java.lang.Long> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRangeLong.BaseRangeSubscription>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public clear(): void;
							public poll(): java.lang.Long;
							public isEmpty(): boolean;
						}
						export class RangeConditionalSubscription extends io.reactivex.internal.operators.flowable.FlowableRangeLong.BaseRangeSubscription {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRangeLong.RangeConditionalSubscription>;
						}
						export class RangeSubscription extends io.reactivex.internal.operators.flowable.FlowableRangeLong.BaseRangeSubscription {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRangeLong.RangeSubscription>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableReduce<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduce<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableReduce {
						export class ReduceSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduce.ReduceSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableReduceMaybe<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduceMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableReduceMaybe {
						export class ReduceSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduceMaybe.ReduceSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableReduceSeedSingle<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, seed: any, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module FlowableReduceSeedSingle {
						export class ReduceSeedObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle.ReduceSeedObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(value: T): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableReduceWithSingle<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReduceWithSingle<any,any>>;
						public constructor(source: org.reactivestreams.Publisher<any>, seedSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRefCount<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRefCount<any>>;
						public constructor(source: io.reactivex.flowables.ConnectableFlowable<any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.flowables.ConnectableFlowable<any>, n: number, timeout: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRefCount {
						export class RefConnection extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRefCount.RefConnection>;
							public accept(t: io.reactivex.disposables.Disposable): void;
							public accept(param0: any): void;
							public run(): void;
						}
						export class RefCountSubscriber<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRefCount.RefCountSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRepeat<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeat<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, count: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRepeat {
						export class RepeatSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeat.RepeatSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRepeatUntil<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatUntil<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, until: io.reactivex.functions.BooleanSupplier);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRepeatUntil {
						export class RepeatSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatUntil.RepeatSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRepeatWhen<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatWhen<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, handler: io.reactivex.functions.Function<any,any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRepeatWhen {
						export class RepeatWhenSubscriber<T>  extends io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenSourceSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatWhen.RepeatWhenSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class WhenReceiver<T, U>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenReceiver<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export abstract class WhenSourceSubscriber<T, U>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenSourceSubscriber<any,any>>;
							public downstream: org.reactivestreams.Subscriber<any>;
							public processor: io.reactivex.processors.FlowableProcessor<any>;
							public receiver: org.reactivestreams.Subscription;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public again(signal: any): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableReplay<T>  extends io.reactivex.flowables.ConnectableFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public resetIf(param0: io.reactivex.disposables.Disposable): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public static multicastSelector(connectableFactory: java.util.concurrent.Callable<any>, selector: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
						public static createFrom(source: io.reactivex.Flowable<any>): io.reactivex.flowables.ConnectableFlowable<any>;
						public static create(source: io.reactivex.Flowable<any>, bufferSize: number): io.reactivex.flowables.ConnectableFlowable<any>;
						public source(): org.reactivestreams.Publisher<any>;
						public static create(source: io.reactivex.Flowable<any>, maxAge: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public static create(source: io.reactivex.Flowable<any>, maxAge: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.flowables.ConnectableFlowable<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public connect(): io.reactivex.disposables.Disposable;
						public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
						public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean, bufferSize: number): io.reactivex.Flowable<any>;
						public static observeOn(cf: io.reactivex.flowables.ConnectableFlowable<any>, scheduler: io.reactivex.Scheduler): io.reactivex.flowables.ConnectableFlowable<any>;
						public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean): io.reactivex.Flowable<any>;
						public subscribe(): io.reactivex.disposables.Disposable;
						public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Flowable<any>;
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public resetIf(connectionObject: io.reactivex.disposables.Disposable): void;
					}
					export module FlowableReplay {
						export class BoundedReplayBuffer<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.flowable.FlowableReplay.Node> implements io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.BoundedReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
							public error(param0: java.lang.Throwable): void;
							public next(param0: any): void;
							public next(value: any): void;
							public complete(): void;
							public replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
						}
						export class ConnectableFlowableReplay<T>  extends io.reactivex.flowables.ConnectableFlowable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ConnectableFlowableReplay<any>>;
							public connect(connection: io.reactivex.functions.Consumer<any>): void;
							public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public connect(): io.reactivex.disposables.Disposable;
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
							public connect(param0: io.reactivex.functions.Consumer<any>): void;
						}
						export class DefaultUnboundedFactory extends java.util.concurrent.Callable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.DefaultUnboundedFactory>;
							public call(): any;
						}
						export class InnerSubscription<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public produced(n: number): number;
							public dispose(): void;
							public isDisposed(): boolean;
							public request(param0: number): void;
						}
						export class MulticastFlowable<R, U>  extends io.reactivex.Flowable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.MulticastFlowable<any,any>>;
							public subscribeActual(child: org.reactivestreams.Subscriber<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						}
						export module MulticastFlowable {
							export class DisposableConsumer extends io.reactivex.functions.Consumer<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.MulticastFlowable.DisposableConsumer>;
								public accept(param0: any): void;
								public accept(r: io.reactivex.disposables.Disposable): void;
							}
						}
						export class Node extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.flowable.FlowableReplay.Node> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.Node>;
						}
						export class ReplayBuffer<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableReplay$ReplayBuffer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								next(param0: T): void;
								error(param0: java.lang.Throwable): void;
								complete(): void;
								replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<T>): void;
							});
							public constructor();
							public error(param0: java.lang.Throwable): void;
							public complete(): void;
							public next(param0: T): void;
							public replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<T>): void;
						}
						export class ReplayBufferTask<T>  extends java.util.concurrent.Callable<io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBufferTask<any>>;
							public call(): io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>;
							public call(): any;
						}
						export class ReplayPublisher<T>  extends org.reactivestreams.Publisher<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ReplayPublisher<any>>;
							public subscribe(child: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						}
						export class ReplaySubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ReplaySubscriber<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(p: org.reactivestreams.Subscription): void;
							public onError(e: java.lang.Throwable): void;
						}
						export class ScheduledReplayBufferTask<T>  extends java.util.concurrent.Callable<io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.ScheduledReplayBufferTask<any>>;
							public call(): io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>;
							public call(): any;
						}
						export class SizeAndTimeBoundReplayBuffer<T>  extends io.reactivex.internal.operators.flowable.FlowableReplay.BoundedReplayBuffer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.SizeAndTimeBoundReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public error(param0: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
							public next(param0: any): void;
							public next(value: any): void;
							public complete(): void;
							public replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
						}
						export class SizeBoundReplayBuffer<T>  extends io.reactivex.internal.operators.flowable.FlowableReplay.BoundedReplayBuffer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.SizeBoundReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public error(param0: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
							public next(param0: any): void;
							public next(value: any): void;
							public complete(): void;
							public replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
						}
						export class UnboundedReplayBuffer<T>  extends java.util.ArrayList<any> implements io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableReplay.UnboundedReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public subList(param0: number, param1: number): java.util.List<any>;
							public toArray(): any[];
							public add(index: number, element: any): void;
							public lastIndexOf(o: any): number;
							public next(value: any): void;
							public stream(): java.util.stream.Stream<any>;
							public listIterator(index: number): java.util.ListIterator<any>;
							public toArray(a: any[]): any[];
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public get(index: number): any;
							public add(param0: number, param1: any): void;
							public toArray(param0: any[]): any[];
							public indexOf(o: any): number;
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public get(param0: number): any;
							public indexOf(param0: any): number;
							public set(index: number, element: any): any;
							public replay(output: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
							public error(param0: java.lang.Throwable): void;
							public addAll(param0: number, param1: java.util.Collection<any>): boolean;
							public removeAll(c: java.util.Collection<any>): boolean;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public remove(index: number): any;
							public parallelStream(): java.util.stream.Stream<any>;
							public contains(param0: any): boolean;
							public remove(param0: number): any;
							public size(): number;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public retainAll(c: java.util.Collection<any>): boolean;
							public add(e: any): boolean;
							public replay(param0: io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription<any>): void;
							public listIterator(): java.util.ListIterator<any>;
							public replaceAll(operator: any /* any*/): void;
							public set(param0: number, param1: any): any;
							public add(param0: any): boolean;
							public listIterator(param0: number): java.util.ListIterator<any>;
							public next(param0: any): void;
							public equals(o: any): boolean;
							public subList(fromIndex: number, toIndex: number): java.util.List<any>;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public lastIndexOf(param0: any): number;
							public clear(): void;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public addAll(index: number, c: java.util.Collection<any>): boolean;
							public sort(c: java.util.Comparator<any>): void;
							public removeIf(filter: any /* any*/): boolean;
							public complete(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRetryBiPredicate<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.BiPredicate<any,any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRetryBiPredicate {
						export class RetryBiSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate.RetryBiSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRetryPredicate<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryPredicate<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, count: number, param2: io.reactivex.functions.Predicate<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRetryPredicate {
						export class RetrySubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryPredicate.RetrySubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableRetryWhen<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryWhen<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, handler: io.reactivex.functions.Function<any,any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableRetryWhen {
						export class RetryWhenSubscriber<T>  extends io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenSourceSubscriber<any,java.lang.Throwable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableRetryWhen.RetryWhenSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSamplePublisher<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSamplePublisher<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, other: org.reactivestreams.Publisher<any>, emitLast: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSamplePublisher {
						export class SampleMainEmitLast<T>  extends io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplePublisherSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SampleMainEmitLast<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class SampleMainNoLast<T>  extends io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplePublisherSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SampleMainNoLast<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export abstract class SamplePublisherSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplePublisherSubscriber<any>>;
							public cancel(): void;
							public error(e: java.lang.Throwable): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public complete(): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export class SamplerSubscriber<T>  extends io.reactivex.FlowableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplerSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSampleTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSampleTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, period: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSampleTimed {
						export class SampleTimedEmitLast<T>  extends io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedEmitLast<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public run(): void;
						}
						export class SampleTimedNoLast<T>  extends io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedNoLast<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public run(): void;
						}
						export abstract class SampleTimedSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableScalarXMap extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScalarXMap>;
						public static scalarXMap(value: any, mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Flowable<any>;
						public static tryScalarXMapSubscribe(source: org.reactivestreams.Publisher, subscriber: org.reactivestreams.Subscriber, mapper: io.reactivex.functions.Function<any,any>): boolean;
					}
					export module FlowableScalarXMap {
						export class ScalarXMapFlowable<T, R>  extends io.reactivex.Flowable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScalarXMap.ScalarXMapFlowable<any,any>>;
							public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(s: org.reactivestreams.Subscriber<any>): void;
							public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
							public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableScan<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScan<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableScan {
						export class ScanSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScan.ScanSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableScanSeed<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScanSeed<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, seedSupplier: java.util.concurrent.Callable<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableScanSeed {
						export class ScanSeedSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableScanSeed.ScanSeedSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSequenceEqual<T>  extends io.reactivex.Flowable<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqual<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(first: org.reactivestreams.Publisher<any>, second: org.reactivestreams.Publisher<any>, comparer: io.reactivex.functions.BiPredicate<any,any>, prefetch: number);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSequenceEqual {
						export class EqualCoordinator<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<java.lang.Boolean> implements io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualCoordinatorHelper  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualCoordinator<any>>;
							public cancel(): void;
							public drain(): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerError(t: java.lang.Throwable): void;
						}
						export class EqualCoordinatorHelper extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualCoordinatorHelper>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableSequenceEqual$EqualCoordinatorHelper interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								drain(): void;
								innerError(param0: java.lang.Throwable): void;
							});
							public constructor();
							public drain(): void;
							public innerError(param0: java.lang.Throwable): void;
						}
						export class EqualSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSequenceEqualSingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToFlowable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<java.lang.Boolean>;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(first: org.reactivestreams.Publisher<any>, second: org.reactivestreams.Publisher<any>, comparer: io.reactivex.functions.BiPredicate<any,any>, prefetch: number);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableSequenceEqualSingle {
						export class EqualCoordinator<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle.EqualCoordinator<any>>;
							public drain(): void;
							public dispose(): void;
							public innerError(param0: java.lang.Throwable): void;
							public isDisposed(): boolean;
							public innerError(t: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSerialized<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSerialized<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSingle<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingle<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, defaultValue: any, failOnEmpty: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSingle {
						export class SingleElementSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingle.SingleElementSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSingleMaybe<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingleMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>);
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableSingleMaybe {
						export class SingleElementSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingleMaybe.SingleElementSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSingleSingle<T>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingleSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, defaultValue: any);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableSingleSingle {
						export class SingleElementSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSingleSingle.SingleElementSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSkip<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkip<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, n: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSkip {
						export class SkipSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkip.SkipSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSkipLast<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipLast<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, skip: number);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSkipLast {
						export class SkipLastSubscriber<T>  extends java.util.ArrayDeque<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipLast.SkipLastSubscriber<any>>;
							public toArray(): any[];
							public removeFirstOccurrence(o: any): boolean;
							public removeLast(): any;
							public element(): any;
							public poll(): any;
							public addFirst(e: any): void;
							public stream(): java.util.stream.Stream<any>;
							public toArray(a: any[]): any[];
							public remove(): any;
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeFirstOccurrence(param0: any): boolean;
							public removeLastOccurrence(o: any): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public toArray(param0: any[]): any[];
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public offer(e: any): boolean;
							public offerFirst(param0: any): boolean;
							public removeLastOccurrence(param0: any): boolean;
							public onError(param0: java.lang.Throwable): void;
							public removeAll(c: java.util.Collection<any>): boolean;
							public peekFirst(): any;
							public descendingIterator(): java.util.Iterator<any>;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public parallelStream(): java.util.stream.Stream<any>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public contains(param0: any): boolean;
							public addLast(e: any): void;
							public offerLast(e: any): boolean;
							public size(): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public pollFirst(): any;
							public retainAll(c: java.util.Collection<any>): boolean;
							public push(e: any): void;
							public equals(obj: any): boolean;
							public add(e: any): boolean;
							public request(param0: number): void;
							public peek(): any;
							public onNext(t: any): void;
							public add(param0: any): boolean;
							public offerLast(param0: any): boolean;
							public offerFirst(e: any): boolean;
							public getFirst(): any;
							public getLast(): any;
							public cancel(): void;
							public removeFirst(): any;
							public push(param0: any): void;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public clear(): void;
							public offer(param0: any): boolean;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public pollLast(): any;
							public removeIf(filter: any /* any*/): boolean;
							public addFirst(param0: any): void;
							public addLast(param0: any): void;
							public pop(): any;
							public peekLast(): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSkipLastTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipLastTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, bufferSize: boolean);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSkipLastTimed {
						export class SkipLastTimedSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipLastTimed.SkipLastTimedSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSkipUntil<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipUntil<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribeActual(child: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSkipUntil {
						export class SkipUntilMainSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipUntil.SkipUntilMainSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public tryOnNext(param0: any): boolean;
							public request(param0: number): void;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export module SkipUntilMainSubscriber {
							export class OtherSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipUntil.SkipUntilMainSubscriber.OtherSubscriber>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSkipWhile<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipWhile<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSkipWhile {
						export class SkipWhileSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSkipWhile.SkipWhileSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSubscribeOn<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSubscribeOn<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, scheduler: io.reactivex.Scheduler, nonScheduledRequests: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSubscribeOn {
						export class SubscribeOnSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<java.lang.Thread> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSubscribeOn.SubscribeOnSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
						export module SubscribeOnSubscriber {
							export class Request extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSubscribeOn.SubscribeOnSubscriber.Request>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSwitchIfEmpty<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSwitchIfEmpty {
						export class SwitchIfEmptySubscriber<T>  extends io.reactivex.FlowableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty.SwitchIfEmptySubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableSwitchMap<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSwitchMap<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, bufferSize: number, delayErrors: boolean);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSwitchMap {
						export class SwitchMapInnerSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSwitchMap.SwitchMapInnerSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
						export class SwitchMapSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableSwitchMap.SwitchMapSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTake<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTake<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, limit: number);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTake {
						export class TakeSubscriber<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTake.TakeSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeLast<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLast<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, count: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeLast {
						export class TakeLastSubscriber<T>  extends java.util.ArrayDeque<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLast.TakeLastSubscriber<any>>;
							public toArray(): any[];
							public removeFirstOccurrence(o: any): boolean;
							public removeLast(): any;
							public element(): any;
							public poll(): any;
							public addFirst(e: any): void;
							public stream(): java.util.stream.Stream<any>;
							public toArray(a: any[]): any[];
							public remove(): any;
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeFirstOccurrence(param0: any): boolean;
							public removeLastOccurrence(o: any): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public toArray(param0: any[]): any[];
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public offer(e: any): boolean;
							public offerFirst(param0: any): boolean;
							public removeLastOccurrence(param0: any): boolean;
							public onError(param0: java.lang.Throwable): void;
							public removeAll(c: java.util.Collection<any>): boolean;
							public peekFirst(): any;
							public descendingIterator(): java.util.Iterator<any>;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public parallelStream(): java.util.stream.Stream<any>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public contains(param0: any): boolean;
							public addLast(e: any): void;
							public offerLast(e: any): boolean;
							public size(): number;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public pollFirst(): any;
							public retainAll(c: java.util.Collection<any>): boolean;
							public push(e: any): void;
							public equals(obj: any): boolean;
							public add(e: any): boolean;
							public request(param0: number): void;
							public peek(): any;
							public onNext(t: any): void;
							public add(param0: any): boolean;
							public offerLast(param0: any): boolean;
							public offerFirst(e: any): boolean;
							public getFirst(): any;
							public getLast(): any;
							public cancel(): void;
							public removeFirst(): any;
							public push(param0: any): void;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public clear(): void;
							public offer(param0: any): boolean;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public pollLast(): any;
							public removeIf(filter: any /* any*/): boolean;
							public addFirst(param0: any): void;
							public addLast(param0: any): void;
							public pop(): any;
							public peekLast(): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeLastOne<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLastOne<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeLastOne {
						export class TakeLastOneSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLastOne.TakeLastOneSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeLastTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLastTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, count: number, param2: number, time: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: number, scheduler: boolean);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeLastTimed {
						export class TakeLastTimedSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeLastTimed.TakeLastTimedSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakePublisher<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakePublisher<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: org.reactivestreams.Publisher<any>, limit: number);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeUntil<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeUntil<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribeActual(child: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeUntil {
						export class TakeUntilMainSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeUntil.TakeUntilMainSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module TakeUntilMainSubscriber {
							export class OtherSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeUntil.TakeUntilMainSubscriber.OtherSubscriber>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeUntilPredicate<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeUntilPredicate {
						export class InnerSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate.InnerSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTakeWhile<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeWhile<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTakeWhile {
						export class TakeWhileSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTakeWhile.TakeWhileSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableThrottleFirstTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableThrottleFirstTimed {
						export class DebounceTimedSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed.DebounceTimedSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableThrottleLatest<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableThrottleLatest<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableThrottleLatest {
						export class ThrottleLatestSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableThrottleLatest.ThrottleLatestSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTimeInterval<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.schedulers.Timed<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeInterval<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Flowable<any>, unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTimeInterval {
						export class TimeIntervalSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeInterval.TimeIntervalSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTimeout<T, U, V>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeout<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, firstTimeoutIndicator: org.reactivestreams.Publisher<any>, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: org.reactivestreams.Publisher<any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTimeout {
						export class TimeoutConsumer extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutConsumer>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class TimeoutFallbackSubscriber<T>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutFallbackSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onTimeout(idx: number): void;
							public request(param0: number): void;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onTimeoutError(idx: number, param1: java.lang.Throwable): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
						}
						export class TimeoutSelectorSupport extends java.lang.Object implements io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSupport {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutSelectorSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableTimeout$TimeoutSelectorSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								onTimeoutError(param0: number, param1: java.lang.Throwable): void;
								onTimeout(param0: number): void;
							});
							public constructor();
							public onTimeout(param0: number): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
						}
						export class TimeoutSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onTimeout(idx: number): void;
							public request(param0: number): void;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onTimeoutError(idx: number, param1: java.lang.Throwable): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTimeoutTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: org.reactivestreams.Publisher<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTimeoutTimed {
						export class FallbackSubscriber<T>  extends io.reactivex.FlowableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.FallbackSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
						export class TimeoutFallbackSubscriber<T>  extends io.reactivex.internal.subscriptions.SubscriptionArbiter {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutFallbackSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onTimeout(idx: number): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
						}
						export class TimeoutSubscriber<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onTimeout(idx: number): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
						}
						export class TimeoutSupport extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.flowable.FlowableTimeoutTimed$TimeoutSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								onTimeout(param0: number): void;
							});
							public constructor();
							public onTimeout(param0: number): void;
						}
						export class TimeoutTask extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutTask>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableTimer extends io.reactivex.Flowable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimer>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableTimer {
						export class TimerSubscriber extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableTimer.TimerSubscriber>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableToList<T, U>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableToList<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableToList {
						export class ToListSubscriber<T, U>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableToList.ToListSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableToListSingle<T, U>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToFlowable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableToListSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>);
						public fuseToFlowable(): io.reactivex.Flowable<any>;
					}
					export module FlowableToListSingle {
						export class ToListSubscriber<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableToListSingle.ToListSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableUnsubscribeOn<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn<any>>;
						public constructor(source: io.reactivex.Flowable<any>, scheduler: io.reactivex.Scheduler);
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableUnsubscribeOn {
						export class UnsubscribeSubscriber<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn.UnsubscribeSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module UnsubscribeSubscriber {
							export class Cancellation extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn.UnsubscribeSubscriber.Cancellation>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableUsing<T, D>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableUsing<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableUsing {
						export class UsingSubscriber<T, D>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableUsing.UsingSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWindow<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Flowable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindow<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, size: number, param2: number, skip: number);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWindow {
						export class WindowExactSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindow.WindowExactSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
						export class WindowOverlapSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindow.WindowOverlapSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
						export class WindowSkipSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindow.WindowSkipSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWindowBoundary<T, B>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Flowable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundary<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, other: org.reactivestreams.Publisher<any>, capacityHint: number);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWindowBoundary {
						export class WindowBoundaryInnerSubscriber<T, B>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundary.WindowBoundaryInnerSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class WindowBoundaryMainSubscriber<T, B>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundary.WindowBoundaryMainSubscriber<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWindowBoundarySelector<T, B, V>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Flowable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, open: org.reactivestreams.Publisher<any>, close: io.reactivex.functions.Function<any,any>, bufferSize: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWindowBoundarySelector {
						export class OperatorWindowBoundaryCloseSubscriber<T, V>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.OperatorWindowBoundaryCloseSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class OperatorWindowBoundaryOpenSubscriber<T, B>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.OperatorWindowBoundaryOpenSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class WindowBoundaryMainSubscriber<T, B, V>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,io.reactivex.Flowable<any>> implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.WindowBoundaryMainSubscriber<any,any,any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
						}
						export class WindowOperation<T, B>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.WindowOperation<any,any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWindowBoundarySupplier<T, B>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Flowable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(subscriber: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, other: java.util.concurrent.Callable<any>, capacityHint: number);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWindowBoundarySupplier {
						export class WindowBoundaryInnerSubscriber<T, B>  extends io.reactivex.subscribers.DisposableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier.WindowBoundaryInnerSubscriber<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export class WindowBoundaryMainSubscriber<T, B>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier.WindowBoundaryMainSubscriber<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWindowTimed<T>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,io.reactivex.Flowable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public constructor(source: io.reactivex.Flowable<any>, timespan: number, param2: number, timeskip: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: number, scheduler: number, maxSize: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWindowTimed {
						export class WindowExactBoundedSubscriber<T>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,io.reactivex.Flowable<any>> implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowExactBoundedSubscriber<any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public disposeTimer(): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
						}
						export module WindowExactBoundedSubscriber {
							export class ConsumerIndexHolder extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowExactBoundedSubscriber.ConsumerIndexHolder>;
								public run(): void;
							}
						}
						export class WindowExactUnboundedSubscriber<T>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,io.reactivex.Flowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowExactUnboundedSubscriber<any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
							public run(): void;
						}
						export class WindowSkipSubscriber<T>  extends io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,io.reactivex.Flowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowSkipSubscriber<any>>;
							public cancel(): void;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public produced(param0: number): number;
							public produced(n: number): number;
							public request(param0: number): void;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
							public enter(): boolean;
							public requested(): number;
							public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public requested(n: number): void;
							public run(): void;
						}
						export module WindowSkipSubscriber {
							export class Completion extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowSkipSubscriber.Completion>;
								public run(): void;
							}
							export class SubjectWork<T>  extends java.lang.Object {
								public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowSkipSubscriber.SubjectWork<any>>;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWithLatestFrom<T, U, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFrom<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, other: org.reactivestreams.Publisher<any>);
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWithLatestFrom {
						export class FlowableWithLatestSubscriber extends io.reactivex.FlowableSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFrom.FlowableWithLatestSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
						export class WithLatestFromSubscriber<T, U, R>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFrom.WithLatestFromSubscriber<any,any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public otherError(e: java.lang.Throwable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public setOther(o: org.reactivestreams.Subscription): boolean;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableWithLatestFromMany<T, R>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany<any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, otherArray: org.reactivestreams.Publisher<any>[], combiner: io.reactivex.functions.Function<any,any>);
						public constructor(source: io.reactivex.Flowable<any>, otherIterable: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableWithLatestFromMany {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
						export class WithLatestFromSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany.WithLatestFromSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public tryOnNext(param0: any): boolean;
							public request(param0: number): void;
							public tryOnNext(t: any): boolean;
							public onNext(t: any): void;
						}
						export class WithLatestInnerSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany.WithLatestInnerSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableZip<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableZip<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(sources: org.reactivestreams.Publisher<any>[], sourcesIterable: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableZip {
						export class ZipCoordinator<T, R>  extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableZip.ZipCoordinator<any,any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
						export class ZipSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableZip.ZipSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module flowable {
					export class FlowableZipIterable<T, U, V>  extends io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableZipIterable<any,any,any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, other: java.lang.Iterable<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): org.reactivestreams.Publisher<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableZipIterable {
						export class ZipIterableSubscriber<T, U, V>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.flowable.FlowableZipIterable.ZipIterableSubscriber<any,any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export abstract class AbstractMaybeWithUpstream<T, R>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any>>;
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeAmb<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeAmb<any>>;
						public constructor(sources: io.reactivex.MaybeSource<any>[], sourcesIterable: java.lang.Iterable<any>);
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeAmb {
						export class AmbMaybeObserver<T>  extends io.reactivex.MaybeObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeAmb.AmbMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeCache<T>  extends io.reactivex.Maybe<any> implements io.reactivex.MaybeObserver<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCache<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public onSuccess(value: any): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public onError(param0: java.lang.Throwable): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public onSuccess(param0: any): void;
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public onError(e: java.lang.Throwable): void;
						public onComplete(): void;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
					}
					export module MaybeCache {
						export class CacheDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.maybe.MaybeCache<any>> implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCache.CacheDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeCallbackObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCallbackObserver<any>>;
						public constructor();
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public isDisposed(): boolean;
						public onSuccess(value: any): void;
						public constructor(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action);
						public onError(param0: java.lang.Throwable): void;
						public constructor(initialValue: any);
						public dispose(): void;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public hasCustomOnError(): boolean;
						public onSuccess(param0: any): void;
						public onError(e: java.lang.Throwable): void;
						public onComplete(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeConcatArray<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatArray<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.MaybeSource<any>[]);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeConcatArray {
						export class ConcatMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatArray.ConcatMaybeObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeConcatArrayDelayError<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.MaybeSource<any>[]);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeConcatArrayDelayError {
						export class ConcatMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError.ConcatMaybeObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeConcatIterable<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatIterable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public constructor(sources: java.lang.Iterable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeConcatIterable {
						export class ConcatMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeConcatIterable.ConcatMaybeObserver<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeContains<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeContains<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, value: any);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeContains {
						export class ContainsMaybeObserver extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeContains.ContainsMaybeObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeCount<T>  extends io.reactivex.Single<java.lang.Long> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCount<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeCount {
						export class CountMaybeObserver extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCount.CountMaybeObserver>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeCreate<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCreate<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeOnSubscribe<any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeCreate {
						export class Emitter<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeCreate.Emitter<any>>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public dispose(): void;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public isDisposed(): boolean;
							public toString(): string;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDefer<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDefer<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(maybeSupplier: java.util.concurrent.Callable<any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDelay<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelay<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, delay: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDelay {
						export class DelayMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelay.DelayMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDelayOtherPublisher<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDelayOtherPublisher {
						export class DelayMaybeObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher.DelayMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class OtherSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher.OtherSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDelaySubscriptionOtherPublisher<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDelaySubscriptionOtherPublisher {
						export class DelayMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher.DelayMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class OtherSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher.OtherSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDelayWithCompletable<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, other: io.reactivex.CompletableSource);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeDelayWithCompletable {
						export class DelayWithMainObserver<T>  extends io.reactivex.MaybeObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable.DelayWithMainObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable.OtherObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDetach<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDetach<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDetach {
						export class DetachMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDetach.DetachMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDoAfterSuccess<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, onAfterSuccess: io.reactivex.functions.Consumer<any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDoAfterSuccess {
						export class DoAfterObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess.DoAfterObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(t: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDoFinally<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoFinally<any>>;
						public constructor(source: io.reactivex.MaybeSource<any>, onFinally: io.reactivex.functions.Action);
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeDoFinally {
						export class DoFinallyObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoFinally.DoFinallyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(t: any): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDoOnEvent<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoOnEvent<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public constructor(source: io.reactivex.MaybeSource<any>, onEvent: io.reactivex.functions.BiConsumer<any,any>);
					}
					export module MaybeDoOnEvent {
						export class DoOnEventMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoOnEvent.DoOnEventMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeDoOnTerminate<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoOnTerminate<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, onTerminate: io.reactivex.functions.Action);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeDoOnTerminate {
						export class DoOnTerminate extends io.reactivex.MaybeObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeDoOnTerminate.DoOnTerminate>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeEmpty extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeEmpty>;
						public static INSTANCE: io.reactivex.internal.operators.maybe.MaybeEmpty;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeEqualSingle<T>  extends io.reactivex.Single<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeEqualSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source1: io.reactivex.MaybeSource<any>, source2: io.reactivex.MaybeSource<any>, isEqual: io.reactivex.functions.BiPredicate<any,any>);
					}
					export module MaybeEqualSingle {
						export class EqualCoordinator<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeEqualSingle.EqualCoordinator<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class EqualObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeEqualSingle.EqualObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeError<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeError<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(error: java.lang.Throwable);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeErrorCallable<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeErrorCallable<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(errorSupplier: java.util.concurrent.Callable<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFilter<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFilter<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeFilter {
						export class FilterMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFilter.FilterMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFilterSingle<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFilterSingle<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeFilterSingle {
						export class FilterMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFilterSingle.FilterMaybeObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapBiSelector<T, U, R>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector<any,any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeFlatMapBiSelector {
						export class FlatMapBiMainObserver<T, U, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector.FlatMapBiMainObserver<any,any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module FlatMapBiMainObserver {
							export class InnerObserver<T, U, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector.FlatMapBiMainObserver.InnerObserver<any,any,any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module MaybeFlatMapCompletable {
						export class FlatMapCompletableObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable.FlatMapCompletableObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapIterableFlowable<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeFlatMapIterableFlowable {
						export class FlatMapIterableObserver<T, R>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable.FlatMapIterableObserver<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public request(n: number): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public poll(): any;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapIterableObservable<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module MaybeFlatMapIterableObservable {
						export class FlatMapIterableObserver<T, R>  extends io.reactivex.internal.observers.BasicQueueDisposable<any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable.FlatMapIterableObserver<any,any>>;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapNotification<T, R>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapNotification<any,any>>;
						public constructor(source: io.reactivex.MaybeSource<any>, onSuccessMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>);
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeFlatMapNotification {
						export class FlatMapMaybeObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapNotification.FlatMapMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module FlatMapMaybeObserver {
							export class InnerObserver extends io.reactivex.MaybeObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapNotification.FlatMapMaybeObserver.InnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapSingle<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingle<any,any>>;
						public constructor();
						public subscribeActual(downstream: io.reactivex.SingleObserver<any>): void;
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeFlatMapSingle {
						export class FlatMapMaybeObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingle.FlatMapMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class FlatMapSingleObserver<R>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingle.FlatMapSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatMapSingleElement<T, R>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribeActual(downstream: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeFlatMapSingleElement {
						export class FlatMapMaybeObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement.FlatMapMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class FlatMapSingleObserver<R>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement.FlatMapSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFlatten<T, R>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatten<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeFlatten {
						export class FlatMapMaybeObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatten.FlatMapMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module FlatMapMaybeObserver {
							export class InnerObserver extends io.reactivex.MaybeObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFlatten.FlatMapMaybeObserver.InnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromAction<T>  extends io.reactivex.Maybe<any> implements java.util.concurrent.Callable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromAction<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(action: io.reactivex.functions.Action);
						public call(): any;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromCallable<T>  extends io.reactivex.Maybe<any> implements java.util.concurrent.Callable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromCallable<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(callable: java.util.concurrent.Callable<any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromCompletable<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.HasUpstreamCompletableSource  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromCompletable<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.CompletableSource);
						public source(): io.reactivex.CompletableSource;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeFromCompletable {
						export class FromCompletableObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromCompletable.FromCompletableObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromFuture<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromFuture<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public constructor(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromRunnable<T>  extends io.reactivex.Maybe<any> implements java.util.concurrent.Callable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromRunnable<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(runnable: java.lang.Runnable);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeFromSingle<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.HasUpstreamSingleSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromSingle<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.SingleSource<any>;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeFromSingle {
						export class FromSingleObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeFromSingle.FromSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeHide<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeHide<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeHide {
						export class HideMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeHide.HideMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeIgnoreElement<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIgnoreElement<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeIgnoreElement {
						export class IgnoreMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIgnoreElement.IgnoreMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeIgnoreElementCompletable<T>  extends io.reactivex.Completable implements io.reactivex.internal.fuseable.FuseToMaybe<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public fuseToMaybe(): io.reactivex.Maybe<any>;
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module MaybeIgnoreElementCompletable {
						export class IgnoreMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable.IgnoreMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeIsEmpty<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIsEmpty<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeIsEmpty {
						export class IsEmptyMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIsEmpty.IsEmptyMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeIsEmptySingle<T>  extends io.reactivex.Single<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIsEmptySingle<any>>;
						public constructor();
						public fuseToMaybe(): io.reactivex.Maybe<any>;
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public fuseToMaybe(): io.reactivex.Maybe<java.lang.Boolean>;
					}
					export module MaybeIsEmptySingle {
						export class IsEmptyMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeIsEmptySingle.IsEmptyMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeJust<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeJust<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public call(): any;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(value: any);
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeLift<T, R>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeLift<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, operator: io.reactivex.MaybeOperator<any,any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeMap<T, R>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMap<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeMap {
						export class MapMaybeObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMap.MapMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeMaterialize<T>  extends io.reactivex.Single<io.reactivex.Notification<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMaterialize<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Maybe<any>);
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeMergeArray<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMergeArray<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.MaybeSource<any>[]);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeMergeArray {
						export class ClqSimpleQueue<T>  extends java.util.concurrent.ConcurrentLinkedQueue<any> implements io.reactivex.internal.operators.maybe.MaybeMergeArray.SimpleQueueWithConsumerIndex<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMergeArray.ClqSimpleQueue<any>>;
							public contains(param0: any): boolean;
							public size(): number;
							public offer(v1: any, v2: any): boolean;
							public toArray(): any[];
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public element(): any;
							public retainAll(c: java.util.Collection<any>): boolean;
							public equals(obj: any): boolean;
							public add(e: any): boolean;
							public poll(): any;
							public peek(): any;
							public stream(): java.util.stream.Stream<any>;
							public toArray(a: any[]): any[];
							public remove(): any;
							public addAll(param0: java.util.Collection<any>): boolean;
							public add(param0: any): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public toArray(param0: any[]): any[];
							public consumerIndex(): number;
							public retainAll(param0: java.util.Collection<any>): boolean;
							public offer(param0: any, param1: any): boolean;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public clear(): void;
							public offer(param0: any): boolean;
							public offer(e: any): boolean;
							public addAll(c: java.util.Collection<any>): boolean;
							public producerIndex(): number;
							public remove(o: any): boolean;
							public removeAll(c: java.util.Collection<any>): boolean;
							public drop(): void;
							public removeIf(filter: any /* any*/): boolean;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public parallelStream(): java.util.stream.Stream<any>;
						}
						export class MergeMaybeObserver<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMergeArray.MergeMaybeObserver<any>>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public poll(): any;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
						export class MpscFillOnceSimpleQueue<T>  extends java.util.concurrent.atomic.AtomicReferenceArray<any> implements io.reactivex.internal.operators.maybe.MaybeMergeArray.SimpleQueueWithConsumerIndex<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMergeArray.MpscFillOnceSimpleQueue<any>>;
							public offer(v1: any, v2: any): boolean;
							public offer(value: any): boolean;
							public offer(param0: any, param1: any): boolean;
							public drop(): void;
							public clear(): void;
							public offer(param0: any): boolean;
							public poll(): any;
							public consumerIndex(): number;
							public peek(): any;
							public isEmpty(): boolean;
							public producerIndex(): number;
						}
						export class SimpleQueueWithConsumerIndex<T>  extends io.reactivex.internal.fuseable.SimpleQueue<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeMergeArray.SimpleQueueWithConsumerIndex<any>>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.maybe.MaybeMergeArray$SimpleQueueWithConsumerIndex interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								poll(): any;
								peek(): any;
								drop(): void;
								consumerIndex(): number;
								producerIndex(): number;
								offer(param0: any): boolean;
								offer(param0: any, param1: any): boolean;
								poll(): any;
								isEmpty(): boolean;
								clear(): void;
							});
							public constructor();
							public offer(param0: any, param1: any): boolean;
							public drop(): void;
							public clear(): void;
							public offer(param0: any): boolean;
							public poll(): any;
							public consumerIndex(): number;
							public peek(): any;
							public isEmpty(): boolean;
							public producerIndex(): number;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeNever extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeNever>;
						public static INSTANCE: io.reactivex.internal.operators.maybe.MaybeNever;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeObserveOn<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeObserveOn<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeObserveOn {
						export class ObserveOnMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeObserveOn.ObserveOnMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeOnErrorComplete<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorComplete<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeOnErrorComplete {
						export class OnErrorCompleteMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorComplete.OnErrorCompleteMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeOnErrorNext<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorNext<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, resumeFunction: io.reactivex.functions.Function<any,any>, allowFatal: boolean);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeOnErrorNext {
						export class OnErrorNextMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorNext.OnErrorNextMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module OnErrorNextMaybeObserver {
							export class NextMaybeObserver<T>  extends io.reactivex.MaybeObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorNext.OnErrorNextMaybeObserver.NextMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeOnErrorReturn<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorReturn<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>, valueSupplier: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeOnErrorReturn {
						export class OnErrorReturnMaybeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeOnErrorReturn.OnErrorReturnMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybePeek<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybePeek<any>>;
						public constructor(source: io.reactivex.MaybeSource<any>, onSubscribeCall: io.reactivex.functions.Consumer<any>, onSuccessCall: io.reactivex.functions.Consumer<any>, onErrorCall: io.reactivex.functions.Consumer<any>, onCompleteCall: io.reactivex.functions.Action, onAfterTerminate: io.reactivex.functions.Action, onDispose: io.reactivex.functions.Action);
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybePeek {
						export class MaybePeekObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybePeek.MaybePeekObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeSubscribeOn<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSubscribeOn<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeSubscribeOn {
						export class SubscribeOnMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSubscribeOn.SubscribeOnMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class SubscribeTask<T>  extends java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSubscribeOn.SubscribeTask<any>>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeSwitchIfEmpty<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, other: io.reactivex.MaybeSource<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeSwitchIfEmpty {
						export class SwitchIfEmptyMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty.SwitchIfEmptyMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module SwitchIfEmptyMaybeObserver {
							export class OtherMaybeObserver<T>  extends io.reactivex.MaybeObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty.SwitchIfEmptyMaybeObserver.OtherMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeSwitchIfEmptySingle<T>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, other: io.reactivex.SingleSource<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeSwitchIfEmptySingle {
						export class SwitchIfEmptyMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle.SwitchIfEmptyMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module SwitchIfEmptyMaybeObserver {
							export class OtherSingleObserver<T>  extends io.reactivex.SingleObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle.SwitchIfEmptyMaybeObserver.OtherSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeTakeUntilMaybe<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, other: io.reactivex.MaybeSource<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeTakeUntilMaybe {
						export class TakeUntilMainMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe.TakeUntilMainMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module TakeUntilMainMaybeObserver {
							export class TakeUntilOtherMaybeObserver<U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe.TakeUntilMainMaybeObserver.TakeUntilOtherMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeTakeUntilPublisher<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeTakeUntilPublisher {
						export class TakeUntilMainMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher.TakeUntilMainMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module TakeUntilMainMaybeObserver {
							export class TakeUntilOtherMaybeObserver<U>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher.TakeUntilMainMaybeObserver.TakeUntilOtherMaybeObserver<any>>;
								public onSubscribe(s: org.reactivestreams.Subscription): void;
								public onSubscribe(param0: org.reactivestreams.Subscription): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onNext(value: any): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeTimeoutMaybe<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, other: io.reactivex.MaybeSource<any>, fallback: io.reactivex.MaybeSource<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeTimeoutMaybe {
						export class TimeoutFallbackMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutFallbackMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class TimeoutMainMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutMainMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public otherError(e: java.lang.Throwable): void;
							public otherComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class TimeoutOtherMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutOtherMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeTimeoutPublisher<T, U>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public constructor(source: io.reactivex.MaybeSource<any>, other: org.reactivestreams.Publisher<any>, fallback: io.reactivex.MaybeSource<any>);
					}
					export module MaybeTimeoutPublisher {
						export class TimeoutFallbackMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutFallbackMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class TimeoutMainMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutMainMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public otherError(e: java.lang.Throwable): void;
							public otherComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class TimeoutOtherMaybeObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutOtherMaybeObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(e: java.lang.Throwable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeTimer extends io.reactivex.Maybe<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimer>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeTimer {
						export class TimerDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeTimer.TimerDisposable>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeToFlowable<T>  extends io.reactivex.Flowable<any> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToFlowable<any>>;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeToFlowable {
						export class MaybeToFlowableSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToFlowable.MaybeToFlowableSubscriber<any>>;
							public cancel(): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeToObservable<T>  extends io.reactivex.Observable<any> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
						public static create(downstream: io.reactivex.Observer<any>): io.reactivex.MaybeObserver<any>;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeToObservable {
						export class MaybeToObservableObserver<T>  extends io.reactivex.internal.observers.DeferredScalarDisposable<any> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToObservable.MaybeToObservableObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeToPublisher extends io.reactivex.functions.Function<io.reactivex.MaybeSource<any>,org.reactivestreams.Publisher<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToPublisher>;
						public static INSTANCE: io.reactivex.internal.operators.maybe.MaybeToPublisher;
						public static valueOf(name: string): io.reactivex.internal.operators.maybe.MaybeToPublisher;
						public static instance(): io.reactivex.functions.Function<any,any>;
						public static values(): io.reactivex.internal.operators.maybe.MaybeToPublisher[];
						public apply(t: io.reactivex.MaybeSource<any>): org.reactivestreams.Publisher<any>;
						public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
						public apply(param0: any): any;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeToSingle<T>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.HasUpstreamMaybeSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToSingle<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>, defaultValue: any);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeToSingle {
						export class ToSingleMaybeSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeToSingle.ToSingleMaybeSubscriber<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeUnsafeCreate<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeUnsafeCreate<any>>;
						public constructor();
						public constructor(source: io.reactivex.MaybeSource<any>);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeUnsubscribeOn<T>  extends io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.MaybeSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.MaybeSource<any>;
					}
					export module MaybeUnsubscribeOn {
						export class UnsubscribeOnMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn.UnsubscribeOnMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeUsing<T, D>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeUsing<any,any>>;
						public constructor();
						public constructor(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, resourceDisposer: io.reactivex.functions.Consumer<any>, eager: boolean);
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeUsing {
						export class UsingObserver<T, D>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeUsing.UsingObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeZipArray<T, R>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipArray<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(sources: io.reactivex.MaybeSource<any>[], zipper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeZipArray {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipArray.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
						export class ZipCoordinator<T, R>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipArray.ZipCoordinator<any,any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class ZipMaybeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipArray.ZipMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module maybe {
					export class MaybeZipIterable<T, R>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipIterable<any,any>>;
						public constructor(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>);
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module MaybeZipIterable {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.maybe.MaybeZipIterable.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class CompletableAndThenObservable<R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.CompletableAndThenObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.CompletableSource, other: io.reactivex.ObservableSource<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module CompletableAndThenObservable {
						export class AndThenObservableObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.CompletableAndThenObservable.AndThenObservableObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class CompletableAndThenPublisher<R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.CompletableAndThenPublisher<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.CompletableSource, other: org.reactivestreams.Publisher<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module CompletableAndThenPublisher {
						export class AndThenPublisherSubscriber<R>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.CompletableAndThenPublisher.AndThenPublisherSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableConcatMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatMapCompletable {
						export class ConcatMapCompletableObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable.ConcatMapCompletableObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
						}
						export module ConcatMapCompletableObserver {
							export class ConcatMapInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable.ConcatMapCompletableObserver.ConcatMapInnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableConcatMapMaybe<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatMapMaybe {
						export class ConcatMapMaybeSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module ConcatMapMaybeSubscriber {
							export class ConcatMapMaybeObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber.ConcatMapMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableConcatMapSingle<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapSingle<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableConcatMapSingle {
						export class ConcatMapSingleSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module ConcatMapSingleSubscriber {
							export class ConcatMapSingleObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber.ConcatMapSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableSwitchMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module FlowableSwitchMapCompletable {
						export class SwitchMapCompletableObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapCompletable.SwitchMapCompletableObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
						export module SwitchMapCompletableObserver {
							export class SwitchMapInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapCompletable.SwitchMapCompletableObserver.SwitchMapInnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableSwitchMapMaybe<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSwitchMapMaybe {
						export class SwitchMapMaybeSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe.SwitchMapMaybeSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module SwitchMapMaybeSubscriber {
							export class SwitchMapMaybeObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe.SwitchMapMaybeSubscriber.SwitchMapMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class FlowableSwitchMapSingle<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.Flowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module FlowableSwitchMapSingle {
						export class SwitchMapSingleSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle.SwitchMapSingleSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
						}
						export module SwitchMapSingleSubscriber {
							export class SwitchMapSingleObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle.SwitchMapSingleSubscriber.SwitchMapSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class MaterializeSingleObserver<T>  extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.MaterializeSingleObserver<any>>;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public onSuccess(t: T): void;
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public isDisposed(): boolean;
						public constructor(downstream: io.reactivex.SingleObserver<any>);
						public onError(e: java.lang.Throwable): void;
						public onComplete(): void;
						public onSuccess(param0: T): void;
						public onError(param0: java.lang.Throwable): void;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class MaybeFlatMapObservable<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.MaybeFlatMapObservable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module MaybeFlatMapObservable {
						export class FlatMapObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.MaybeFlatMapObservable.FlatMapObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSuccess(t: any): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class MaybeFlatMapPublisher<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.MaybeSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module MaybeFlatMapPublisher {
						export class FlatMapPublisherSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher.FlatMapPublisherSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onSuccess(param0: any): void;
							public onSuccess(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableConcatMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module ObservableConcatMapCompletable {
						export class ConcatMapCompletableObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable.ConcatMapCompletableObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module ConcatMapCompletableObserver {
							export class ConcatMapInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable.ConcatMapCompletableObserver.ConcatMapInnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableConcatMapMaybe<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatMapMaybe {
						export class ConcatMapMaybeMainObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe.ConcatMapMaybeMainObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module ConcatMapMaybeMainObserver {
							export class ConcatMapMaybeObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe.ConcatMapMaybeMainObserver.ConcatMapMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableConcatMapSingle<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapSingle<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, prefetch: number);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatMapSingle {
						export class ConcatMapSingleMainObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapSingle.ConcatMapSingleMainObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module ConcatMapSingleMainObserver {
							export class ConcatMapSingleObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableConcatMapSingle.ConcatMapSingleMainObserver.ConcatMapSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableSwitchMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module ObservableSwitchMapCompletable {
						export class SwitchMapCompletableObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable.SwitchMapCompletableObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module SwitchMapCompletableObserver {
							export class SwitchMapInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable.SwitchMapCompletableObserver.SwitchMapInnerObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableSwitchMapMaybe<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSwitchMapMaybe {
						export class SwitchMapMaybeMainObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe.SwitchMapMaybeMainObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module SwitchMapMaybeMainObserver {
							export class SwitchMapMaybeObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe.SwitchMapMaybeMainObserver.SwitchMapMaybeObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ObservableSwitchMapSingle<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSwitchMapSingle {
						export class SwitchMapSingleMainObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle.SwitchMapSingleMainObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module SwitchMapSingleMainObserver {
							export class SwitchMapSingleObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle.SwitchMapSingleMainObserver.SwitchMapSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class ScalarXMapZHelper extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.ScalarXMapZHelper>;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module mixed {
					export class SingleFlatMapObservable<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.mixed.SingleFlatMapObservable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module SingleFlatMapObservable {
						export class FlatMapObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.mixed.SingleFlatMapObservable.FlatMapObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSuccess(t: any): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export abstract class AbstractObservableWithUpstream<T, U>  extends io.reactivex.Observable<any> implements io.reactivex.internal.fuseable.HasUpstreamObservableSource<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.ObservableSource<any>;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class BlockingObservableIterable<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableIterable<any>>;
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public forEach(action: any /* any*/): void;
						public constructor(source: io.reactivex.ObservableSource<any>, bufferSize: number);
					}
					export module BlockingObservableIterable {
						export class BlockingObservableIterator<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableIterable.BlockingObservableIterator<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public hasNext(): boolean;
							public remove(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public next(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class BlockingObservableLatest<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableLatest<any>>;
						public iterator(): java.util.Iterator<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public spliterator(): java.util.Spliterator<any>;
						public forEach(action: any /* any*/): void;
					}
					export module BlockingObservableLatest {
						export class BlockingObservableLatestIterator<T>  extends io.reactivex.observers.DisposableObserver<io.reactivex.Notification<any>> implements java.util.Iterator<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableLatest.BlockingObservableLatestIterator<any>>;
							public onNext(args: io.reactivex.Notification<any>): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public hasNext(): boolean;
							public remove(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public next(): any;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class BlockingObservableMostRecent<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableMostRecent<any>>;
						public iterator(): java.util.Iterator<any>;
						public spliterator(): java.util.Spliterator<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, initialValue: any);
						public forEach(action: any /* any*/): void;
					}
					export module BlockingObservableMostRecent {
						export class MostRecentObserver<T>  extends io.reactivex.observers.DefaultObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableMostRecent.MostRecentObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public getIterable(): io.reactivex.internal.operators.observable.BlockingObservableMostRecent.MostRecentObserver.Iterator;
							public onNext(args: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module MostRecentObserver {
							export class Iterator extends java.util.Iterator<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableMostRecent.MostRecentObserver.Iterator>;
								public next(): any;
								public hasNext(): boolean;
								public remove(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class BlockingObservableNext<T>  extends java.lang.Iterable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableNext<any>>;
						public iterator(): java.util.Iterator<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public spliterator(): java.util.Spliterator<any>;
						public forEach(action: any /* any*/): void;
					}
					export module BlockingObservableNext {
						export class NextIterator<T>  extends java.util.Iterator<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableNext.NextIterator<any>>;
							public hasNext(): boolean;
							public remove(): void;
							public next(): any;
						}
						export class NextObserver<T>  extends io.reactivex.observers.DisposableObserver<io.reactivex.Notification<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.BlockingObservableNext.NextObserver<any>>;
							public onNext(args: io.reactivex.Notification<any>): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public takeNext(): io.reactivex.Notification<any>;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAll<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAll<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableAll {
						export class AllObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAll.AllObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAllSingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToObservable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAllSingle<any>>;
						public fuseToObservable(): io.reactivex.Observable<java.lang.Boolean>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableAllSingle {
						export class AllObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAllSingle.AllObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAmb<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAmb<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(sources: io.reactivex.ObservableSource<any>[], sourcesIterable: java.lang.Iterable<any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableAmb {
						export class AmbCoordinator<T>  extends io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAmb.AmbCoordinator<any>>;
							public dispose(): void;
							public subscribe(sources: io.reactivex.ObservableSource<any>[]): void;
							public isDisposed(): boolean;
							public win(index: number): boolean;
						}
						export class AmbInnerObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAmb.AmbInnerObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAny<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAny<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableAny {
						export class AnyObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAny.AnyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAnySingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToObservable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAnySingle<any>>;
						public fuseToObservable(): io.reactivex.Observable<java.lang.Boolean>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableAnySingle {
						export class AnyObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAnySingle.AnyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableAutoConnect<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableAutoConnect<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.observables.ConnectableObservable<any>, numberOfObservers: number, connection: io.reactivex.functions.Consumer<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(child: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBlockingSubscribe extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBlockingSubscribe>;
						public static subscribe(o: io.reactivex.ObservableSource<any>, onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): void;
						public static subscribe(o: io.reactivex.ObservableSource<any>): void;
						public static subscribe(o: io.reactivex.ObservableSource<any>, observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBuffer<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBuffer<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, count: number, skip: number, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableBuffer {
						export class BufferExactObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBuffer.BufferExactObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class BufferSkipObserver<T, U>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBuffer.BufferSkipObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBufferBoundary<T, U, Open, Close>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundary<any,any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, bufferOpen: io.reactivex.ObservableSource<any>, bufferClose: io.reactivex.functions.Function<any,any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableBufferBoundary {
						export class BufferBoundaryObserver<T, C, Open, Close>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferBoundaryObserver<any,any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module BufferBoundaryObserver {
							export class BufferOpenObserver<Open>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferBoundaryObserver.BufferOpenObserver<any>>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public isDisposed(): boolean;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
						export class BufferCloseObserver<T, C>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferCloseObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBufferBoundarySupplier<T, U, B>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, boundarySupplier: java.util.concurrent.Callable<any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableBufferBoundarySupplier {
						export class BufferBoundaryObserver<T, U, B>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier.BufferBoundaryObserver<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class BufferBoundarySupplierObserver<T, U, B>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier.BufferBoundarySupplierObserver<any,any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBufferExactBoundary<T, U, B>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferExactBoundary<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, boundary: io.reactivex.ObservableSource<any>, bufferSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableBufferExactBoundary {
						export class BufferBoundaryObserver<T, U, B>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferExactBoundary.BufferBoundaryObserver<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class BufferExactBoundaryObserver<T, U, B>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferExactBoundary.BufferExactBoundaryObserver<any,any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableBufferTimed<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, timespan: number, param2: number, timeskip: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: java.util.concurrent.Callable<any>, scheduler: number, bufferSupplier: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableBufferTimed {
						export class BufferExactBoundedObserver<T, U>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferExactBoundedObserver<any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
							public run(): void;
						}
						export class BufferExactUnboundedObserver<T, U>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferExactUnboundedObserver<any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
							public run(): void;
						}
						export class BufferSkipBoundedObserver<T, U>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferSkipBoundedObserver<any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
							public run(): void;
						}
						export module BufferSkipBoundedObserver {
							export class RemoveFromBuffer extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferSkipBoundedObserver.RemoveFromBuffer>;
								public run(): void;
							}
							export class RemoveFromBufferEmit extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferSkipBoundedObserver.RemoveFromBufferEmit>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCache<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> implements io.reactivex.Observer<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCache<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public onNext(param0: any): void;
						public onNext(t: any): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public onError(param0: java.lang.Throwable): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public onComplete(): void;
						public onError(t: java.lang.Throwable): void;
						public constructor(source: io.reactivex.Observable<any>, capacityHint: number);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ObservableCache {
						export class CacheDisposable<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCache.CacheDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class Node<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCache.Node<any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCollect<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCollect<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, initialSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableCollect {
						export class CollectObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCollect.CollectObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCollectSingle<T, U>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCollectSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, initialSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>);
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableCollectSingle {
						export class CollectObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCollectSingle.CollectObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCombineLatest<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCombineLatest<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(sources: io.reactivex.ObservableSource<any>[], sourcesIterable: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableCombineLatest {
						export class CombinerObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCombineLatest.CombinerObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class LatestCoordinator<T, R>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCombineLatest.LatestCoordinator<any,any>>;
							public dispose(): void;
							public subscribe(sources: io.reactivex.ObservableSource<any>[]): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableConcatMap<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMap<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, bufferSize: number, delayErrors: io.reactivex.internal.util.ErrorMode);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatMap {
						export class ConcatMapDelayErrorObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMap.ConcatMapDelayErrorObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
						export module ConcatMapDelayErrorObserver {
							export class DelayErrorInnerObserver<R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMap.ConcatMapDelayErrorObserver.DelayErrorInnerObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(value: any): void;
								public onNext(param0: any): void;
							}
						}
						export class SourceObserver<T, U>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMap.SourceObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module SourceObserver {
							export class InnerObserver<U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMap.SourceObserver.InnerObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableConcatMapEager<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMapEager<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, errorMode: io.reactivex.internal.util.ErrorMode, maxConcurrency: number, prefetch: number);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatMapEager {
						export class ConcatMapEagerMainObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatMapEager.ConcatMapEagerMainObserver<any,any>>;
							public onComplete(): void;
							public drain(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
							public innerComplete(inner: io.reactivex.internal.observers.InnerQueuedObserver<any>): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public innerNext(inner: io.reactivex.internal.observers.InnerQueuedObserver<any>, value: any): void;
							public innerNext(param0: io.reactivex.internal.observers.InnerQueuedObserver<any>, param1: any): void;
							public innerError(inner: io.reactivex.internal.observers.InnerQueuedObserver<any>, e: java.lang.Throwable): void;
							public innerError(param0: io.reactivex.internal.observers.InnerQueuedObserver<any>, param1: java.lang.Throwable): void;
							public innerComplete(param0: io.reactivex.internal.observers.InnerQueuedObserver<any>): void;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableConcatWithCompletable<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithCompletable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatWithCompletable {
						export class ConcatWithObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithCompletable.ConcatWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableConcatWithMaybe<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithMaybe<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.MaybeSource<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatWithMaybe {
						export class ConcatWithObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithMaybe.ConcatWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(t: any): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableConcatWithSingle<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithSingle<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.SingleSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableConcatWithSingle {
						export class ConcatWithObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableConcatWithSingle.ConcatWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(t: any): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCount<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCount<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableCount {
						export class CountObserver extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCount.CountObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCountSingle<T>  extends io.reactivex.Single<java.lang.Long> implements io.reactivex.internal.fuseable.FuseToObservable<java.lang.Long>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCountSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<java.lang.Long>;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableCountSingle {
						export class CountObserver extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCountSingle.CountObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableCreate<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCreate<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableOnSubscribe<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableCreate {
						export class CreateEmitter<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCreate.CreateEmitter<any>>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public dispose(): void;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public isDisposed(): boolean;
							public toString(): string;
							public onNext(t: any): void;
							public serialize(): io.reactivex.ObservableEmitter<any>;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
						export class SerializedEmitter<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.ObservableEmitter<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableCreate.SerializedEmitter<any>>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public isDisposed(): boolean;
							public toString(): string;
							public onNext(t: any): void;
							public serialize(): io.reactivex.ObservableEmitter<any>;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDebounce<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounce<any,any>>;
						public constructor(source: io.reactivex.ObservableSource<any>, debounceSelector: io.reactivex.functions.Function<any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDebounce {
						export class DebounceObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounce.DebounceObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module DebounceObserver {
							export class DebounceInnerObserver<T, U>  extends io.reactivex.observers.DisposableObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounce.DebounceObserver.DebounceInnerObserver<any,any>>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public isDisposed(): boolean;
								public onError(t: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDebounceTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounceTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDebounceTimed {
						export class DebounceEmitter<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounceTimed.DebounceEmitter<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
						export class DebounceTimedObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDebounceTimed.DebounceTimedObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDefer<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDefer<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(supplier: java.util.concurrent.Callable<any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDelay<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelay<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, delay: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDelay {
						export class DelayObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelay.DelayObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module DelayObserver {
							export class OnComplete extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelay.DelayObserver.OnComplete>;
								public run(): void;
							}
							export class OnError extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelay.DelayObserver.OnError>;
								public run(): void;
							}
							export class OnNext extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelay.DelayObserver.OnNext>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDelaySubscriptionOther<T, U>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(main: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(child: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDelaySubscriptionOther {
						export class DelayObserver extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther.DelayObserver>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module DelayObserver {
							export class OnComplete extends io.reactivex.Observer<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther.DelayObserver.OnComplete>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(value: any): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDematerialize<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDematerialize<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, selector: io.reactivex.functions.Function<any,any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDematerialize {
						export class DematerializeObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDematerialize.DematerializeObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(item: T): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDetach<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDetach<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDetach {
						export class DetachObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDetach.DetachObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDistinct<T, K>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDistinct<any,any>>;
						public constructor(source: io.reactivex.ObservableSource<any>, keySelector: io.reactivex.functions.Function<any,any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDistinct {
						export class DistinctObserver<T, K>  extends io.reactivex.internal.observers.BasicFuseableObserver<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDistinct.DistinctObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public poll(): any;
							public onError(e: java.lang.Throwable): void;
							public onNext(value: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDistinctUntilChanged<T, K>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, keySelector: io.reactivex.functions.Function<any,any>, comparer: io.reactivex.functions.BiPredicate<any,any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDistinctUntilChanged {
						export class DistinctUntilChangedObserver<T, K>  extends io.reactivex.internal.observers.BasicFuseableObserver<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged.DistinctUntilChangedObserver<any,any>>;
							public requestFusion(mode: number): number;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDoAfterNext<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoAfterNext<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, onAfterNext: io.reactivex.functions.Consumer<any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDoAfterNext {
						export class DoAfterObserver<T>  extends io.reactivex.internal.observers.BasicFuseableObserver<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoAfterNext.DoAfterObserver<any>>;
							public requestFusion(mode: number): number;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDoFinally<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoFinally<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, onFinally: io.reactivex.functions.Action);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDoFinally {
						export class DoFinallyObserver<T>  extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoFinally.DoFinallyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDoOnEach<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoOnEach<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onAfterTerminate: io.reactivex.functions.Action);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableDoOnEach {
						export class DoOnEachObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoOnEach.DoOnEachObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableDoOnLifecycle<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableDoOnLifecycle<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(upstream: io.reactivex.Observable<any>, onSubscribe: io.reactivex.functions.Consumer<any>, onDispose: io.reactivex.functions.Action);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableElementAt<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAt<any>>;
						public constructor(source: io.reactivex.ObservableSource<any>, index: number, param2: any, defaultValue: boolean);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableElementAt {
						export class ElementAtObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAt.ElementAtObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableElementAtMaybe<T>  extends io.reactivex.Maybe<any> implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAtMaybe<any>>;
						public constructor();
						public subscribeActual(t: io.reactivex.MaybeObserver<any>): void;
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, index: number);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableElementAtMaybe {
						export class ElementAtObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAtMaybe.ElementAtObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableElementAtSingle<T>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAtSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, index: number, param2: any);
					}
					export module ObservableElementAtSingle {
						export class ElementAtObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableElementAtSingle.ElementAtObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableEmpty extends io.reactivex.Observable<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableEmpty>;
						public static INSTANCE: io.reactivex.Observable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public call(): any;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableError<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableError<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(errorSupplier: java.util.concurrent.Callable<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFilter<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFilter<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFilter {
						export class FilterObserver<T>  extends io.reactivex.internal.observers.BasicFuseableObserver<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFilter.FilterObserver<any>>;
							public requestFusion(mode: number): number;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlatMap<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMap<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean, maxConcurrency: number, bufferSize: number);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFlatMap {
						export class InnerObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMap.InnerObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class MergeObserver<T, U>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMap.MergeObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlatMapCompletable<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFlatMapCompletable {
						export class FlatMapCompletableMainObserver<T>  extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletable.FlatMapCompletableMainObserver<any>>;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
						}
						export module FlatMapCompletableMainObserver {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletable.FlatMapCompletableMainObserver.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlatMapCompletableCompletable<T>  extends io.reactivex.Completable implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, delayErrors: boolean);
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module ObservableFlatMapCompletableCompletable {
						export class FlatMapCompletableMainObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable.FlatMapCompletableMainObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
						export module FlatMapCompletableMainObserver {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable.FlatMapCompletableMainObserver.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlatMapMaybe<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapMaybe<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, delayError: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFlatMapMaybe {
						export class FlatMapMaybeObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapMaybe.FlatMapMaybeObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module FlatMapMaybeObserver {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapMaybe.FlatMapMaybeObserver.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlatMapSingle<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapSingle<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, delayError: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFlatMapSingle {
						export class FlatMapSingleObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapSingle.FlatMapSingleObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module FlatMapSingleObserver {
							export class InnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlatMapSingle.FlatMapSingleObserver.InnerObserver>;
								public dispose(): void;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public isDisposed(): boolean;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFlattenIterable<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlattenIterable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFlattenIterable {
						export class FlattenIterableObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFlattenIterable.FlattenIterableObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(value: T): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromArray<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromArray<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(array: any[]);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFromArray {
						export class FromArrayDisposable<T>  extends io.reactivex.internal.observers.BasicQueueDisposable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromArray.FromArrayDisposable<any>>;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromCallable<T>  extends io.reactivex.Observable<any> implements java.util.concurrent.Callable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromCallable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public call(): any;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(callable: java.util.concurrent.Callable<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromFuture<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromFuture<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(future: java.util.concurrent.Future<any>, timeout: number, param2: java.util.concurrent.TimeUnit);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromIterable<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromIterable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: java.lang.Iterable<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFromIterable {
						export class FromIterableDisposable<T>  extends io.reactivex.internal.observers.BasicQueueDisposable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromIterable.FromIterableDisposable<any>>;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromPublisher<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromPublisher<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public constructor(publisher: org.reactivestreams.Publisher<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableFromPublisher {
						export class PublisherSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromPublisher.PublisherSubscriber<any>>;
							public onComplete(): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableFromUnsafeSource<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableFromUnsafeSource<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableGenerate<T, S>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGenerate<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(stateSupplier: java.util.concurrent.Callable<any>, generator: io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any>, disposeState: io.reactivex.functions.Consumer<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableGenerate {
						export class GeneratorDisposable<T, S>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGenerate.GeneratorDisposable<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public isDisposed(): boolean;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableGroupBy<T, K, V>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.observables.GroupedObservable<any,any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupBy<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableGroupBy {
						export class GroupByObserver<T, K, V>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupBy.GroupByObserver<any,any,any>>;
							public constructor();
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public cancel(key: any): void;
							public constructor(initialValue: number);
							public constructor(actual: io.reactivex.Observer<any>, keySelector: io.reactivex.functions.Function<any,any>, valueSelector: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean);
						}
						export class GroupedUnicast<K, T>  extends io.reactivex.observables.GroupedObservable<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupBy.GroupedUnicast<any,any>>;
							public constructor();
							public onComplete(): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(observer: io.reactivex.Observer<any>): void;
							public subscribe(param0: io.reactivex.Observer<any>): void;
							public onNext(t: any): void;
							public subscribeActual(observer: io.reactivex.Observer<any>): void;
							public static createWith(key: any, bufferSize: number, parent: io.reactivex.internal.operators.observable.ObservableGroupBy.GroupByObserver<any,any,any>, delayError: boolean): io.reactivex.internal.operators.observable.ObservableGroupBy.GroupedUnicast<any,any>;
							public constructor(key: any);
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribeActual(param0: io.reactivex.Observer<any>): void;
							public constructor(key: any, state: io.reactivex.internal.operators.observable.ObservableGroupBy.State<any,any>);
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public onError(e: java.lang.Throwable): void;
						}
						export class State<T, K>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupBy.State<any,any>>;
							public onComplete(): void;
							public subscribe(observer: io.reactivex.Observer<any>): void;
							public dispose(): void;
							public subscribe(param0: io.reactivex.Observer<any>): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableGroupJoin<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupJoin<any,any,any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableGroupJoin {
						export class GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupJoin.GroupJoinDisposable<any,any,any,any,any>>;
							public innerClose(isLeft: boolean, index: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
							public innerError(ex: java.lang.Throwable): void;
							public dispose(): void;
							public innerValue(isLeft: boolean, o: any): void;
							public innerCloseError(ex: java.lang.Throwable): void;
							public innerComplete(param0: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
							public innerError(param0: java.lang.Throwable): void;
							public isDisposed(): boolean;
							public innerComplete(sender: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
							public innerCloseError(param0: java.lang.Throwable): void;
						}
						export class JoinSupport extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupJoin.JoinSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservableGroupJoin$JoinSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								innerError(param0: java.lang.Throwable): void;
								innerComplete(param0: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
								innerValue(param0: boolean, param1: any): void;
								innerClose(param0: boolean, param1: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
								innerCloseError(param0: java.lang.Throwable): void;
							});
							public constructor();
							public innerComplete(param0: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
							public innerError(param0: java.lang.Throwable): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
							public innerCloseError(param0: java.lang.Throwable): void;
						}
						export class LeftRightEndObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class LeftRightObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableHide<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableHide<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableHide {
						export class HideDisposable<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableHide.HideDisposable<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableIgnoreElements<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIgnoreElements<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableIgnoreElements {
						export class IgnoreObservable<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIgnoreElements.IgnoreObservable<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(v: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableIgnoreElementsCompletable<T>  extends io.reactivex.Completable implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module ObservableIgnoreElementsCompletable {
						export class IgnoreObservable<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable.IgnoreObservable<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(v: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableInternalHelper extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper>;
						public static simpleBiGenerator(consumer: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.functions.BiFunction<any,any,any>;
						public static flatMapWithCombiner(mapper: io.reactivex.functions.Function<any,any>, combiner: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.functions.Function<any,any>;
						public static zipIterable(zipper: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
						public static observerOnNext(observer: io.reactivex.Observer<any>): io.reactivex.functions.Consumer<any>;
						public static observerOnError(observer: io.reactivex.Observer<any>): io.reactivex.functions.Consumer<any>;
						public static replayCallable(parent: io.reactivex.Observable<any>): java.util.concurrent.Callable<any>;
						public static observerOnComplete(observer: io.reactivex.Observer<any>): io.reactivex.functions.Action;
						public static replayFunction(selector: io.reactivex.functions.Function<any,any>, scheduler: io.reactivex.Scheduler): io.reactivex.functions.Function<any,any>;
						public static simpleGenerator(consumer: io.reactivex.functions.Consumer<any>): io.reactivex.functions.BiFunction<any,any,any>;
						public static replayCallable(parent: io.reactivex.Observable<any>, bufferSize: number): java.util.concurrent.Callable<any>;
						public static replayCallable(parent: io.reactivex.Observable<any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): java.util.concurrent.Callable<any>;
						public static itemDelay(itemDelay: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
						public static flatMapIntoIterable(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.functions.Function<any,any>;
						public static replayCallable(parent: io.reactivex.Observable<any>, bufferSize: number, time: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): java.util.concurrent.Callable<any>;
					}
					export module ObservableInternalHelper {
						export class BufferedReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.observables.ConnectableObservable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.BufferedReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.observables.ConnectableObservable<any>;
						}
						export class BufferedTimedReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.observables.ConnectableObservable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.BufferedTimedReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.observables.ConnectableObservable<any>;
						}
						export class FlatMapIntoIterable<T, U>  extends io.reactivex.functions.Function<any,io.reactivex.ObservableSource<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapIntoIterable<any,any>>;
							public apply(param0: any): any;
							public apply(t: any): io.reactivex.ObservableSource<any>;
						}
						export class FlatMapWithCombinerInner<U, R, T>  extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapWithCombinerInner<any,any,any>>;
							public apply(w: any): any;
							public apply(param0: any): any;
						}
						export class FlatMapWithCombinerOuter<T, R, U>  extends io.reactivex.functions.Function<any,io.reactivex.ObservableSource<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapWithCombinerOuter<any,any,any>>;
							public apply(param0: any): any;
							public apply(t: any): io.reactivex.ObservableSource<any>;
						}
						export class ItemDelayFunction<T, U>  extends io.reactivex.functions.Function<any,io.reactivex.ObservableSource<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ItemDelayFunction<any,any>>;
							public apply(v: any): io.reactivex.ObservableSource<any>;
							public apply(param0: any): any;
						}
						export class MapToInt extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.MapToInt>;
							public static INSTANCE: io.reactivex.internal.operators.observable.ObservableInternalHelper.MapToInt;
							public static values(): io.reactivex.internal.operators.observable.ObservableInternalHelper.MapToInt[];
							public apply(t: any): any;
							public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
							public static valueOf(name: string): io.reactivex.internal.operators.observable.ObservableInternalHelper.MapToInt;
							public apply(param0: any): any;
						}
						export class ObserverOnComplete<T>  extends io.reactivex.functions.Action {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnComplete<any>>;
							public run(): void;
						}
						export class ObserverOnError<T>  extends io.reactivex.functions.Consumer<java.lang.Throwable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnError<any>>;
							public accept(v: java.lang.Throwable): void;
							public accept(param0: any): void;
						}
						export class ObserverOnNext<T>  extends io.reactivex.functions.Consumer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnNext<any>>;
							public accept(param0: any): void;
							public accept(v: any): void;
						}
						export class ReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.observables.ConnectableObservable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.observables.ConnectableObservable<any>;
						}
						export class ReplayFunction<T, R>  extends io.reactivex.functions.Function<io.reactivex.Observable<any>,io.reactivex.ObservableSource<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ReplayFunction<any,any>>;
							public apply(t: io.reactivex.Observable<any>): io.reactivex.ObservableSource<any>;
							public apply(param0: any): any;
						}
						export class SimpleBiGenerator<T, S>  extends io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.SimpleBiGenerator<any,any>>;
							public apply(t1: any, t2: io.reactivex.Emitter<any>): any;
							public apply(param0: any, param1: any): any;
						}
						export class SimpleGenerator<T, S>  extends io.reactivex.functions.BiFunction<any,io.reactivex.Emitter<any>,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.SimpleGenerator<any,any>>;
							public apply(t1: any, t2: io.reactivex.Emitter<any>): any;
							public apply(param0: any, param1: any): any;
						}
						export class TimedReplayCallable<T>  extends java.util.concurrent.Callable<io.reactivex.observables.ConnectableObservable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.TimedReplayCallable<any>>;
							public call(): any;
							public call(): io.reactivex.observables.ConnectableObservable<any>;
						}
						export class ZipIterableFunction<T, R>  extends io.reactivex.functions.Function<java.util.List<io.reactivex.ObservableSource<any>>,io.reactivex.ObservableSource<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInternalHelper.ZipIterableFunction<any,any>>;
							public apply(param0: any): any;
							public apply(list: java.util.List<io.reactivex.ObservableSource<any>>): io.reactivex.ObservableSource<any>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableInterval extends io.reactivex.Observable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInterval>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(initialDelay: number, param1: number, period: java.util.concurrent.TimeUnit, param3: io.reactivex.Scheduler);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableInterval {
						export class IntervalObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableInterval.IntervalObserver>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableIntervalRange extends io.reactivex.Observable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIntervalRange>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(start: number, param1: number, end: number, param3: number, initialDelay: java.util.concurrent.TimeUnit, param5: io.reactivex.Scheduler);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableIntervalRange {
						export class IntervalRangeObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableIntervalRange.IntervalRangeObserver>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableJoin<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableJoin<any,any,any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>, leftEnd: io.reactivex.functions.Function<any,any>, rightEnd: io.reactivex.functions.Function<any,any>, resultSelector: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableJoin {
						export class JoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableJoin.JoinDisposable<any,any,any,any,any>>;
							public innerClose(isLeft: boolean, index: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
							public innerError(ex: java.lang.Throwable): void;
							public dispose(): void;
							public innerValue(isLeft: boolean, o: any): void;
							public innerCloseError(ex: java.lang.Throwable): void;
							public innerComplete(param0: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
							public innerError(param0: java.lang.Throwable): void;
							public isDisposed(): boolean;
							public innerComplete(sender: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightObserver): void;
							public innerValue(param0: boolean, param1: any): void;
							public innerClose(param0: boolean, param1: io.reactivex.internal.operators.observable.ObservableGroupJoin.LeftRightEndObserver): void;
							public innerCloseError(param0: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableJust<T>  extends io.reactivex.Observable<any> implements io.reactivex.internal.fuseable.ScalarCallable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableJust<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public call(): any;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(value: any);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableLastMaybe<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableLastMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableLastMaybe {
						export class LastObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableLastMaybe.LastObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableLastSingle<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableLastSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, defaultItem: any);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableLastSingle {
						export class LastObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableLastSingle.LastObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableLift<R, T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableLift<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, operator: io.reactivex.ObservableOperator<any,any>);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMap<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMap<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, _function_: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMap {
						export class MapObserver<T, U>  extends io.reactivex.internal.observers.BasicFuseableObserver<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMap.MapObserver<any,any>>;
							public requestFusion(mode: number): number;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMapNotification<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.ObservableSource<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMapNotification<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, onNextMapper: io.reactivex.functions.Function<any,any>, onErrorMapper: io.reactivex.functions.Function<any,any>, onCompleteSupplier: java.util.concurrent.Callable<any>);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMapNotification {
						export class MapNotificationObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMapNotification.MapNotificationObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMaterialize<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Notification<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMaterialize<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMaterialize {
						export class MaterializeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMaterialize.MaterializeObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMergeWithCompletable<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithCompletable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.CompletableSource);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMergeWithCompletable {
						export class MergeWithObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithCompletable.MergeWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(ex: java.lang.Throwable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module MergeWithObserver {
							export class OtherObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.CompletableObserver  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithCompletable.MergeWithObserver.OtherObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMergeWithMaybe<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithMaybe<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.MaybeSource<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMergeWithMaybe {
						export class MergeWithObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithMaybe.MergeWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(ex: java.lang.Throwable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module MergeWithObserver {
							export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.MaybeObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithMaybe.MergeWithObserver.OtherObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableMergeWithSingle<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithSingle<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, other: io.reactivex.SingleSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableMergeWithSingle {
						export class MergeWithObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithSingle.MergeWithObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(ex: java.lang.Throwable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module MergeWithObserver {
							export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableMergeWithSingle.MergeWithObserver.OtherObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableNever extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableNever>;
						public static INSTANCE: io.reactivex.Observable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableObserveOn<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableObserveOn<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, scheduler: io.reactivex.Scheduler, delayError: boolean, bufferSize: number);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableObserveOn {
						export class ObserveOnObserver<T>  extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableObserveOn.ObserveOnObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public isEmpty(): boolean;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableOnErrorNext<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableOnErrorNext<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, nextSupplier: io.reactivex.functions.Function<any,any>, allowFatal: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableOnErrorNext {
						export class OnErrorNextObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableOnErrorNext.OnErrorNextObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableOnErrorReturn<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableOnErrorReturn<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, valueSupplier: io.reactivex.functions.Function<any,any>);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableOnErrorReturn {
						export class OnErrorReturnObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableOnErrorReturn.OnErrorReturnObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservablePublish<T>  extends io.reactivex.observables.ConnectableObservable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublish<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public static create(source: io.reactivex.ObservableSource<any>): io.reactivex.observables.ConnectableObservable<any>;
						public source(): io.reactivex.ObservableSource<any>;
						public connect(): io.reactivex.disposables.Disposable;
						public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public publishSource(): io.reactivex.ObservableSource<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ObservablePublish {
						export class InnerDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<any> implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublish.InnerDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class PublishObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublish.PublishObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class PublishSource<T>  extends io.reactivex.ObservableSource<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublish.PublishSource<any>>;
							public subscribe(child: io.reactivex.Observer<any>): void;
							public subscribe(param0: io.reactivex.Observer<any>): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservablePublishAlt<T>  extends io.reactivex.observables.ConnectableObservable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishAlt<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public connect(): io.reactivex.disposables.Disposable;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public resetIf(param0: io.reactivex.disposables.Disposable): void;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public resetIf(connection: io.reactivex.disposables.Disposable): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ObservablePublishAlt {
						export class InnerDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.observable.ObservablePublishAlt.PublishConnection<any>> implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishAlt.InnerDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class PublishConnection<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.observable.ObservablePublishAlt.InnerDisposable<any>[]> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishAlt.PublishConnection<any>>;
							public add(inner: io.reactivex.internal.operators.observable.ObservablePublishAlt.InnerDisposable<any>): boolean;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public remove(inner: io.reactivex.internal.operators.observable.ObservablePublishAlt.InnerDisposable<any>): void;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservablePublishClassic<T>  extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishClassic<any>>;
						/**
						 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservablePublishClassic<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
						 */
						public constructor(implementation: {
							publishSource(): io.reactivex.ObservableSource<T>;
						});
						public constructor();
						public publishSource(): io.reactivex.ObservableSource<T>;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservablePublishSelector<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishSelector<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, selector: io.reactivex.functions.Function<any,any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservablePublishSelector {
						export class SourceObserver<T, R>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishSelector.SourceObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
						export class TargetObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservablePublishSelector.TargetObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRange extends io.reactivex.Observable<java.lang.Integer> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRange>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(start: number, count: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRange {
						export class RangeDisposable extends io.reactivex.internal.observers.BasicIntQueueDisposable<java.lang.Integer> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRange.RangeDisposable>;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public clear(): void;
							public isDisposed(): boolean;
							public isEmpty(): boolean;
							public poll(): java.lang.Integer;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRangeLong extends io.reactivex.Observable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRangeLong>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(start: number, param1: number);
						public subscribeActual(o: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRangeLong {
						export class RangeDisposable extends io.reactivex.internal.observers.BasicIntQueueDisposable<java.lang.Long> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRangeLong.RangeDisposable>;
							public requestFusion(mode: number): number;
							public dispose(): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): java.lang.Long;
							public isEmpty(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableReduceMaybe<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReduceMaybe<any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableReduceMaybe {
						export class ReduceObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReduceMaybe.ReduceObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(value: T): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableReduceSeedSingle<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReduceSeedSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, seed: any, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableReduceSeedSingle {
						export class ReduceSeedObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReduceSeedSingle.ReduceSeedObserver<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(value: T): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableReduceWithSingle<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReduceWithSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, seedSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRefCount<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRefCount<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.observables.ConnectableObservable<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.observables.ConnectableObservable<any>, n: number, timeout: number, param3: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRefCount {
						export class RefConnection extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRefCount.RefConnection>;
							public accept(t: io.reactivex.disposables.Disposable): void;
							public accept(param0: any): void;
							public run(): void;
						}
						export class RefCountObserver<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRefCount.RefCountObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRepeat<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeat<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.Observable<any>, count: number);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRepeat {
						export class RepeatObserver<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeat.RepeatObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRepeatUntil<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeatUntil<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Observable<any>, until: io.reactivex.functions.BooleanSupplier);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRepeatUntil {
						export class RepeatUntilObserver<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeatUntil.RepeatUntilObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRepeatWhen<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeatWhen<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, handler: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRepeatWhen {
						export class RepeatWhenObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeatWhen.RepeatWhenObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module RepeatWhenObserver {
							export class InnerRepeatObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRepeatWhen.RepeatWhenObserver.InnerRepeatObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableReplay<T>  extends io.reactivex.observables.ConnectableObservable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay<any>>;
						public static create(source: io.reactivex.ObservableSource<any>, maxAge: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public source(): io.reactivex.ObservableSource<any>;
						public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
						public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean): io.reactivex.Observable<any>;
						public connect(param0: io.reactivex.functions.Consumer<any>): void;
						public static observeOn(co: io.reactivex.observables.ConnectableObservable<any>, scheduler: io.reactivex.Scheduler): io.reactivex.observables.ConnectableObservable<any>;
						public observeOn(scheduler: io.reactivex.Scheduler, delayError: boolean, bufferSize: number): io.reactivex.Observable<any>;
						public resetIf(param0: io.reactivex.disposables.Disposable): void;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public observeOn(scheduler: io.reactivex.Scheduler): io.reactivex.Observable<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public static createFrom(source: io.reactivex.ObservableSource<any>): io.reactivex.observables.ConnectableObservable<any>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public static create(source: io.reactivex.ObservableSource<any>, bufferSize: number): io.reactivex.observables.ConnectableObservable<any>;
						public connect(): io.reactivex.disposables.Disposable;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public connect(connection: io.reactivex.functions.Consumer<any>): void;
						public static create(source: io.reactivex.ObservableSource<any>, maxAge: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.observables.ConnectableObservable<any>;
						public static multicastSelector(connectableFactory: java.util.concurrent.Callable<any>, selector: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public resetIf(connectionObject: io.reactivex.disposables.Disposable): void;
					}
					export module ObservableReplay {
						export abstract class BoundedReplayBuffer<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.observable.ObservableReplay.Node> implements io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.BoundedReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public error(param0: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(param0: any): void;
							public replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(value: any): void;
							public complete(): void;
						}
						export class BufferSupplier<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.BufferSupplier<any>>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservableReplay$BufferSupplier interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								call(): io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<T>;
							});
							public constructor();
							public call(): io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<T>;
						}
						export class DisposeConsumer<R>  extends io.reactivex.functions.Consumer<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.DisposeConsumer<any>>;
							public accept(r: io.reactivex.disposables.Disposable): void;
							public accept(param0: any): void;
						}
						export class InnerDisposable<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class MulticastReplay<R, U>  extends io.reactivex.Observable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.MulticastReplay<any,any>>;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(observer: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribeActual(param0: io.reactivex.Observer<any>): void;
							public subscribeActual(child: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(param0: io.reactivex.Observer<any>): void;
						}
						export class Node extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.operators.observable.ObservableReplay.Node> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.Node>;
						}
						export class Replay<T>  extends io.reactivex.observables.ConnectableObservable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.Replay<any>>;
							public connect(connection: io.reactivex.functions.Consumer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(observer: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public connect(): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribeActual(param0: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(param0: io.reactivex.Observer<any>): void;
							public subscribeActual(observer: io.reactivex.Observer<any>): void;
							public connect(param0: io.reactivex.functions.Consumer<any>): void;
						}
						export class ReplayBuffer<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservableReplay$ReplayBuffer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								next(param0: T): void;
								error(param0: java.lang.Throwable): void;
								complete(): void;
								replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<T>): void;
							});
							public constructor();
							public error(param0: java.lang.Throwable): void;
							public complete(): void;
							public next(param0: T): void;
							public replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<T>): void;
						}
						export class ReplayBufferSupplier<T>  extends io.reactivex.internal.operators.observable.ObservableReplay.BufferSupplier<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.ReplayBufferSupplier<any>>;
							public call(): io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>;
						}
						export class ReplayObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.ReplayObserver<any>>;
							public onSubscribe(p: io.reactivex.disposables.Disposable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
						}
						export class ReplaySource<T>  extends io.reactivex.ObservableSource<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.ReplaySource<any>>;
							public subscribe(child: io.reactivex.Observer<any>): void;
							public subscribe(param0: io.reactivex.Observer<any>): void;
						}
						export class ScheduledReplaySupplier<T>  extends io.reactivex.internal.operators.observable.ObservableReplay.BufferSupplier<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.ScheduledReplaySupplier<any>>;
							public call(): io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>;
						}
						export class SizeAndTimeBoundReplayBuffer<T>  extends io.reactivex.internal.operators.observable.ObservableReplay.BoundedReplayBuffer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.SizeAndTimeBoundReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public error(param0: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(param0: any): void;
							public replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(value: any): void;
							public complete(): void;
						}
						export class SizeBoundReplayBuffer<T>  extends io.reactivex.internal.operators.observable.ObservableReplay.BoundedReplayBuffer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.SizeBoundReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public error(param0: java.lang.Throwable): void;
							public replay(output: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(param0: any): void;
							public replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public next(value: any): void;
							public complete(): void;
						}
						export class UnBoundedFactory extends io.reactivex.internal.operators.observable.ObservableReplay.BufferSupplier<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.UnBoundedFactory>;
							public call(): io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>;
						}
						export class UnboundedReplayBuffer<T>  extends java.util.ArrayList<any> implements io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableReplay.UnboundedReplayBuffer<any>>;
							public error(e: java.lang.Throwable): void;
							public subList(param0: number, param1: number): java.util.List<any>;
							public toArray(): any[];
							public add(index: number, element: any): void;
							public lastIndexOf(o: any): number;
							public next(value: any): void;
							public stream(): java.util.stream.Stream<any>;
							public listIterator(index: number): java.util.ListIterator<any>;
							public toArray(a: any[]): any[];
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public get(index: number): any;
							public add(param0: number, param1: any): void;
							public toArray(param0: any[]): any[];
							public indexOf(o: any): number;
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public get(param0: number): any;
							public indexOf(param0: any): number;
							public set(index: number, element: any): any;
							public error(param0: java.lang.Throwable): void;
							public addAll(param0: number, param1: java.util.Collection<any>): boolean;
							public removeAll(c: java.util.Collection<any>): boolean;
							public replay(param0: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public remove(index: number): any;
							public parallelStream(): java.util.stream.Stream<any>;
							public contains(param0: any): boolean;
							public remove(param0: number): any;
							public size(): number;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public retainAll(c: java.util.Collection<any>): boolean;
							public add(e: any): boolean;
							public listIterator(): java.util.ListIterator<any>;
							public replaceAll(operator: any /* any*/): void;
							public set(param0: number, param1: any): any;
							public add(param0: any): boolean;
							public listIterator(param0: number): java.util.ListIterator<any>;
							public next(param0: any): void;
							public equals(o: any): boolean;
							public subList(fromIndex: number, toIndex: number): java.util.List<any>;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public lastIndexOf(param0: any): number;
							public clear(): void;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public addAll(index: number, c: java.util.Collection<any>): boolean;
							public replay(output: io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable<any>): void;
							public sort(c: java.util.Comparator<any>): void;
							public removeIf(filter: any /* any*/): boolean;
							public complete(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRetryBiPredicate<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryBiPredicate<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, predicate: io.reactivex.functions.BiPredicate<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRetryBiPredicate {
						export class RetryBiObserver<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryBiPredicate.RetryBiObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRetryPredicate<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryPredicate<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, count: number, param2: io.reactivex.functions.Predicate<any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRetryPredicate {
						export class RepeatObserver<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryPredicate.RepeatObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableRetryWhen<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryWhen<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, handler: io.reactivex.functions.Function<any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableRetryWhen {
						export class RepeatWhenObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryWhen.RepeatWhenObserver<any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module RepeatWhenObserver {
							export class InnerRepeatObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableRetryWhen.RepeatWhenObserver.InnerRepeatObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSampleTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, period: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSampleTimed {
						export class SampleTimedEmitLast<T>  extends io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedEmitLast<any>>;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SampleTimedNoLast<T>  extends io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedNoLast<any>>;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export abstract class SampleTimedObserver<T>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSampleWithObservable<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleWithObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>, emitLast: boolean);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSampleWithObservable {
						export class SampleMainEmitLast<T>  extends io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainEmitLast<any>>;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SampleMainNoLast<T>  extends io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainNoLast<any>>;
							public onNext(param0: any): void;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public onComplete(): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export abstract class SampleMainObserver<T>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainObserver<any>>;
							public error(e: java.lang.Throwable): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public complete(): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SamplerObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SamplerObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableScalarXMap extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScalarXMap>;
						public static tryScalarXMapSubscribe(source: io.reactivex.ObservableSource<any>, observer: io.reactivex.Observer<any>, mapper: io.reactivex.functions.Function<any,any>): boolean;
						public static scalarXMap(value: any, mapper: io.reactivex.functions.Function<any,any>): io.reactivex.Observable<any>;
					}
					export module ObservableScalarXMap {
						export class ScalarDisposable<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable<any>>;
							public constructor();
							public requestFusion(mode: number): number;
							public offer(v1: any, v2: any): boolean;
							public offer(param0: any, param1: any): boolean;
							public dispose(): void;
							public clear(): void;
							public isDisposed(): boolean;
							public offer(param0: any): boolean;
							public poll(): any;
							public offer(value: any): boolean;
							public constructor(initialValue: number);
							public constructor(observer: io.reactivex.Observer<any>, value: any);
							public requestFusion(param0: number): number;
							public isEmpty(): boolean;
							public run(): void;
						}
						export class ScalarXMapObservable<T, R>  extends io.reactivex.Observable<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarXMapObservable<any,any>>;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(observer: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribeActual(param0: io.reactivex.Observer<any>): void;
							public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(param0: io.reactivex.Observer<any>): void;
							public subscribeActual(observer: io.reactivex.Observer<any>): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableScan<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScan<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableScan {
						export class ScanObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScan.ScanObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableScanSeed<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScanSeed<any,any>>;
						public constructor(source: io.reactivex.ObservableSource<any>, seedSupplier: java.util.concurrent.Callable<any>, accumulator: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableScanSeed {
						export class ScanSeedObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableScanSeed.ScanSeedObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSequenceEqual<T>  extends io.reactivex.Observable<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqual<any>>;
						public constructor(first: io.reactivex.ObservableSource<any>, second: io.reactivex.ObservableSource<any>, comparer: io.reactivex.functions.BiPredicate<any,any>, bufferSize: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSequenceEqual {
						export class EqualCoordinator<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqual.EqualCoordinator<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class EqualObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqual.EqualObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSequenceEqualSingle<T>  extends io.reactivex.Single<java.lang.Boolean> implements io.reactivex.internal.fuseable.FuseToObservable<java.lang.Boolean>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle<any>>;
						public constructor(first: io.reactivex.ObservableSource<any>, second: io.reactivex.ObservableSource<any>, comparer: io.reactivex.functions.BiPredicate<any,any>, bufferSize: number);
						public fuseToObservable(): io.reactivex.Observable<java.lang.Boolean>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public fuseToObservable(): io.reactivex.Observable<any>;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableSequenceEqualSingle {
						export class EqualCoordinator<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle.EqualCoordinator<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class EqualObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle.EqualObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSerialized<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSerialized<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(upstream: io.reactivex.Observable<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSingleMaybe<T>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSingleMaybe<any>>;
						public constructor();
						public subscribeActual(t: io.reactivex.MaybeObserver<any>): void;
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableSingleMaybe {
						export class SingleElementObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSingleMaybe.SingleElementObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSingleSingle<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSingleSingle<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, defaultValue: any);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableSingleSingle {
						export class SingleElementObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSingleSingle.SingleElementObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSkip<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkip<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, n: number);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSkip {
						export class SkipObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkip.SkipObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSkipLast<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipLast<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, skip: number);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSkipLast {
						export class SkipLastObserver<T>  extends java.util.ArrayDeque<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipLast.SkipLastObserver<any>>;
							public toArray(): any[];
							public removeFirstOccurrence(o: any): boolean;
							public removeLast(): any;
							public element(): any;
							public poll(): any;
							public addFirst(e: any): void;
							public stream(): java.util.stream.Stream<any>;
							public toArray(a: any[]): any[];
							public remove(): any;
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeFirstOccurrence(param0: any): boolean;
							public removeLastOccurrence(o: any): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public toArray(param0: any[]): any[];
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public offer(e: any): boolean;
							public offerFirst(param0: any): boolean;
							public removeLastOccurrence(param0: any): boolean;
							public onError(param0: java.lang.Throwable): void;
							public removeAll(c: java.util.Collection<any>): boolean;
							public peekFirst(): any;
							public descendingIterator(): java.util.Iterator<any>;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public parallelStream(): java.util.stream.Stream<any>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public contains(param0: any): boolean;
							public addLast(e: any): void;
							public offerLast(e: any): boolean;
							public size(): number;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public pollFirst(): any;
							public retainAll(c: java.util.Collection<any>): boolean;
							public push(e: any): void;
							public equals(obj: any): boolean;
							public add(e: any): boolean;
							public isDisposed(): boolean;
							public peek(): any;
							public onNext(t: any): void;
							public add(param0: any): boolean;
							public offerLast(param0: any): boolean;
							public offerFirst(e: any): boolean;
							public getFirst(): any;
							public getLast(): any;
							public removeFirst(): any;
							public push(param0: any): void;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public offer(param0: any): boolean;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public pollLast(): any;
							public removeIf(filter: any /* any*/): boolean;
							public addFirst(param0: any): void;
							public addLast(param0: any): void;
							public pop(): any;
							public peekLast(): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSkipLastTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipLastTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number, bufferSize: boolean);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSkipLastTimed {
						export class SkipLastTimedObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipLastTimed.SkipLastTimedObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSkipUntil<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipUntil<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(child: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSkipUntil {
						export class SkipUntil extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipUntil.SkipUntil>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SkipUntilObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipUntil.SkipUntilObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSkipWhile<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipWhile<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSkipWhile {
						export class SkipWhileObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSkipWhile.SkipWhileObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSubscribeOn<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSubscribeOn<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, scheduler: io.reactivex.Scheduler);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSubscribeOn {
						export class SubscribeOnObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSubscribeOn.SubscribeOnObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SubscribeTask extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSubscribeOn.SubscribeTask>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSwitchIfEmpty<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSwitchIfEmpty {
						export class SwitchIfEmptyObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty.SwitchIfEmptyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableSwitchMap<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSwitchMap<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, mapper: io.reactivex.functions.Function<any,any>, bufferSize: number, delayErrors: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableSwitchMap {
						export class SwitchMapInnerObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSwitchMap.SwitchMapInnerObserver<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class SwitchMapObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableSwitchMap.SwitchMapObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTake<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTake<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, limit: number);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTake {
						export class TakeObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTake.TakeObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeLast<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLast<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, count: number);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeLast {
						export class TakeLastObserver<T>  extends java.util.ArrayDeque<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLast.TakeLastObserver<any>>;
							public toArray(): any[];
							public removeFirstOccurrence(o: any): boolean;
							public removeLast(): any;
							public element(): any;
							public poll(): any;
							public addFirst(e: any): void;
							public stream(): java.util.stream.Stream<any>;
							public toArray(a: any[]): any[];
							public remove(): any;
							public addAll(param0: java.util.Collection<any>): boolean;
							public removeFirstOccurrence(param0: any): boolean;
							public removeLastOccurrence(o: any): boolean;
							public removeAll(param0: java.util.Collection<any>): boolean;
							public toArray(param0: any[]): any[];
							public retainAll(param0: java.util.Collection<any>): boolean;
							public remove(param0: any): boolean;
							public contains(o: any): boolean;
							public containsAll(c: java.util.Collection<any>): boolean;
							public offer(e: any): boolean;
							public offerFirst(param0: any): boolean;
							public removeLastOccurrence(param0: any): boolean;
							public onError(param0: java.lang.Throwable): void;
							public removeAll(c: java.util.Collection<any>): boolean;
							public peekFirst(): any;
							public descendingIterator(): java.util.Iterator<any>;
							public isEmpty(): boolean;
							public equals(param0: any): boolean;
							public parallelStream(): java.util.stream.Stream<any>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public contains(param0: any): boolean;
							public addLast(e: any): void;
							public offerLast(e: any): boolean;
							public size(): number;
							public hashCode(): number;
							public spliterator(): java.util.Spliterator<any>;
							public pollFirst(): any;
							public retainAll(c: java.util.Collection<any>): boolean;
							public push(e: any): void;
							public equals(obj: any): boolean;
							public add(e: any): boolean;
							public isDisposed(): boolean;
							public peek(): any;
							public onNext(t: any): void;
							public add(param0: any): boolean;
							public offerLast(param0: any): boolean;
							public offerFirst(e: any): boolean;
							public getFirst(): any;
							public getLast(): any;
							public removeFirst(): any;
							public push(param0: any): void;
							public iterator(): java.util.Iterator<any>;
							public containsAll(param0: java.util.Collection<any>): boolean;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public offer(param0: any): boolean;
							public addAll(c: java.util.Collection<any>): boolean;
							public remove(o: any): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public pollLast(): any;
							public removeIf(filter: any /* any*/): boolean;
							public addFirst(param0: any): void;
							public addLast(param0: any): void;
							public pop(): any;
							public peekLast(): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeLastOne<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLastOne<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeLastOne {
						export class TakeLastOneObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLastOne.TakeLastOneObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeLastTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLastTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, count: number, param2: number, time: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: number, scheduler: boolean);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeLastTimed {
						export class TakeLastTimedObserver<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeLastTimed.TakeLastTimedObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeUntil<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeUntil<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(child: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeUntil {
						export class TakeUntilMainObserver<T, U>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeUntil.TakeUntilMainObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module TakeUntilMainObserver {
							export class OtherObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeUntil.TakeUntilMainObserver.OtherObserver>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onNext(t: any): void;
								public onError(e: java.lang.Throwable): void;
								public onComplete(): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onNext(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeUntilPredicate<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeUntilPredicate {
						export class TakeUntilPredicateObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate.TakeUntilPredicateObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTakeWhile<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeWhile<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTakeWhile {
						export class TakeWhileObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTakeWhile.TakeWhileObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableThrottleFirstTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableThrottleFirstTimed {
						export class DebounceTimedObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed.DebounceTimedObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableThrottleLatest<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableThrottleLatest<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.Observable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableThrottleLatest {
						export class ThrottleLatestObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableThrottleLatest.ThrottleLatestObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTimeInterval<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.schedulers.Timed<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeInterval<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, unit: java.util.concurrent.TimeUnit, scheduler: io.reactivex.Scheduler);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTimeInterval {
						export class TimeIntervalObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeInterval.TimeIntervalObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTimeout<T, U, V>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeout<any,any,any>>;
						public constructor(source: io.reactivex.Observable<any>, firstTimeoutIndicator: io.reactivex.ObservableSource<any>, itemTimeoutIndicator: io.reactivex.functions.Function<any,any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTimeout {
						export class TimeoutConsumer extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutConsumer>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class TimeoutFallbackObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutFallbackObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onTimeout(idx: number): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onTimeoutError(idx: number, param1: java.lang.Throwable): void;
						}
						export class TimeoutObserver<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onTimeout(idx: number): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onTimeoutError(idx: number, param1: java.lang.Throwable): void;
						}
						export class TimeoutSelectorSupport extends java.lang.Object implements io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutSupport {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutSelectorSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservableTimeout$TimeoutSelectorSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								onTimeoutError(param0: number, param1: java.lang.Throwable): void;
								onTimeout(param0: number): void;
							});
							public constructor();
							public onTimeout(param0: number): void;
							public onTimeoutError(param0: number, param1: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTimeoutTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.Observable<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: io.reactivex.ObservableSource<any>);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTimeoutTimed {
						export class FallbackObserver<T>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed.FallbackObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class TimeoutFallbackObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutFallbackObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onTimeout(idx: number): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class TimeoutObserver<T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onTimeout(idx: number): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onTimeout(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class TimeoutSupport extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutSupport>;
							/**
							 * Constructs a new instance of the io.reactivex.internal.operators.observable.ObservableTimeoutTimed$TimeoutSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
							 */
							public constructor(implementation: {
								onTimeout(param0: number): void;
							});
							public constructor();
							public onTimeout(param0: number): void;
						}
						export class TimeoutTask extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutTask>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableTimer extends io.reactivex.Observable<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimer>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableTimer {
						export class TimerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableTimer.TimerObserver>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
							public setResource(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableToList<T, U>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableToList<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, defaultCapacityHint: number);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ObservableToList {
						export class ToListObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableToList.ToListObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableToListSingle<T, U>  extends io.reactivex.Single<any> implements io.reactivex.internal.fuseable.FuseToObservable<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableToListSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, defaultCapacityHint: number);
						public fuseToObservable(): io.reactivex.Observable<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, collectionSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module ObservableToListSingle {
						export class ToListObserver<T, U>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableToListSingle.ToListObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableUnsubscribeOn<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableUnsubscribeOn<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, scheduler: io.reactivex.Scheduler);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableUnsubscribeOn {
						export class UnsubscribeObserver<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableUnsubscribeOn.UnsubscribeObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module UnsubscribeObserver {
							export class DisposeTask extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableUnsubscribeOn.UnsubscribeObserver.DisposeTask>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableUsing<T, D>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableUsing<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(resourceSupplier: java.util.concurrent.Callable<any>, sourceSupplier: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableUsing {
						export class UsingObserver<T, D>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableUsing.UsingObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWindow<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Observable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindow<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, count: number, param2: number, skip: number);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWindow {
						export class WindowExactObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindow.WindowExactObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
						export class WindowSkipObserver<T>  extends java.util.concurrent.atomic.AtomicBoolean {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindow.WindowSkipObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWindowBoundary<T, B>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Observable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundary<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, other: io.reactivex.ObservableSource<any>, capacityHint: number);
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWindowBoundary {
						export class WindowBoundaryInnerObserver<T, B>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundary.WindowBoundaryInnerObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class WindowBoundaryMainObserver<T, B>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundary.WindowBoundaryMainObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWindowBoundarySelector<T, B, V>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Observable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, open: io.reactivex.ObservableSource<any>, close: io.reactivex.functions.Function<any,any>, bufferSize: number);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWindowBoundarySelector {
						export class OperatorWindowBoundaryCloseObserver<T, V>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.OperatorWindowBoundaryCloseObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class OperatorWindowBoundaryOpenObserver<T, B>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.OperatorWindowBoundaryOpenObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class WindowBoundaryMainObserver<T, B, V>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,io.reactivex.Observable<any>> implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.WindowBoundaryMainObserver<any,any,any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
						}
						export class WindowOperation<T, B>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.WindowOperation<any,any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWindowBoundarySupplier<T, B>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Observable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public constructor(source: io.reactivex.ObservableSource<any>, other: java.util.concurrent.Callable<any>, capacityHint: number);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWindowBoundarySupplier {
						export class WindowBoundaryInnerObserver<T, B>  extends io.reactivex.observers.DisposableObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier.WindowBoundaryInnerObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class WindowBoundaryMainObserver<T, B>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier.WindowBoundaryMainObserver<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWindowTimed<T>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,io.reactivex.Observable<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, timespan: number, param2: number, timeskip: java.util.concurrent.TimeUnit, param4: io.reactivex.Scheduler, unit: number, scheduler: number, maxSize: boolean);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWindowTimed {
						export class WindowExactBoundedObserver<T>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,io.reactivex.Observable<any>> implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowExactBoundedObserver<any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
						}
						export module WindowExactBoundedObserver {
							export class ConsumerIndexHolder extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowExactBoundedObserver.ConsumerIndexHolder>;
								public run(): void;
							}
						}
						export class WindowExactUnboundedObserver<T>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,io.reactivex.Observable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowExactUnboundedObserver<any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
							public run(): void;
						}
						export class WindowSkipObserver<T>  extends io.reactivex.internal.observers.QueueDrainObserver<any,any,io.reactivex.Observable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowSkipObserver<any>>;
							public cancelled(): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public done(): boolean;
							public dispose(): void;
							public accept(a: io.reactivex.Observer<any>, v: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public leave(param0: number): number;
							public onNext(t: any): void;
							public enter(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public error(): java.lang.Throwable;
							public leave(m: number): number;
							public accept(param0: io.reactivex.Observer<any>, param1: any): void;
							public run(): void;
						}
						export module WindowSkipObserver {
							export class CompletionTask extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowSkipObserver.CompletionTask>;
								public run(): void;
							}
							export class SubjectWork<T>  extends java.lang.Object {
								public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowSkipObserver.SubjectWork<any>>;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWithLatestFrom<T, U, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFrom<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.ObservableSource<any>, combiner: io.reactivex.functions.BiFunction<any,any,any>, other: io.reactivex.ObservableSource<any>);
						public source(): io.reactivex.ObservableSource<any>;
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableWithLatestFrom {
						export class WithLatestFromObserver<T, U, R>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFrom.WithLatestFromObserver<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public otherError(e: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public setOther(o: io.reactivex.disposables.Disposable): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class WithLatestFromOtherObserver extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFrom.WithLatestFromOtherObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableWithLatestFromMany<T, R>  extends io.reactivex.internal.operators.observable.AbstractObservableWithUpstream<any,any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFromMany<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public source(): io.reactivex.ObservableSource<any>;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.ObservableSource<any>, otherIterable: java.lang.Iterable<any>, combiner: io.reactivex.functions.Function<any,any>);
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.ObservableSource<any>, otherArray: io.reactivex.ObservableSource<any>[], combiner: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ObservableWithLatestFromMany {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFromMany.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
						export class WithLatestFromObserver<T, R>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFromMany.WithLatestFromObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export class WithLatestInnerObserver extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.Observer<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableWithLatestFromMany.WithLatestInnerObserver>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableZip<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableZip<any,any>>;
						public constructor(sources: io.reactivex.ObservableSource<any>[], sourcesIterable: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>, bufferSize: number, delayError: boolean);
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableZip {
						export class ZipCoordinator<T, R>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableZip.ZipCoordinator<any,any>>;
							public drain(): void;
							public dispose(): void;
							public isDisposed(): boolean;
							public subscribe(sources: io.reactivex.ObservableSource<any>[], bufferSize: number): void;
						}
						export class ZipObserver<T, R>  extends io.reactivex.Observer<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableZip.ZipObserver<any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObservableZipIterable<T, U, V>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableZipIterable<any,any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.Observable<any>, other: java.lang.Iterable<any>, zipper: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribeActual(t: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module ObservableZipIterable {
						export class ZipIterableObserver<T, U, V>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObservableZipIterable.ZipIterableObserver<any,any,any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: T): void;
							public dispose(): void;
							public onNext(t: T): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module observable {
					export class ObserverResourceWrapper<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
						public static class: java.lang.Class<io.reactivex.internal.operators.observable.ObserverResourceWrapper<any>>;
						public setResource(resource: io.reactivex.disposables.Disposable): void;
						public constructor();
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public isDisposed(): boolean;
						public onNext(param0: any): void;
						public onNext(t: any): void;
						public onError(param0: java.lang.Throwable): void;
						public constructor(initialValue: any);
						public dispose(): void;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public constructor(downstream: io.reactivex.Observer<any>);
						public onComplete(): void;
						public onError(t: java.lang.Throwable): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelCollect<T, C>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelCollect<any,any>>;
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, initialCollection: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelCollect {
						export class ParallelCollectSubscriber<T, C>  extends io.reactivex.internal.subscribers.DeferredScalarSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelCollect.ParallelCollectSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelConcatMap<T, R>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelConcatMap<any,any>>;
						public constructor();
						public parallelism(): number;
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, mapper: io.reactivex.functions.Function<any,any>, prefetch: number, errorMode: io.reactivex.internal.util.ErrorMode);
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelDoOnNextTry<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelDoOnNextTry<any>>;
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, onNext: io.reactivex.functions.Consumer<any>, errorHandler: io.reactivex.functions.BiFunction<any,any,io.reactivex.parallel.ParallelFailureHandling>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelDoOnNextTry {
						export class ParallelDoOnNextConditionalSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelDoOnNextTry.ParallelDoOnNextConditionalSubscriber<any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public tryOnNext(t: T): boolean;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class ParallelDoOnNextSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelDoOnNextTry.ParallelDoOnNextSubscriber<any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public tryOnNext(t: T): boolean;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelFilter<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilter<any>>;
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, predicate: io.reactivex.functions.Predicate<any>);
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelFilter {
						export abstract class BaseFilterSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilter.BaseFilterSubscriber<any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class ParallelFilterConditionalSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelFilter.BaseFilterSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilter.ParallelFilterConditionalSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
						}
						export class ParallelFilterSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelFilter.BaseFilterSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilter.ParallelFilterSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelFilterTry<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilterTry<any>>;
						public constructor();
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, predicate: io.reactivex.functions.Predicate<any>, errorHandler: io.reactivex.functions.BiFunction<any,any,io.reactivex.parallel.ParallelFailureHandling>);
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelFilterTry {
						export abstract class BaseFilterSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilterTry.BaseFilterSubscriber<any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class ParallelFilterConditionalSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelFilterTry.BaseFilterSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilterTry.ParallelFilterConditionalSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
						}
						export class ParallelFilterSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelFilterTry.BaseFilterSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFilterTry.ParallelFilterSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public tryOnNext(param0: any): boolean;
							public tryOnNext(t: any): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelFlatMap<T, R>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFlatMap<any,any>>;
						public constructor();
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, mapper: io.reactivex.functions.Function<any,any>, delayError: boolean, maxConcurrency: number, prefetch: number);
						public parallelism(): number;
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelFromArray<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFromArray<any>>;
						public constructor();
						public constructor(sources: org.reactivestreams.Publisher<any>[]);
						public parallelism(): number;
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelFromPublisher<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFromPublisher<any>>;
						public constructor();
						public constructor(source: org.reactivestreams.Publisher<any>, parallelism: number, prefetch: number);
						public parallelism(): number;
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelFromPublisher {
						export class ParallelDispatcher<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFromPublisher.ParallelDispatcher<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
						export module ParallelDispatcher {
							export class RailSubscription extends java.lang.Object implements org.reactivestreams.Subscription {
								public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelFromPublisher.ParallelDispatcher.RailSubscription>;
								public cancel(): void;
								public request(param0: number): void;
								public request(n: number): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelJoin<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelJoin<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, prefetch: number, delayErrors: boolean);
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ParallelJoin {
						export class JoinInnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelJoin.JoinInnerSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public cancel(): boolean;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public requestOne(): void;
							public onNext(t: any): void;
						}
						export class JoinSubscription<T>  extends io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionBase<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscription<any>>;
							public cancel(): void;
							public onComplete(): void;
							public request(n: number): void;
							public onNext(inner: io.reactivex.internal.operators.parallel.ParallelJoin.JoinInnerSubscriber<any>, value: any): void;
							public request(param0: number): void;
							public onError(e: java.lang.Throwable): void;
						}
						export abstract class JoinSubscriptionBase<T>  extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionBase<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
						export class JoinSubscriptionDelayError<T>  extends io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionBase<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionDelayError<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelMap<T, R>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMap<any,any>>;
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, mapper: io.reactivex.functions.Function<any,any>);
					}
					export module ParallelMap {
						export class ParallelMapConditionalSubscriber<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMap.ParallelMapConditionalSubscriber<any,any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public tryOnNext(t: T): boolean;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class ParallelMapSubscriber<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMap.ParallelMapSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelMapTry<T, R>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMapTry<any,any>>;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, mapper: io.reactivex.functions.Function<any,any>, errorHandler: io.reactivex.functions.BiFunction<any,any,io.reactivex.parallel.ParallelFailureHandling>);
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelMapTry {
						export class ParallelMapTryConditionalSubscriber<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMapTry.ParallelMapTryConditionalSubscriber<any,any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public tryOnNext(t: T): boolean;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
						export class ParallelMapTrySubscriber<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelMapTry.ParallelMapTrySubscriber<any,any>>;
							public cancel(): void;
							public tryOnNext(param0: T): boolean;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public tryOnNext(t: T): boolean;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelPeek<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelPeek<any>>;
						public constructor();
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, onNext: io.reactivex.functions.Consumer<any>, onAfterNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onAfterTerminated: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>, onRequest: io.reactivex.functions.LongConsumer, onCancel: io.reactivex.functions.Action);
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelPeek {
						export class ParallelPeekSubscriber<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelPeek.ParallelPeekSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelReduce<T, R>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduce<any,any>>;
						public constructor();
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, initialSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelReduce {
						export class ParallelReduceSubscriber<T, R>  extends io.reactivex.internal.subscribers.DeferredScalarSubscriber<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduce.ParallelReduceSubscriber<any,any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelReduceFull<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduceFull<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ParallelReduceFull {
						export class ParallelReduceFullInnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduceFull.ParallelReduceFullInnerSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
						export class ParallelReduceFullMainSubscriber<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduceFull.ParallelReduceFullMainSubscriber<any>>;
							public cancel(): void;
						}
						export class SlotPair<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelReduceFull.SlotPair<any>>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelRunOn<T>  extends io.reactivex.parallel.ParallelFlowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelRunOn<any>>;
						public constructor();
						public constructor(parent: io.reactivex.parallel.ParallelFlowable<any>, scheduler: io.reactivex.Scheduler, prefetch: number);
						public subscribe(subscribers: org.reactivestreams.Subscriber<any>[]): void;
						public parallelism(): number;
						public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
					}
					export module ParallelRunOn {
						export abstract class BaseRunOnSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelRunOn.BaseRunOnSubscriber<any>>;
							public cancel(): void;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public request(n: number): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public run(): void;
						}
						export class MultiWorkerCallback extends java.lang.Object implements io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelRunOn.MultiWorkerCallback>;
							public onWorker(i: number, w: io.reactivex.Scheduler.Worker): void;
							public onWorker(param0: number, param1: io.reactivex.Scheduler.Worker): void;
						}
						export class RunOnConditionalSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelRunOn.BaseRunOnSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelRunOn.RunOnConditionalSubscriber<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public run(): void;
						}
						export class RunOnSubscriber<T>  extends io.reactivex.internal.operators.parallel.ParallelRunOn.BaseRunOnSubscriber<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelRunOn.RunOnSubscriber<any>>;
							public cancel(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public request(param0: number): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module parallel {
					export class ParallelSortedJoin<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelSortedJoin<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public constructor(source: io.reactivex.parallel.ParallelFlowable<java.util.List<any>>, comparator: java.util.Comparator<any>);
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module ParallelSortedJoin {
						export class SortedJoinInnerSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<java.util.List<any>>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelSortedJoin.SortedJoinInnerSubscriber<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: java.util.List<any>): void;
						}
						export class SortedJoinSubscription<T>  extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription  {
							public static class: java.lang.Class<io.reactivex.internal.operators.parallel.ParallelSortedJoin.SortedJoinSubscription<any>>;
							public cancel(): void;
							public request(n: number): void;
							public request(param0: number): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleAmb<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleAmb<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(sources: io.reactivex.SingleSource<any>[], sourcesIterable: java.lang.Iterable<any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleAmb {
						export class AmbSingleObserver<T>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleAmb.AmbSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleCache<T>  extends io.reactivex.Single<any> implements io.reactivex.SingleObserver<any>  {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleCache<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public onSuccess(value: any): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public onError(param0: java.lang.Throwable): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						public onSuccess(param0: any): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public onError(e: java.lang.Throwable): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
					}
					export module SingleCache {
						export class CacheDisposable<T>  extends java.util.concurrent.atomic.AtomicBoolean implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleCache.CacheDisposable<any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleContains<T>  extends io.reactivex.Single<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleContains<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, value: any, comparer: io.reactivex.functions.BiPredicate<any,any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleContains {
						export class ContainsSingleObserver extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleContains.ContainsSingleObserver>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(v: any): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleCreate<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleCreate<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleOnSubscribe<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleCreate {
						export class Emitter<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleCreate.Emitter<any>>;
							public tryOnError(t: java.lang.Throwable): boolean;
							public onError(t: java.lang.Throwable): void;
							public tryOnError(param0: java.lang.Throwable): boolean;
							public dispose(): void;
							public setDisposable(d: io.reactivex.disposables.Disposable): void;
							public setCancellable(c: io.reactivex.functions.Cancellable): void;
							public isDisposed(): boolean;
							public toString(): string;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public setCancellable(param0: io.reactivex.functions.Cancellable): void;
							public setDisposable(param0: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDefer<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDefer<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(singleSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDelay<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelay<any>>;
						public constructor(source: io.reactivex.SingleSource<any>, time: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: boolean);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDelay {
						export class Delay extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelay.Delay>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module Delay {
							export class OnError extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelay.Delay.OnError>;
								public run(): void;
							}
							export class OnSuccess extends java.lang.Object implements java.lang.Runnable {
								public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelay.Delay.OnSuccess>;
								public run(): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDelayWithCompletable<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithCompletable<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, other: io.reactivex.CompletableSource);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDelayWithCompletable {
						export class OtherObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithCompletable.OtherObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDelayWithObservable<T, U>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithObservable<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, other: io.reactivex.ObservableSource<any>);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDelayWithObservable {
						export class OtherSubscriber<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithObservable.OtherSubscriber<any,any>>;
							public onComplete(): void;
							public onNext(param0: any): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDelayWithPublisher<T, U>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithPublisher<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDelayWithPublisher {
						export class OtherSubscriber<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithPublisher.OtherSubscriber<any,any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onNext(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDelayWithSingle<T, U>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithSingle<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, other: io.reactivex.SingleSource<any>);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDelayWithSingle {
						export class OtherObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDelayWithSingle.OtherObserver<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDematerialize<T, R>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDematerialize<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.Single<any>, selector: io.reactivex.functions.Function<any,io.reactivex.Notification<any>>);
						public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDematerialize {
						export class DematerializeObserver<T, R>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDematerialize.DematerializeObserver<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(t: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDetach<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDetach<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDetach {
						export class DetachSingleObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDetach.DetachSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoAfterSuccess<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoAfterSuccess<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, onAfterSuccess: io.reactivex.functions.Consumer<any>);
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoAfterSuccess {
						export class DoAfterObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoAfterSuccess.DoAfterObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(t: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoAfterTerminate<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoAfterTerminate<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, onAfterTerminate: io.reactivex.functions.Action);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoAfterTerminate {
						export class DoAfterTerminateObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoAfterTerminate.DoAfterTerminateObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(t: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoFinally<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoFinally<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, onFinally: io.reactivex.functions.Action);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoFinally {
						export class DoFinallyObserver<T>  extends java.util.concurrent.atomic.AtomicInteger {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoFinally.DoFinallyObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(t: any): void;
							public isDisposed(): boolean;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnDispose<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnDispose<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>, onDispose: io.reactivex.functions.Action);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoOnDispose {
						export class DoOnDisposeObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.functions.Action> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnDispose.DoOnDisposeObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnError<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnError<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, onError: io.reactivex.functions.Consumer<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoOnError {
						export class DoOnError extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnError.DoOnError>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnEvent<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnEvent<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, onEvent: io.reactivex.functions.BiConsumer<any,any>);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoOnEvent {
						export class DoOnEvent extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnEvent.DoOnEvent>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnSubscribe<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnSubscribe<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, onSubscribe: io.reactivex.functions.Consumer<any>);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoOnSubscribe {
						export class DoOnSubscribeSingleObserver<T>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnSubscribe.DoOnSubscribeSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnSuccess<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnSuccess<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, onSuccess: io.reactivex.functions.Consumer<any>);
					}
					export module SingleDoOnSuccess {
						export class DoOnSuccess extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnSuccess.DoOnSuccess>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleDoOnTerminate<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnTerminate<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, onTerminate: io.reactivex.functions.Action);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleDoOnTerminate {
						export class DoOnTerminate extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleDoOnTerminate.DoOnTerminate>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleEquals<T>  extends io.reactivex.Single<java.lang.Boolean> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleEquals<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(first: io.reactivex.SingleSource<any>, second: io.reactivex.SingleSource<any>);
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleEquals {
						export class InnerObserver<T>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleEquals.InnerObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleError<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleError<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(errorSupplier: java.util.concurrent.Callable<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMap<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMap<any,any>>;
						public constructor();
						public subscribeActual(downstream: io.reactivex.SingleObserver<any>): void;
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleFlatMap {
						export class SingleFlatMapCallback<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMap.SingleFlatMapCallback<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export module SingleFlatMapCallback {
							export class FlatMapSingleObserver<R>  extends io.reactivex.SingleObserver<any> {
								public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMap.SingleFlatMapCallback.FlatMapSingleObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onSuccess(value: any): void;
								public onError(e: java.lang.Throwable): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMapCompletable<T>  extends io.reactivex.Completable {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapCompletable<any>>;
						public subscribeActual(param0: io.reactivex.CompletableObserver): void;
						public constructor();
						public subscribe(param0: io.reactivex.CompletableObserver): void;
						public subscribe(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.CompletableObserver): void;
						public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
					}
					export module SingleFlatMapCompletable {
						export class FlatMapCompletableObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapCompletable.FlatMapCompletableObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMapIterableFlowable<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module SingleFlatMapIterableFlowable {
						export class FlatMapIterableObserver<T, R>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable.FlatMapIterableObserver<any,any>>;
							public cancel(): void;
							public requestFusion(mode: number): number;
							public onError(param0: java.lang.Throwable): void;
							public request(n: number): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public poll(): any;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMapIterableObservable<T, R>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapIterableObservable<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
					}
					export module SingleFlatMapIterableObservable {
						export class FlatMapIterableObserver<T, R>  extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapIterableObservable.FlatMapIterableObserver<any,any>>;
							public requestFusion(mode: number): number;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public clear(): void;
							public isDisposed(): boolean;
							public poll(): any;
							public isEmpty(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMapMaybe<T, R>  extends io.reactivex.Maybe<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapMaybe<any,any>>;
						public constructor();
						public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
						public subscribeActual(downstream: io.reactivex.MaybeObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleFlatMapMaybe {
						export class FlatMapMaybeObserver<R>  extends io.reactivex.MaybeObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapMaybe.FlatMapMaybeObserver<any>>;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class FlatMapSingleObserver<T, R>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapMaybe.FlatMapSingleObserver<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFlatMapPublisher<T, R>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapPublisher<any,any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public subscribeActual(downstream: org.reactivestreams.Subscriber<any>): void;
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module SingleFlatMapPublisher {
						export class SingleFlatMapPublisherObserver<S, T>  extends java.util.concurrent.atomic.AtomicLong {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFlatMapPublisher.SingleFlatMapPublisherObserver<any,any>>;
							public cancel(): void;
							public onComplete(): void;
							public request(n: number): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public request(param0: number): void;
							public onNext(t: any): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onError(e: java.lang.Throwable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFromCallable<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFromCallable<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(callable: java.util.concurrent.Callable<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFromPublisher<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFromPublisher<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(publisher: org.reactivestreams.Publisher<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleFromPublisher {
						export class ToSingleObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFromPublisher.ToSingleObserver<any>>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public onNext(param0: T): void;
							public onNext(t: T): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public isDisposed(): boolean;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleFromUnsafeSource<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleFromUnsafeSource<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleHide<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleHide<any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleHide {
						export class HideSingleObserver<T>  extends java.lang.Object {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleHide.HideSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(param0: T): void;
							public isDisposed(): boolean;
							public onSuccess(value: T): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleInternalHelper extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper>;
						public static emptyThrower(): java.util.concurrent.Callable<any>;
						public static toFlowable(): io.reactivex.functions.Function<any,any>;
						public static toObservable(): io.reactivex.functions.Function<any,any>;
						public static iterableToFlowable(sources: java.lang.Iterable<any>): java.lang.Iterable<any>;
					}
					export module SingleInternalHelper {
						export class NoSuchElementCallable extends java.util.concurrent.Callable<java.util.NoSuchElementException> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper.NoSuchElementCallable>;
							public static INSTANCE: io.reactivex.internal.operators.single.SingleInternalHelper.NoSuchElementCallable;
							public call(): any;
							public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
							public static values(): io.reactivex.internal.operators.single.SingleInternalHelper.NoSuchElementCallable[];
							public call(): java.util.NoSuchElementException;
							public static valueOf(name: string): io.reactivex.internal.operators.single.SingleInternalHelper.NoSuchElementCallable;
						}
						export class ToFlowable extends io.reactivex.functions.Function<io.reactivex.SingleSource<any>,org.reactivestreams.Publisher> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowable>;
							public static INSTANCE: io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowable;
							public static valueOf(name: string): io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowable;
							public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
							public static values(): io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowable[];
							public apply(param0: any): any;
							public apply(v: io.reactivex.SingleSource<any>): org.reactivestreams.Publisher;
						}
						export class ToFlowableIterable<T>  extends java.lang.Iterable<io.reactivex.Flowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowableIterable<any>>;
							public iterator(): java.util.Iterator<any>;
							public spliterator(): java.util.Spliterator<any>;
							public iterator(): java.util.Iterator<io.reactivex.Flowable<any>>;
							public forEach(action: any /* any*/): void;
						}
						export class ToFlowableIterator<T>  extends java.util.Iterator<io.reactivex.Flowable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowableIterator<any>>;
							public hasNext(): boolean;
							public remove(): void;
							public next(): io.reactivex.Flowable<any>;
						}
						export class ToObservable extends io.reactivex.functions.Function<io.reactivex.SingleSource<any>,io.reactivex.Observable<any>> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleInternalHelper.ToObservable>;
							public static INSTANCE: io.reactivex.internal.operators.single.SingleInternalHelper.ToObservable;
							public static valueOf(name: string): io.reactivex.internal.operators.single.SingleInternalHelper.ToObservable;
							public static values(): io.reactivex.internal.operators.single.SingleInternalHelper.ToObservable[];
							public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
							public apply(param0: any): any;
							public apply(v: io.reactivex.SingleSource<any>): io.reactivex.Observable<any>;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleJust<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleJust<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public constructor(value: any);
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleLift<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleLift<any,any>>;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>, onLift: io.reactivex.SingleOperator<any,any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleMap<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleMap<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, mapper: io.reactivex.functions.Function<any,any>);
						public subscribeActual(t: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleMap {
						export class MapSingleObserver<T, R>  extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleMap.MapSingleObserver<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleMaterialize<T>  extends io.reactivex.Single<io.reactivex.Notification<any>> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleMaterialize<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.Single<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleNever extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleNever>;
						public static INSTANCE: io.reactivex.Single<any>;
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleObserveOn<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleObserveOn<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleObserveOn {
						export class ObserveOnSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleObserveOn.ObserveOnSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleOnErrorReturn<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleOnErrorReturn<any>>;
						public constructor(source: io.reactivex.SingleSource<any>, valueSupplier: io.reactivex.functions.Function<any,any>, value: any);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleOnErrorReturn {
						export class OnErrorReturn extends io.reactivex.SingleObserver<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleOnErrorReturn.OnErrorReturn>;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleResumeNext<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleResumeNext<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, nextFunction: io.reactivex.functions.Function<any,any>);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleResumeNext {
						export class ResumeMainSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleResumeNext.ResumeMainSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleSubscribeOn<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleSubscribeOn<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleSubscribeOn {
						export class SubscribeOnObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleSubscribeOn.SubscribeOnObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleTakeUntil<T, U>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTakeUntil<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, other: org.reactivestreams.Publisher<any>);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleTakeUntil {
						export class TakeUntilMainObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTakeUntil.TakeUntilMainObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
						export class TakeUntilOtherSubscriber extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> implements io.reactivex.FlowableSubscriber<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTakeUntil.TakeUntilOtherSubscriber>;
							public onError(t: java.lang.Throwable): void;
							public onComplete(): void;
							public onError(param0: java.lang.Throwable): void;
							public onNext(param0: any): void;
							public onSubscribe(s: org.reactivestreams.Subscription): void;
							public dispose(): void;
							public onSubscribe(param0: org.reactivestreams.Subscription): void;
							public onNext(t: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleTimeout<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTimeout<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(source: io.reactivex.SingleSource<any>, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: io.reactivex.SingleSource<any>);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleTimeout {
						export class TimeoutMainObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTimeout.TimeoutMainObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onSuccess(t: any): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
						}
						export module TimeoutMainObserver {
							export class TimeoutFallbackObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
								public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTimeout.TimeoutMainObserver.TimeoutFallbackObserver<any>>;
								public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
								public onError(param0: java.lang.Throwable): void;
								public onError(e: java.lang.Throwable): void;
								public onSuccess(t: any): void;
								public onSubscribe(d: io.reactivex.disposables.Disposable): void;
								public onSuccess(param0: any): void;
							}
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleTimer extends io.reactivex.Single<java.lang.Long> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTimer>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public constructor(delay: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler);
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleTimer {
						export class TimerDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleTimer.TimerDisposable>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleToFlowable<T>  extends io.reactivex.Flowable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleToFlowable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
						public subscribe(s: org.reactivestreams.Subscriber<any>): void;
						public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module SingleToFlowable {
						export class SingleToFlowableObserver<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleToFlowable.SingleToFlowableObserver<any>>;
							public cancel(): void;
							public onError(param0: java.lang.Throwable): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleToObservable<T>  extends io.reactivex.Observable<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleToObservable<any>>;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
						public constructor();
						public constructor(source: io.reactivex.SingleSource<any>);
						public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
						public subscribe(param0: io.reactivex.Observer<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
						public subscribe(observer: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.Observer<any>): void;
						public static create(downstream: io.reactivex.Observer<any>): io.reactivex.SingleObserver<any>;
						public subscribeActual(param0: io.reactivex.Observer<any>): void;
						public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
					}
					export module SingleToObservable {
						export class SingleToObservableObserver<T>  extends io.reactivex.internal.observers.DeferredScalarDisposable<any> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleToObservable.SingleToObservableObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleUnsubscribeOn<T>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleUnsubscribeOn<any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public constructor(source: io.reactivex.SingleSource<any>, scheduler: io.reactivex.Scheduler);
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleUnsubscribeOn {
						export class UnsubscribeOnSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleUnsubscribeOn.UnsubscribeOnSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public run(): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleUsing<T, U>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleUsing<any,any>>;
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public constructor(resourceSupplier: java.util.concurrent.Callable<any>, singleFunction: io.reactivex.functions.Function<any,any>, disposer: io.reactivex.functions.Consumer<any>, eager: boolean);
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleUsing {
						export class UsingSingleObserver<T, U>  extends java.util.concurrent.atomic.AtomicReference<any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleUsing.UsingSingleObserver<any,any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public isDisposed(): boolean;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleZipArray<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipArray<any,any>>;
						public constructor();
						public constructor(sources: io.reactivex.SingleSource<any>[], zipper: io.reactivex.functions.Function<any,any>);
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleZipArray {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipArray.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
						export class ZipCoordinator<T, R>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipArray.ZipCoordinator<any,any>>;
							public dispose(): void;
							public isDisposed(): boolean;
						}
						export class ZipSingleObserver<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.SingleObserver<any>  {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipArray.ZipSingleObserver<any>>;
							public onError(param0: java.lang.Throwable): void;
							public dispose(): void;
							public onSuccess(param0: any): void;
							public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
							public onError(e: java.lang.Throwable): void;
							public onSubscribe(d: io.reactivex.disposables.Disposable): void;
							public onSuccess(value: any): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module operators {
				export module single {
					export class SingleZipIterable<T, R>  extends io.reactivex.Single<any> {
						public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipIterable<any,any>>;
						public constructor(sources: java.lang.Iterable<any>, zipper: io.reactivex.functions.Function<any,any>);
						public constructor();
						public subscribe(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(param0: io.reactivex.SingleObserver<any>): void;
						public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
						public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
						public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
						public subscribe(): io.reactivex.disposables.Disposable;
					}
					export module SingleZipIterable {
						export class SingletonArrayFunc extends io.reactivex.functions.Function<any,any> {
							public static class: java.lang.Class<io.reactivex.internal.operators.single.SingleZipIterable.SingletonArrayFunc>;
							public apply(t: any): any;
							public apply(param0: any): any;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module queue {
				export class MpscLinkedQueue<T>  extends io.reactivex.internal.fuseable.SimplePlainQueue<any> {
					public static class: java.lang.Class<io.reactivex.internal.queue.MpscLinkedQueue<any>>;
					public poll(): any;
					public offer(v1: any, v2: any): boolean;
					public isEmpty(): boolean;
					public constructor();
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
				}
				export module MpscLinkedQueue {
					export class LinkedQueueNode<E>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.internal.queue.MpscLinkedQueue.LinkedQueueNode<any>> {
						public static class: java.lang.Class<io.reactivex.internal.queue.MpscLinkedQueue.LinkedQueueNode<any>>;
						public getAndNullValue(): any;
						public lpValue(): any;
						public soNext(n: io.reactivex.internal.queue.MpscLinkedQueue.LinkedQueueNode<any>): void;
						public lvNext(): io.reactivex.internal.queue.MpscLinkedQueue.LinkedQueueNode<any>;
						public spValue(newValue: any): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module queue {
				export class SpscArrayQueue<E>  extends java.util.concurrent.atomic.AtomicReferenceArray<any> implements io.reactivex.internal.fuseable.SimplePlainQueue<any>  {
					public static class: java.lang.Class<io.reactivex.internal.queue.SpscArrayQueue<any>>;
					public constructor(length: number);
					public constructor(array: any[]);
					public constructor(capacity: number);
					public offer(v1: any, v2: any): boolean;
					public poll(): any;
					public isEmpty(): boolean;
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module queue {
				export class SpscLinkedArrayQueue<T>  extends io.reactivex.internal.fuseable.SimplePlainQueue<any> {
					public static class: java.lang.Class<io.reactivex.internal.queue.SpscLinkedArrayQueue<any>>;
					public offer(first: any, second: any): boolean;
					public constructor(bufferSize: number);
					public poll(): any;
					public peek(): any;
					public isEmpty(): boolean;
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public size(): number;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export abstract class AbstractDirectTask extends java.util.concurrent.atomic.AtomicReference<java.util.concurrent.Future<any>> {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.AbstractDirectTask>;
					public runnable: java.lang.Runnable;
					public runner: java.lang.Thread;
					public static FINISHED: java.util.concurrent.FutureTask<java.lang.Void>;
					public static DISPOSED: java.util.concurrent.FutureTask<java.lang.Void>;
					public isDisposed(): boolean;
					public setFuture(future: java.util.concurrent.Future<any>): void;
					public dispose(): void;
					public getWrappedRunnable(): java.lang.Runnable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ComputationScheduler extends io.reactivex.Scheduler implements io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ComputationScheduler>;
					public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public shutdown(): void;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public constructor(threadFactory: java.util.concurrent.ThreadFactory);
					public createWorkers(number: number, callback: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
					public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public start(): void;
					public createWorkers(param0: number, param1: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
				}
				export module ComputationScheduler {
					export class EventLoopWorker extends io.reactivex.Scheduler.Worker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ComputationScheduler.EventLoopWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public schedule(action: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public schedule(action: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export class FixedSchedulerPool extends java.lang.Object implements io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ComputationScheduler.FixedSchedulerPool>;
						public shutdown(): void;
						public getEventLoop(): io.reactivex.internal.schedulers.ComputationScheduler.PoolWorker;
						public createWorkers(number: number, callback: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
						public createWorkers(param0: number, param1: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
					}
					export class PoolWorker extends io.reactivex.internal.schedulers.NewThreadWorker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ComputationScheduler.PoolWorker>;
						public isDisposed(): boolean;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class DisposeOnCancel extends java.util.concurrent.Future<any> {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.DisposeOnCancel>;
					public get(): any;
					public isDone(): boolean;
					public isCancelled(): boolean;
					public get(param0: number, param1: java.util.concurrent.TimeUnit): any;
					public cancel(param0: boolean): boolean;
					public get(timeout: number, param1: java.util.concurrent.TimeUnit): any;
					public cancel(mayInterruptIfRunning: boolean): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ExecutorScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler>;
					public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public constructor(executor: java.util.concurrent.Executor, interruptibleWorker: boolean);
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				}
				export module ExecutorScheduler {
					export class DelayedDispose extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.DelayedDispose>;
						public run(): void;
					}
					export class DelayedRunnable extends java.util.concurrent.atomic.AtomicReference<java.lang.Runnable> {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.DelayedRunnable>;
						public run(): void;
						public isDisposed(): boolean;
						public getWrappedRunnable(): java.lang.Runnable;
						public dispose(): void;
					}
					export class ExecutorWorker extends io.reactivex.Scheduler.Worker implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker>;
						public constructor();
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public run(): void;
						public constructor(executor: java.util.concurrent.Executor, interruptibleWorker: boolean);
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export module ExecutorWorker {
						export class BooleanRunnable extends java.util.concurrent.atomic.AtomicBoolean implements java.lang.Runnable, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.BooleanRunnable>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
						}
						export class InterruptibleRunnable extends java.util.concurrent.atomic.AtomicInteger implements java.lang.Runnable, io.reactivex.disposables.Disposable {
							public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.InterruptibleRunnable>;
							public dispose(): void;
							public isDisposed(): boolean;
							public run(): void;
						}
						export class SequentialDispose extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.SequentialDispose>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ImmediateThinScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ImmediateThinScheduler>;
					public static INSTANCE: io.reactivex.Scheduler;
					public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				}
				export module ImmediateThinScheduler {
					export class ImmediateThinWorker extends io.reactivex.Scheduler.Worker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.ImmediateThinScheduler.ImmediateThinWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public schedule(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public schedulePeriodically(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class InstantPeriodicTask extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.InstantPeriodicTask>;
					public isDisposed(): boolean;
					public call(): java.lang.Void;
					public dispose(): void;
					public call(): any;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class IoScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.IoScheduler>;
					public static KEEP_ALIVE_TIME_DEFAULT: number;
					public shutdown(): void;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public constructor(threadFactory: java.util.concurrent.ThreadFactory);
					public size(): number;
					public start(): void;
				}
				export module IoScheduler {
					export class CachedWorkerPool extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.IoScheduler.CachedWorkerPool>;
						public run(): void;
					}
					export class EventLoopWorker extends io.reactivex.Scheduler.Worker implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.IoScheduler.EventLoopWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public run(): void;
						public isDisposed(): boolean;
						public schedule(action: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export class ThreadWorker extends io.reactivex.internal.schedulers.NewThreadWorker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.IoScheduler.ThreadWorker>;
						public isDisposed(): boolean;
						public getExpirationTime(): number;
						public setExpirationTime(expirationTime: number): void;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class NewThreadScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.NewThreadScheduler>;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public constructor(threadFactory: java.util.concurrent.ThreadFactory);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class NewThreadWorker extends io.reactivex.Scheduler.Worker implements io.reactivex.disposables.Disposable {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.NewThreadWorker>;
					public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public schedule(action: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public scheduleActual(run: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.internal.disposables.DisposableContainer): io.reactivex.internal.schedulers.ScheduledRunnable;
					public isDisposed(): boolean;
					public shutdown(): void;
					public constructor();
					public dispose(): void;
					public constructor(threadFactory: java.util.concurrent.ThreadFactory);
					public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public scheduleDirect(run: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class NonBlockingThread extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.NonBlockingThread>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.schedulers.NonBlockingThread interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
					});
					public constructor();
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class RxThreadFactory extends java.util.concurrent.atomic.AtomicLong implements java.util.concurrent.ThreadFactory {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.RxThreadFactory>;
					public constructor(prefix: string);
					public newThread(param0: java.lang.Runnable): java.lang.Thread;
					public constructor(initialValue: number);
					public toString(): string;
					public constructor(prefix: string, priority: number);
					public constructor();
					public newThread(r: java.lang.Runnable): java.lang.Thread;
					public constructor(prefix: string, priority: number, nonBlocking: boolean);
				}
				export module RxThreadFactory {
					export class RxCustomThread extends java.lang.Thread implements io.reactivex.internal.schedulers.NonBlockingThread {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.RxThreadFactory.RxCustomThread>;
						public run(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ScheduledDirectPeriodicTask extends io.reactivex.internal.schedulers.AbstractDirectTask implements java.lang.Runnable {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask>;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public run(): void;
					public dispose(): void;
					public constructor(runnable: java.lang.Runnable);
					public getWrappedRunnable(): java.lang.Runnable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ScheduledDirectTask extends io.reactivex.internal.schedulers.AbstractDirectTask implements java.util.concurrent.Callable<java.lang.Void>  {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ScheduledDirectTask>;
					public isDisposed(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public call(): java.lang.Void;
					public dispose(): void;
					public constructor(runnable: java.lang.Runnable);
					public call(): any;
					public getWrappedRunnable(): java.lang.Runnable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class ScheduledRunnable extends java.util.concurrent.atomic.AtomicReferenceArray<any> {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.ScheduledRunnable>;
					public constructor(length: number);
					public constructor(array: any[]);
					public isDisposed(): boolean;
					public run(): void;
					public dispose(): void;
					public call(): any;
					public setFuture(f: java.util.concurrent.Future<any>): void;
					public constructor(actual: java.lang.Runnable, parent: io.reactivex.internal.disposables.DisposableContainer);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class SchedulerMultiWorkerSupport extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						createWorkers(param0: number, param1: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
					});
					public constructor();
					public createWorkers(param0: number, param1: io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback): void;
				}
				export module SchedulerMultiWorkerSupport {
					export class WorkerCallback extends java.lang.Object {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback>;
						/**
						 * Constructs a new instance of the io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport$WorkerCallback interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
						 */
						public constructor(implementation: {
							onWorker(param0: number, param1: io.reactivex.Scheduler.Worker): void;
						});
						public constructor();
						public onWorker(param0: number, param1: io.reactivex.Scheduler.Worker): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class SchedulerPoolFactory extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerPoolFactory>;
					public static PURGE_ENABLED: boolean;
					public static PURGE_PERIOD_SECONDS: number;
					public static start(): void;
					public static shutdown(): void;
					public static create(factory: java.util.concurrent.ThreadFactory): java.util.concurrent.ScheduledExecutorService;
				}
				export module SchedulerPoolFactory {
					export class ScheduledTask extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerPoolFactory.ScheduledTask>;
						public run(): void;
					}
					export class SystemPropertyAccessor extends io.reactivex.functions.Function<string,string> {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerPoolFactory.SystemPropertyAccessor>;
						public apply(t: string): string;
						public apply(param0: any): any;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class SchedulerWhen extends io.reactivex.Scheduler implements io.reactivex.disposables.Disposable {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen>;
					public isDisposed(): boolean;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public dispose(): void;
					public constructor(combine: io.reactivex.functions.Function<io.reactivex.Flowable<io.reactivex.Flowable<io.reactivex.Completable>>,io.reactivex.Completable>, actualScheduler: io.reactivex.Scheduler);
				}
				export module SchedulerWhen {
					export class CreateWorkerFunction extends io.reactivex.functions.Function<io.reactivex.internal.schedulers.SchedulerWhen.ScheduledAction,io.reactivex.Completable> {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.CreateWorkerFunction>;
						public apply(param0: any): any;
						public apply(action: io.reactivex.internal.schedulers.SchedulerWhen.ScheduledAction): io.reactivex.Completable;
					}
					export module CreateWorkerFunction {
						export class WorkerCompletable extends io.reactivex.Completable {
							public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.CreateWorkerFunction.WorkerCompletable>;
							public subscribe(): io.reactivex.disposables.Disposable;
							public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
							public subscribe(observer: io.reactivex.CompletableObserver): void;
							public subscribeActual(param0: io.reactivex.CompletableObserver): void;
							public subscribeActual(actionCompletable: io.reactivex.CompletableObserver): void;
							public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
							public subscribe(param0: io.reactivex.CompletableObserver): void;
						}
					}
					export class DelayedAction extends io.reactivex.internal.schedulers.SchedulerWhen.ScheduledAction {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.DelayedAction>;
						public isDisposed(): boolean;
						public callActual(param0: io.reactivex.Scheduler.Worker, param1: io.reactivex.CompletableObserver): io.reactivex.disposables.Disposable;
						public callActual(actualWorker: io.reactivex.Scheduler.Worker, actionCompletable: io.reactivex.CompletableObserver): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export class ImmediateAction extends io.reactivex.internal.schedulers.SchedulerWhen.ScheduledAction {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.ImmediateAction>;
						public isDisposed(): boolean;
						public callActual(param0: io.reactivex.Scheduler.Worker, param1: io.reactivex.CompletableObserver): io.reactivex.disposables.Disposable;
						public callActual(actualWorker: io.reactivex.Scheduler.Worker, actionCompletable: io.reactivex.CompletableObserver): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export class OnCompletedAction extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.OnCompletedAction>;
						public run(): void;
					}
					export class QueueWorker extends io.reactivex.Scheduler.Worker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.QueueWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public schedule(action: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public schedule(action: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export abstract class ScheduledAction extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> implements io.reactivex.disposables.Disposable  {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.ScheduledAction>;
						public isDisposed(): boolean;
						public callActual(param0: io.reactivex.Scheduler.Worker, param1: io.reactivex.CompletableObserver): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export class SubscribedDisposable extends java.lang.Object implements io.reactivex.disposables.Disposable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SchedulerWhen.SubscribedDisposable>;
						public isDisposed(): boolean;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class SingleScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.SingleScheduler>;
					public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public shutdown(): void;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public constructor();
					public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public constructor(threadFactory: java.util.concurrent.ThreadFactory);
					public start(): void;
					public schedulePeriodicallyDirect(run: java.lang.Runnable, initialDelay: number, param2: number, period: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				}
				export module SingleScheduler {
					export class ScheduledWorker extends io.reactivex.Scheduler.Worker {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.SingleScheduler.ScheduledWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module schedulers {
				export class TrampolineScheduler extends io.reactivex.Scheduler {
					public static class: java.lang.Class<io.reactivex.internal.schedulers.TrampolineScheduler>;
					public scheduleDirect(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public createWorker(): io.reactivex.Scheduler.Worker;
					public scheduleDirect(run: java.lang.Runnable, delay: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public static instance(): io.reactivex.internal.schedulers.TrampolineScheduler;
				}
				export module TrampolineScheduler {
					export class SleepingRunnable extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.TrampolineScheduler.SleepingRunnable>;
						public run(): void;
					}
					export class TimedRunnable extends java.lang.Comparable<io.reactivex.internal.schedulers.TrampolineScheduler.TimedRunnable> {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.TrampolineScheduler.TimedRunnable>;
						public compareTo(that: io.reactivex.internal.schedulers.TrampolineScheduler.TimedRunnable): number;
					}
					export class TrampolineWorker extends io.reactivex.Scheduler.Worker implements io.reactivex.disposables.Disposable {
						public static class: java.lang.Class<io.reactivex.internal.schedulers.TrampolineScheduler.TrampolineWorker>;
						public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(action: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public isDisposed(): boolean;
						public schedule(action: java.lang.Runnable): io.reactivex.disposables.Disposable;
						public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
						public dispose(): void;
					}
					export module TrampolineWorker {
						export class AppendToQueueTask extends java.lang.Object implements java.lang.Runnable {
							public static class: java.lang.Class<io.reactivex.internal.schedulers.TrampolineScheduler.TrampolineWorker.AppendToQueueTask>;
							public run(): void;
						}
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class BasicFuseableConditionalSubscriber<T, R>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber<any,any>>;
					public downstream: io.reactivex.internal.fuseable.ConditionalSubscriber<any>;
					public upstream: org.reactivestreams.Subscription;
					public qs: io.reactivex.internal.fuseable.QueueSubscription<T>;
					public done: boolean;
					public sourceMode: number;
					public onError(t: java.lang.Throwable): void;
					public isEmpty(): boolean;
					public fail(t: java.lang.Throwable): void;
					public constructor(downstream: io.reactivex.internal.fuseable.ConditionalSubscriber<any>);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onNext(param0: T): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public offer(param0: T): boolean;
					public beforeDownstream(): boolean;
					public afterDownstream(): void;
					public request(n: number): void;
					public tryOnNext(param0: T): boolean;
					public transitiveBoundaryFusion(mode: number): number;
					public clear(): void;
					public requestFusion(param0: number): number;
					public poll(): T;
					public offer(param0: T, param1: T): boolean;
					public offer(v1: R, v2: R): boolean;
					public offer(e: R): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class BasicFuseableSubscriber<T, R>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BasicFuseableSubscriber<any,any>>;
					public downstream: org.reactivestreams.Subscriber<any>;
					public upstream: org.reactivestreams.Subscription;
					public qs: io.reactivex.internal.fuseable.QueueSubscription<T>;
					public done: boolean;
					public sourceMode: number;
					public onError(t: java.lang.Throwable): void;
					public isEmpty(): boolean;
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public fail(t: java.lang.Throwable): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onNext(param0: T): void;
					public onError(param0: java.lang.Throwable): void;
					public request(param0: number): void;
					public offer(param0: T): boolean;
					public beforeDownstream(): boolean;
					public afterDownstream(): void;
					public request(n: number): void;
					public transitiveBoundaryFusion(mode: number): number;
					public clear(): void;
					public requestFusion(param0: number): number;
					public poll(): T;
					public offer(param0: T, param1: T): boolean;
					public offer(v1: R, v2: R): boolean;
					public offer(e: R): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class BlockingBaseSubscriber<T>  extends java.util.concurrent.CountDownLatch implements io.reactivex.FlowableSubscriber<any>  {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BlockingBaseSubscriber<any>>;
					public constructor();
					public constructor(count: number);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public blockingGet(): any;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class BlockingFirstSubscriber<T>  extends io.reactivex.internal.subscribers.BlockingBaseSubscriber<any> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BlockingFirstSubscriber<any>>;
					public onNext(t: any): void;
					public onError(t: java.lang.Throwable): void;
					public constructor();
					public constructor(count: number);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class BlockingLastSubscriber<T>  extends io.reactivex.internal.subscribers.BlockingBaseSubscriber<any> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BlockingLastSubscriber<any>>;
					public onNext(t: any): void;
					public onError(t: java.lang.Throwable): void;
					public constructor();
					public constructor(count: number);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class BlockingSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BlockingSubscriber<any>>;
					public static TERMINATED: any;
					public onError(t: java.lang.Throwable): void;
					public isCancelled(): boolean;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public request(n: number): void;
					public constructor(initialValue: any);
					public constructor();
					public constructor(queue: java.util.Queue<any>);
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class BoundedSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.BoundedSubscriber<any>>;
					public onError(t: java.lang.Throwable): void;
					public dispose(): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public isDisposed(): boolean;
					public request(n: number): void;
					public constructor(initialValue: any);
					public constructor();
					public hasCustomOnError(): boolean;
					public constructor(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>, bufferSize: number);
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class DeferredScalarSubscriber<T, R>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> implements io.reactivex.FlowableSubscriber<any>  {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.DeferredScalarSubscriber<any,any>>;
					public upstream: org.reactivestreams.Subscription;
					public hasValue: boolean;
					public constructor(initialValue: number);
					public onError(t: java.lang.Throwable): void;
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public constructor();
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class ForEachWhileSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.ForEachWhileSubscriber<any>>;
					public onNext(t: any): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public constructor(initialValue: any);
					public constructor();
					public dispose(): void;
					public constructor(onNext: io.reactivex.functions.Predicate<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class FutureSubscriber<T>  extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.FutureSubscriber<any>>;
					public onError(t: java.lang.Throwable): void;
					public isCancelled(): boolean;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public cancel(param0: boolean): boolean;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public get(): any;
					public request(n: number): void;
					public isDone(): boolean;
					public constructor();
					public constructor(count: number);
					public get(param0: number, param1: java.util.concurrent.TimeUnit): any;
					public get(timeout: number, param1: java.util.concurrent.TimeUnit): any;
					public cancel(mayInterruptIfRunning: boolean): boolean;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class InnerQueuedSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.InnerQueuedSubscriber<any>>;
					public requestOne(): void;
					public setDone(): void;
					public onError(t: java.lang.Throwable): void;
					public queue(): io.reactivex.internal.fuseable.SimpleQueue<any>;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public request(n: number): void;
					public isDone(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public constructor(parent: io.reactivex.internal.subscribers.InnerQueuedSubscriberSupport<any>, prefetch: number);
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class InnerQueuedSubscriberSupport<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.InnerQueuedSubscriberSupport<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.subscribers.InnerQueuedSubscriberSupport<any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						innerNext(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>, param1: T): void;
						innerError(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>, param1: java.lang.Throwable): void;
						innerComplete(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>): void;
						drain(): void;
					});
					public constructor();
					public innerComplete(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>): void;
					public innerError(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>, param1: java.lang.Throwable): void;
					public drain(): void;
					public innerNext(param0: io.reactivex.internal.subscribers.InnerQueuedSubscriber<T>, param1: T): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class LambdaSubscriber<T>  extends java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.LambdaSubscriber<any>>;
					public onError(t: java.lang.Throwable): void;
					public dispose(): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public constructor(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>);
					public isDisposed(): boolean;
					public request(n: number): void;
					public constructor(initialValue: any);
					public constructor();
					public hasCustomOnError(): boolean;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class QueueDrainSubscriber<T, U, V>  extends io.reactivex.internal.subscribers.QueueDrainSubscriberPad4 {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriber<any,any,any>>;
					public downstream: org.reactivestreams.Subscriber<any>;
					public queue: io.reactivex.internal.fuseable.SimplePlainQueue<any>;
					public accept(param0: org.reactivestreams.Subscriber<any>, param1: any): boolean;
					public produced(param0: number): number;
					public requested(n: number): void;
					public leave(param0: number): number;
					public leave(m: number): number;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onError(param0: java.lang.Throwable): void;
					public done(): boolean;
					public enter(): boolean;
					public fastPathEmitMax(value: any, delayError: boolean, dispose: io.reactivex.disposables.Disposable): void;
					public requested(): number;
					public accept(a: org.reactivestreams.Subscriber<any>, v: any): boolean;
					public fastPathOrderedEmitMax(value: any, delayError: boolean, dispose: io.reactivex.disposables.Disposable): void;
					public fastEnter(): boolean;
					public produced(n: number): number;
					public constructor(actual: org.reactivestreams.Subscriber<any>, queue: io.reactivex.internal.fuseable.SimplePlainQueue<any>);
					public cancelled(): boolean;
					public error(): java.lang.Throwable;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class QueueDrainSubscriberPad0 extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriberPad0>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class QueueDrainSubscriberPad2 extends io.reactivex.internal.subscribers.QueueDrainSubscriberWip {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriberPad2>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class QueueDrainSubscriberPad3 extends io.reactivex.internal.subscribers.QueueDrainSubscriberPad2 {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriberPad3>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class QueueDrainSubscriberPad4 extends io.reactivex.internal.subscribers.QueueDrainSubscriberPad3 {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriberPad4>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class QueueDrainSubscriberWip extends io.reactivex.internal.subscribers.QueueDrainSubscriberPad0 {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.QueueDrainSubscriberWip>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export abstract class SinglePostCompleteSubscriber<T, R>  extends java.util.concurrent.atomic.AtomicLong {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.SinglePostCompleteSubscriber<any,any>>;
					public downstream: org.reactivestreams.Subscriber<any>;
					public upstream: org.reactivestreams.Subscription;
					public value: any;
					public produced: number;
					public constructor(initialValue: number);
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public complete(n: any): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public onDrop(n: any): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public request(n: number): void;
					public constructor();
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class StrictSubscriber<T>  extends java.util.concurrent.atomic.AtomicInteger {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.StrictSubscriber<any>>;
					public constructor(initialValue: number);
					public onError(t: java.lang.Throwable): void;
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public cancel(): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public request(n: number): void;
					public constructor();
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscribers {
				export class SubscriberResourceWrapper<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.subscribers.SubscriberResourceWrapper<any>>;
					public onError(t: java.lang.Throwable): void;
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public dispose(): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public cancel(): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public setResource(resource: io.reactivex.disposables.Disposable): void;
					public request(param0: number): void;
					public onError(param0: java.lang.Throwable): void;
					public onNext(t: any): void;
					public isDisposed(): boolean;
					public request(n: number): void;
					public constructor(initialValue: any);
					public constructor();
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class ArrayCompositeSubscription extends java.util.concurrent.atomic.AtomicReferenceArray<org.reactivestreams.Subscription> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.ArrayCompositeSubscription>;
					public constructor(length: number);
					public constructor(array: any[]);
					public constructor(capacity: number);
					public isDisposed(): boolean;
					public dispose(): void;
					public replaceResource(index: number, resource: org.reactivestreams.Subscription): org.reactivestreams.Subscription;
					public setResource(index: number, resource: org.reactivestreams.Subscription): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class AsyncSubscription extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription, io.reactivex.disposables.Disposable {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.AsyncSubscription>;
					public constructor(initialValue: number);
					public isDisposed(): boolean;
					public request(n: number): void;
					public setSubscription(s: org.reactivestreams.Subscription): void;
					public constructor();
					public constructor(resource: io.reactivex.disposables.Disposable);
					public dispose(): void;
					public cancel(): void;
					public replaceResource(r: io.reactivex.disposables.Disposable): boolean;
					public setResource(r: io.reactivex.disposables.Disposable): boolean;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export abstract class BasicIntQueueSubscription<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.internal.fuseable.QueueSubscription<any>  {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any>>;
					public constructor(initialValue: number);
					public offer(v1: any, v2: any): boolean;
					public poll(): any;
					public isEmpty(): boolean;
					public constructor();
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public cancel(): void;
					public requestFusion(param0: number): number;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export abstract class BasicQueueSubscription<T>  extends java.util.concurrent.atomic.AtomicLong implements io.reactivex.internal.fuseable.QueueSubscription<any>  {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.BasicQueueSubscription<any>>;
					public constructor(initialValue: number);
					public offer(v1: any, v2: any): boolean;
					public poll(): any;
					public isEmpty(): boolean;
					public constructor();
					public offer(param0: any, param1: any): boolean;
					public clear(): void;
					public cancel(): void;
					public requestFusion(param0: number): number;
					public offer(e: any): boolean;
					public offer(param0: any): boolean;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class BooleanSubscription extends java.util.concurrent.atomic.AtomicBoolean implements org.reactivestreams.Subscription {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.BooleanSubscription>;
					public toString(): string;
					public request(n: number): void;
					public constructor();
					public isCancelled(): boolean;
					public cancel(): void;
					public constructor(initialValue: boolean);
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class DeferredScalarSubscription<T>  extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.DeferredScalarSubscription<any>>;
					public downstream: org.reactivestreams.Subscriber<any>;
					public value: any;
					public constructor(initialValue: number);
					public poll(): any;
					public request(n: number): void;
					public requestFusion(mode: number): number;
					public isEmpty(): boolean;
					public constructor(downstream: org.reactivestreams.Subscriber<any>);
					public constructor();
					public isCancelled(): boolean;
					public clear(): void;
					public cancel(): void;
					public tryCancel(): boolean;
					public complete(v: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class EmptySubscription extends io.reactivex.internal.fuseable.QueueSubscription<any> {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.EmptySubscription>;
					public static INSTANCE: io.reactivex.internal.subscriptions.EmptySubscription;
					public offer(v1: any, v2: any): boolean;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public isEmpty(): boolean;
					public static values(): io.reactivex.internal.subscriptions.EmptySubscription[];
					public cancel(): void;
					public offer(value: any): boolean;
					public request(param0: number): void;
					public static valueOf(name: string): io.reactivex.internal.subscriptions.EmptySubscription;
					public toString(): string;
					public poll(): any;
					public request(n: number): void;
					public requestFusion(mode: number): number;
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public requestFusion(param0: number): number;
					public offer(param0: any): boolean;
					public static error(e: java.lang.Throwable, s: org.reactivestreams.Subscriber<any>): void;
					public static complete(s: org.reactivestreams.Subscriber<any>): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class ScalarSubscription<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.internal.fuseable.QueueSubscription<any>  {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.ScalarSubscription<any>>;
					public constructor(initialValue: number);
					public offer(v1: any, v2: any): boolean;
					public isEmpty(): boolean;
					public isCancelled(): boolean;
					public constructor(subscriber: org.reactivestreams.Subscriber<any>, value: any);
					public cancel(): void;
					public offer(e: any): boolean;
					public request(param0: number): void;
					public poll(): any;
					public request(n: number): void;
					public requestFusion(mode: number): number;
					public constructor();
					public clear(): void;
					public offer(param0: any, param1: any): boolean;
					public requestFusion(param0: number): number;
					public offer(param0: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class SubscriptionArbiter extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.SubscriptionArbiter>;
					public unbounded: boolean;
					public constructor(initialValue: number);
					public request(n: number): void;
					public setSubscription(s: org.reactivestreams.Subscription): void;
					public constructor();
					public isCancelled(): boolean;
					public cancel(): void;
					public isUnbounded(): boolean;
					public request(param0: number): void;
					public constructor(cancelOnReplace: boolean);
					public produced(n: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module subscriptions {
				export class SubscriptionHelper extends org.reactivestreams.Subscription {
					public static class: java.lang.Class<io.reactivex.internal.subscriptions.SubscriptionHelper>;
					public static CANCELLED: io.reactivex.internal.subscriptions.SubscriptionHelper;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static deferredRequest(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, requested: java.util.concurrent.atomic.AtomicLong, n: number): void;
					public static valueOf(name: string): io.reactivex.internal.subscriptions.SubscriptionHelper;
					public cancel(): void;
					public static replace(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, s: org.reactivestreams.Subscription): boolean;
					public request(param0: number): void;
					public static set(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, s: org.reactivestreams.Subscription): boolean;
					public static cancel(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>): boolean;
					public static deferredSetOnce(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, requested: java.util.concurrent.atomic.AtomicLong, s: org.reactivestreams.Subscription): boolean;
					public request(n: number): void;
					public static values(): io.reactivex.internal.subscriptions.SubscriptionHelper[];
					public static setOnce(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, s: org.reactivestreams.Subscription): boolean;
					public static setOnce(field: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, s: org.reactivestreams.Subscription, request: number): boolean;
					public static validate(current: org.reactivestreams.Subscription, next: org.reactivestreams.Subscription): boolean;
					public static validate(n: number): boolean;
					public static reportSubscriptionSet(): void;
					public static reportMoreProduced(n: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class AppendOnlyLinkedArrayList<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.AppendOnlyLinkedArrayList<any>>;
					public constructor(capacity: number);
					public accept(subscriber: org.reactivestreams.Subscriber): boolean;
					public forEachWhile(state: any, consumer: io.reactivex.functions.BiPredicate<any,any>): void;
					public setFirst(value: T): void;
					public forEachWhile(consumer: io.reactivex.internal.util.AppendOnlyLinkedArrayList.NonThrowingPredicate<any>): void;
					public add(value: T): void;
					public accept(observer: io.reactivex.Observer<any>): boolean;
				}
				export module AppendOnlyLinkedArrayList {
					export class NonThrowingPredicate<T>  extends io.reactivex.functions.Predicate<any> {
						public static class: java.lang.Class<io.reactivex.internal.util.AppendOnlyLinkedArrayList.NonThrowingPredicate<any>>;
						/**
						 * Constructs a new instance of the io.reactivex.internal.util.AppendOnlyLinkedArrayList$NonThrowingPredicate interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
						 */
						public constructor(implementation: {
							test(param0: any): boolean;
							test(param0: any): boolean;
						});
						public constructor();
						public test(param0: any): boolean;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ArrayListSupplier {
					public static class: java.lang.Class<io.reactivex.internal.util.ArrayListSupplier>;
					public static INSTANCE: io.reactivex.internal.util.ArrayListSupplier;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static asCallable(): java.util.concurrent.Callable<any>;
					public static asFunction(): io.reactivex.functions.Function<any,any>;
					public apply(o: any): java.util.List<any>;
					public static values(): io.reactivex.internal.util.ArrayListSupplier[];
					public call(): any;
					public apply(param0: any): any;
					public static valueOf(name: string): io.reactivex.internal.util.ArrayListSupplier;
					public call(): java.util.List<any>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class AtomicThrowable extends java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> {
					public static class: java.lang.Class<io.reactivex.internal.util.AtomicThrowable>;
					public addThrowable(t: java.lang.Throwable): boolean;
					public isTerminated(): boolean;
					public constructor(initialValue: any);
					public constructor();
					public terminate(): java.lang.Throwable;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class BackpressureHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.BackpressureHelper>;
					public static addCap(a: number, param1: number): number;
					public static add(requested: java.util.concurrent.atomic.AtomicLong, n: number): number;
					public static multiplyCap(a: number, param1: number): number;
					public static producedCancel(requested: java.util.concurrent.atomic.AtomicLong, n: number): number;
					public static addCancel(requested: java.util.concurrent.atomic.AtomicLong, n: number): number;
					public static produced(requested: java.util.concurrent.atomic.AtomicLong, n: number): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class BlockingHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.BlockingHelper>;
					public static awaitForComplete(latch: java.util.concurrent.CountDownLatch, subscription: io.reactivex.disposables.Disposable): void;
					public static verifyNonBlocking(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class BlockingIgnoringReceiver extends java.util.concurrent.CountDownLatch {
					public static class: java.lang.Class<io.reactivex.internal.util.BlockingIgnoringReceiver>;
					public error: java.lang.Throwable;
					public accept(param0: any): void;
					public constructor();
					public run(): void;
					public constructor(count: number);
					public accept(e: java.lang.Throwable): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ConnectConsumer extends io.reactivex.functions.Consumer<io.reactivex.disposables.Disposable> {
					public static class: java.lang.Class<io.reactivex.internal.util.ConnectConsumer>;
					public disposable: io.reactivex.disposables.Disposable;
					public accept(param0: any): void;
					public constructor();
					public accept(t: io.reactivex.disposables.Disposable): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class EmptyComponent {
					public static class: java.lang.Class<io.reactivex.internal.util.EmptyComponent>;
					public static INSTANCE: io.reactivex.internal.util.EmptyComponent;
					public onSuccess(value: any): void;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public onError(t: java.lang.Throwable): void;
					public static values(): io.reactivex.internal.util.EmptyComponent[];
					public dispose(): void;
					public cancel(): void;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public static asSubscriber(): org.reactivestreams.Subscriber;
					public onError(param0: java.lang.Throwable): void;
					public request(param0: number): void;
					public onSuccess(param0: any): void;
					public static valueOf(name: string): io.reactivex.internal.util.EmptyComponent;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public isDisposed(): boolean;
					public request(n: number): void;
					public static asObserver(): io.reactivex.Observer<any>;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class EndConsumerHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.EndConsumerHelper>;
					public static validate(upstream: io.reactivex.disposables.Disposable, next: io.reactivex.disposables.Disposable, observer: java.lang.Class<any>): boolean;
					public static validate(upstream: org.reactivestreams.Subscription, next: org.reactivestreams.Subscription, subscriber: java.lang.Class<any>): boolean;
					public static setOnce(upstream: java.util.concurrent.atomic.AtomicReference<org.reactivestreams.Subscription>, next: org.reactivestreams.Subscription, subscriber: java.lang.Class<any>): boolean;
					public static setOnce(upstream: java.util.concurrent.atomic.AtomicReference<io.reactivex.disposables.Disposable>, next: io.reactivex.disposables.Disposable, observer: java.lang.Class<any>): boolean;
					public static composeMessage(consumer: string): string;
					public static reportDoubleSubscription(consumer: java.lang.Class<any>): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ErrorMode {
					public static class: java.lang.Class<io.reactivex.internal.util.ErrorMode>;
					public static IMMEDIATE: io.reactivex.internal.util.ErrorMode;
					public static BOUNDARY: io.reactivex.internal.util.ErrorMode;
					public static END: io.reactivex.internal.util.ErrorMode;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static valueOf(name: string): io.reactivex.internal.util.ErrorMode;
					public static values(): io.reactivex.internal.util.ErrorMode[];
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ExceptionHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.ExceptionHelper>;
					public static TERMINATED: java.lang.Throwable;
					public static terminate(field: java.util.concurrent.atomic.AtomicReference<any>): java.lang.Throwable;
					public static flatten(t: java.lang.Throwable): java.util.List<java.lang.Throwable>;
					public static timeoutMessage(timeout: number, param1: java.util.concurrent.TimeUnit): string;
					public static throwIfThrowable(e: java.lang.Throwable): java.lang.Exception;
					public static addThrowable(field: java.util.concurrent.atomic.AtomicReference<any>, exception: java.lang.Throwable): boolean;
					public static wrapOrThrow(error: java.lang.Throwable): java.lang.RuntimeException;
				}
				export module ExceptionHelper {
					export class Termination extends java.lang.Throwable {
						public static class: java.lang.Class<io.reactivex.internal.util.ExceptionHelper.Termination>;
						public fillInStackTrace(): java.lang.Throwable;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class HalfSerializer extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.HalfSerializer>;
					public static onError(subscriber: org.reactivestreams.Subscriber<any>, ex: java.lang.Throwable, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
					public static onError(observer: io.reactivex.Observer<any>, ex: java.lang.Throwable, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
					public static onNext(subscriber: org.reactivestreams.Subscriber, value: any, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
					public static onComplete(observer: io.reactivex.Observer<any>, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
					public static onNext(observer: io.reactivex.Observer<any>, value: any, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
					public static onComplete(subscriber: org.reactivestreams.Subscriber<any>, wip: java.util.concurrent.atomic.AtomicInteger, error: io.reactivex.internal.util.AtomicThrowable): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class HashMapSupplier extends java.util.concurrent.Callable<java.util.Map<any,any>> {
					public static class: java.lang.Class<io.reactivex.internal.util.HashMapSupplier>;
					public static INSTANCE: io.reactivex.internal.util.HashMapSupplier;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static asCallable(): java.util.concurrent.Callable<any>;
					public static valueOf(name: string): io.reactivex.internal.util.HashMapSupplier;
					public static values(): io.reactivex.internal.util.HashMapSupplier[];
					public call(): any;
					public call(): java.util.Map<any,any>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class LinkedArrayList extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.LinkedArrayList>;
					public toString(): string;
					public constructor(capacityHint: number);
					public head(): any[];
					public size(): number;
					public add(o: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ListAddBiConsumer extends io.reactivex.functions.BiFunction<java.util.List<any>,any,java.util.List<any>> {
					public static class: java.lang.Class<io.reactivex.internal.util.ListAddBiConsumer>;
					public static INSTANCE: io.reactivex.internal.util.ListAddBiConsumer;
					public static instance(): io.reactivex.functions.BiFunction<any,any,any>;
					public apply(param0: any, param1: any): any;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static valueOf(name: string): io.reactivex.internal.util.ListAddBiConsumer;
					public apply(t1: java.util.List<any>, t2: any): java.util.List<any>;
					public static values(): io.reactivex.internal.util.ListAddBiConsumer[];
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class MergerBiFunction<T>  extends io.reactivex.functions.BiFunction<java.util.List<any>,java.util.List<any>,java.util.List<any>> {
					public static class: java.lang.Class<io.reactivex.internal.util.MergerBiFunction<any>>;
					public apply(param0: any, param1: any): any;
					public apply(a: java.util.List<any>, b: java.util.List<any>): java.util.List<any>;
					public constructor(comparator: java.util.Comparator<any>);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class NotificationLite {
					public static class: java.lang.Class<io.reactivex.internal.util.NotificationLite>;
					public static COMPLETE: io.reactivex.internal.util.NotificationLite;
					public static isDisposable(o: any): boolean;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static getValue(o: any): any;
					public static getError(o: any): java.lang.Throwable;
					public static next(value: any): any;
					public static isComplete(o: any): boolean;
					public static values(): io.reactivex.internal.util.NotificationLite[];
					public static accept(o: any, observer: io.reactivex.Observer<any>): boolean;
					public static isError(o: any): boolean;
					public static acceptFull(o: any, s: org.reactivestreams.Subscriber): boolean;
					public toString(): string;
					public static valueOf(name: string): io.reactivex.internal.util.NotificationLite;
					public static getSubscription(o: any): org.reactivestreams.Subscription;
					public static accept(o: any, s: org.reactivestreams.Subscriber): boolean;
					public static error(e: java.lang.Throwable): any;
					public static complete(): any;
					public static isSubscription(o: any): boolean;
					public static disposable(d: io.reactivex.disposables.Disposable): any;
					public static acceptFull(o: any, observer: io.reactivex.Observer<any>): boolean;
					public static subscription(s: org.reactivestreams.Subscription): any;
					public static getDisposable(o: any): io.reactivex.disposables.Disposable;
				}
				export module NotificationLite {
					export class DisposableNotification extends java.lang.Object implements java.io.Serializable {
						public static class: java.lang.Class<io.reactivex.internal.util.NotificationLite.DisposableNotification>;
						public toString(): string;
					}
					export class ErrorNotification extends java.lang.Object implements java.io.Serializable {
						public static class: java.lang.Class<io.reactivex.internal.util.NotificationLite.ErrorNotification>;
						public equals(obj: any): boolean;
						public hashCode(): number;
						public toString(): string;
					}
					export class SubscriptionNotification extends java.lang.Object implements java.io.Serializable {
						public static class: java.lang.Class<io.reactivex.internal.util.NotificationLite.SubscriptionNotification>;
						public toString(): string;
					}
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class ObservableQueueDrain<T, U>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.ObservableQueueDrain<any,any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.util.ObservableQueueDrain<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						cancelled(): boolean;
						done(): boolean;
						error(): java.lang.Throwable;
						enter(): boolean;
						leave(param0: number): number;
						accept(param0: io.reactivex.Observer<any>, param1: T): void;
					});
					public constructor();
					public leave(param0: number): number;
					public accept(param0: io.reactivex.Observer<any>, param1: T): void;
					public cancelled(): boolean;
					public error(): java.lang.Throwable;
					public done(): boolean;
					public enter(): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class OpenHashSet<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.OpenHashSet<any>>;
					public remove(value: T): boolean;
					public constructor(capacity: number);
					public add(value: T): boolean;
					public constructor(capacity: number, loadFactor: number);
					public constructor();
					public keys(): any[];
					public size(): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class Pow2 extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.Pow2>;
					public static isPowerOfTwo(value: number): boolean;
					public static roundToPowerOfTwo(value: number): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class QueueDrain<T, U>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.QueueDrain<any,any>>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.util.QueueDrain<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						cancelled(): boolean;
						done(): boolean;
						error(): java.lang.Throwable;
						enter(): boolean;
						requested(): number;
						produced(param0: number): number;
						leave(param0: number): number;
						accept(param0: org.reactivestreams.Subscriber<any>, param1: T): boolean;
					});
					public constructor();
					public produced(param0: number): number;
					public leave(param0: number): number;
					public accept(param0: org.reactivestreams.Subscriber<any>, param1: T): boolean;
					public cancelled(): boolean;
					public error(): java.lang.Throwable;
					public done(): boolean;
					public enter(): boolean;
					public requested(): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class QueueDrainHelper extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.internal.util.QueueDrainHelper>;
					public static checkTerminated(d: boolean, empty: boolean, s: org.reactivestreams.Subscriber, delayError: boolean, q: io.reactivex.internal.fuseable.SimpleQueue<any>, qd: io.reactivex.internal.util.QueueDrain<any,any>): boolean;
					public static request(s: org.reactivestreams.Subscription, prefetch: number): void;
					public static postCompleteRequest(n: number, param1: org.reactivestreams.Subscriber, actual: java.util.Queue<any>, queue: java.util.concurrent.atomic.AtomicLong, state: io.reactivex.functions.BooleanSupplier): boolean;
					public static postComplete(actual: org.reactivestreams.Subscriber, queue: java.util.Queue<any>, state: java.util.concurrent.atomic.AtomicLong, isCancelled: io.reactivex.functions.BooleanSupplier): void;
					public static drainLoop(q: io.reactivex.internal.fuseable.SimplePlainQueue<any>, a: io.reactivex.Observer<any>, delayError: boolean, dispose: io.reactivex.disposables.Disposable, qd: io.reactivex.internal.util.ObservableQueueDrain<any,any>): void;
					public static checkTerminated(d: boolean, empty: boolean, observer: io.reactivex.Observer<any>, delayError: boolean, q: io.reactivex.internal.fuseable.SimpleQueue<any>, disposable: io.reactivex.disposables.Disposable, qd: io.reactivex.internal.util.ObservableQueueDrain<any,any>): boolean;
					public static drainMaxLoop(q: io.reactivex.internal.fuseable.SimplePlainQueue<any>, a: org.reactivestreams.Subscriber, delayError: boolean, dispose: io.reactivex.disposables.Disposable, qd: io.reactivex.internal.util.QueueDrain<any,any>): void;
					public static createQueue(capacityHint: number): io.reactivex.internal.fuseable.SimpleQueue<any>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class SorterFunction<T>  extends io.reactivex.functions.Function<java.util.List<any>,java.util.List<any>> {
					public static class: java.lang.Class<io.reactivex.internal.util.SorterFunction<any>>;
					public apply(t: java.util.List<any>): java.util.List<any>;
					public apply(param0: any): any;
					public constructor(comparator: java.util.Comparator<any>);
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class SuppressAnimalSniffer extends java.lang.Object implements java.lang.annotation.Annotation {
					public static class: java.lang.Class<io.reactivex.internal.util.SuppressAnimalSniffer>;
					/**
					 * Constructs a new instance of the io.reactivex.internal.util.SuppressAnimalSniffer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						equals(param0: any): boolean;
						hashCode(): number;
						toString(): string;
						annotationType(): java.lang.Class<any>;
					});
					public constructor();
					public equals(param0: any): boolean;
					public equals(obj: any): boolean;
					public toString(): string;
					public annotationType(): java.lang.Class<any>;
					public hashCode(): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module internal {
			export module util {
				export class VolatileSizeArrayList<T>  extends java.util.concurrent.atomic.AtomicInteger {
					public static class: java.lang.Class<io.reactivex.internal.util.VolatileSizeArrayList<any>>;
					public isEmpty(): boolean;
					public spliterator(): java.util.Spliterator<any>;
					public set(newValue: number): void;
					public size(): number;
					public lastIndexOf(param0: any): number;
					public lastIndexOf(o: any): number;
					public iterator(): java.util.Iterator<any>;
					public constructor();
					public toArray(param0: any[]): any[];
					public remove(o: any): boolean;
					public get(param0: number): any;
					public listIterator(index: number): java.util.ListIterator<any>;
					public toArray(a: any[]): any[];
					public constructor(initialValue: number);
					public toArray(): any[];
					public add(param0: number, param1: any): void;
					public sort(c: java.util.Comparator<any>): void;
					public add(index: number, element: any): void;
					public set(param0: number, param1: any): any;
					public replaceAll(operator: any /* any*/): void;
					public addAll(param0: java.util.Collection<any>): boolean;
					public equals(obj: any): boolean;
					public add(param0: any): boolean;
					public subList(fromIndex: number, toIndex: number): java.util.List<any>;
					public containsAll(param0: java.util.Collection<any>): boolean;
					public addAll(c: java.util.Collection<any>): boolean;
					public get(index: number): any;
					public set(index: number, element: any): any;
					public remove(index: number): any;
					public contains(o: any): boolean;
					public remove(param0: number): any;
					public toString(): string;
					public removeAll(c: java.util.Collection<any>): boolean;
					public constructor(initialCapacity: number);
					public clear(): void;
					public subList(param0: number, param1: number): java.util.List<any>;
					public listIterator(param0: number): java.util.ListIterator<any>;
					public containsAll(c: java.util.Collection<any>): boolean;
					public hashCode(): number;
					public contains(param0: any): boolean;
					public forEach(action: any /* any*/): void;
					public remove(param0: any): boolean;
					public removeAll(param0: java.util.Collection<any>): boolean;
					public parallelStream(): java.util.stream.Stream<any>;
					public add(e: any): boolean;
					public addAll(param0: number, param1: java.util.Collection<any>): boolean;
					public retainAll(c: java.util.Collection<any>): boolean;
					public retainAll(param0: java.util.Collection<any>): boolean;
					public indexOf(o: any): number;
					public indexOf(param0: any): number;
					public equals(param0: any): boolean;
					public removeIf(filter: any /* any*/): boolean;
					public addAll(index: number, c: java.util.Collection<any>): boolean;
					public get(): number;
					public listIterator(): java.util.ListIterator<any>;
					public stream(): java.util.stream.Stream<any>;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observables {
			export abstract class ConnectableObservable<T>  extends io.reactivex.Observable<any> {
				public static class: java.lang.Class<io.reactivex.observables.ConnectableObservable<any>>;
				public autoConnect(numberOfSubscribers: number): io.reactivex.Observable<any>;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public refCount(subscriberCount: number): io.reactivex.Observable<any>;
				public connect(param0: io.reactivex.functions.Consumer<any>): void;
				public refCount(subscriberCount: number, timeout: number, param2: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public refCount(): io.reactivex.Observable<any>;
				public autoConnect(): io.reactivex.Observable<any>;
				public refCount(timeout: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public autoConnect(numberOfSubscribers: number, connection: io.reactivex.functions.Consumer<any>): io.reactivex.Observable<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public refCount(subscriberCount: number, timeout: number, param2: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.Observable<any>;
				public subscribe(): io.reactivex.disposables.Disposable;
				public connect(): io.reactivex.disposables.Disposable;
				public refCount(timeout: number, param1: java.util.concurrent.TimeUnit): io.reactivex.Observable<any>;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observables {
			export abstract class GroupedObservable<K, T>  extends io.reactivex.Observable<any> {
				public static class: java.lang.Class<io.reactivex.observables.GroupedObservable<any,any>>;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public getKey(): any;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public constructor(key: any);
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class BaseTestConsumer<T, U>  extends io.reactivex.disposables.Disposable {
				public static class: java.lang.Class<io.reactivex.observers.BaseTestConsumer<any,any>>;
				public done: java.util.concurrent.CountDownLatch;
				public checkSubscriptionOnce: boolean;
				public initialFusionMode: number;
				public establishedFusionMode: number;
				public tag: string;
				public timeout: boolean;
				public completions(): number;
				public assertNoErrors(): any;
				public isTerminated(): boolean;
				public assertNever(value: any): any;
				public isDisposed(): boolean;
				public withTag(tag: string): any;
				public constructor();
				public assertValueSetOnly(expected: java.util.Collection<any>): any;
				public valueCount(): number;
				public static valueAndClass(o: any): string;
				public fail(message: string): java.lang.AssertionError;
				public assertValueCount(count: number): any;
				public assertError(errorClass: java.lang.Class<any>): any;
				public assertFailure(error: java.lang.Class<any>, ...values: any[]): any;
				public assertNotSubscribed(): any;
				public errorCount(): number;
				public await(): any;
				public awaitDone(time: number, param1: java.util.concurrent.TimeUnit): any;
				public awaitCount(atLeast: number, waitStrategy: java.lang.Runnable, timeoutMillis: number): any;
				public assertNoTimeout(): any;
				public assertNotComplete(): any;
				public assertFailureAndMessage(error: java.lang.Class<any>, message: string, ...values: any[]): any;
				public dispose(): void;
				public assertComplete(): any;
				public assertValue(value: any): any;
				public assertTerminated(): any;
				public values(): java.util.List<any>;
				public assertValueAt(index: number, value: any): any;
				public assertFailure(errorPredicate: io.reactivex.functions.Predicate<java.lang.Throwable>, ...values: any[]): any;
				public assertValueSequenceOnly(sequence: java.lang.Iterable<any>): any;
				public clearTimeout(): any;
				public awaitCount(atLeast: number, waitStrategy: java.lang.Runnable): any;
				public awaitTerminalEvent(): boolean;
				public assertNoValues(): any;
				public assertNotTerminated(): any;
				public errors(): java.util.List<java.lang.Throwable>;
				public assertValues(...values: any[]): any;
				public getEvents(): java.util.List<java.util.List<any>>;
				public assertValuesOnly(...values: any[]): any;
				public assertEmpty(): any;
				public assertErrorMessage(message: string): any;
				public assertTimeout(): any;
				public assertNever(valuePredicate: io.reactivex.functions.Predicate<any>): any;
				public awaitTerminalEvent(duration: number, param1: java.util.concurrent.TimeUnit): boolean;
				public assertValueSet(expected: java.util.Collection<any>): any;
				public assertValue(valuePredicate: io.reactivex.functions.Predicate<any>): any;
				public assertError(error: java.lang.Throwable): any;
				public isTimeout(): boolean;
				public assertResult(...values: any[]): any;
				public assertSubscribed(): any;
				public assertValueAt(index: number, valuePredicate: io.reactivex.functions.Predicate<any>): any;
				public assertError(errorPredicate: io.reactivex.functions.Predicate<java.lang.Throwable>): any;
				public awaitCount(atLeast: number): any;
				public lastThread(): java.lang.Thread;
				public await(time: number, param1: java.util.concurrent.TimeUnit): boolean;
				public assertValueSequence(sequence: java.lang.Iterable<any>): any;
			}
			export module BaseTestConsumer {
				export abstract class TestWaitStrategy extends java.lang.Runnable {
					public static class: java.lang.Class<io.reactivex.observers.BaseTestConsumer.TestWaitStrategy>;
					public static SPIN: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static YIELD: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static SLEEP_1MS: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static SLEEP_10MS: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static SLEEP_100MS: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static SLEEP_1000MS: io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public static valueOf(name: string): io.reactivex.observers.BaseTestConsumer.TestWaitStrategy;
					public run(): void;
					public static values(): io.reactivex.observers.BaseTestConsumer.TestWaitStrategy[];
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class DefaultObserver<T>  extends io.reactivex.Observer<any> {
				public static class: java.lang.Class<io.reactivex.observers.DefaultObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public onNext(param0: any): void;
				public cancel(): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class DisposableCompletableObserver extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
				public static class: java.lang.Class<io.reactivex.observers.DisposableCompletableObserver>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public isDisposed(): boolean;
				public dispose(): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class DisposableMaybeObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.DisposableMaybeObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public isDisposed(): boolean;
				public dispose(): void;
				public onSuccess(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class DisposableObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.DisposableObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public isDisposed(): boolean;
				public dispose(): void;
				public onNext(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class DisposableSingleObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.DisposableSingleObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public isDisposed(): boolean;
				public dispose(): void;
				public onSuccess(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export class LambdaConsumerIntrospection extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.LambdaConsumerIntrospection>;
				/**
				 * Constructs a new instance of the io.reactivex.observers.LambdaConsumerIntrospection interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					hasCustomOnError(): boolean;
				});
				public constructor();
				public hasCustomOnError(): boolean;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class ResourceCompletableObserver extends java.lang.Object implements io.reactivex.CompletableObserver, io.reactivex.disposables.Disposable {
				public static class: java.lang.Class<io.reactivex.observers.ResourceCompletableObserver>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public add(resource: io.reactivex.disposables.Disposable): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class ResourceMaybeObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.ResourceMaybeObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public add(resource: io.reactivex.disposables.Disposable): void;
				public onSuccess(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class ResourceObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.ResourceObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public add(resource: io.reactivex.disposables.Disposable): void;
				public onNext(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export abstract class ResourceSingleObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.ResourceSingleObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onStart(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public add(resource: io.reactivex.disposables.Disposable): void;
				public onSuccess(param0: T): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export class SafeObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.SafeObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onNext(t: T): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public onNext(param0: T): void;
				public constructor(downstream: io.reactivex.Observer<any>);
				public onError(t: java.lang.Throwable): void;
				public onError(param0: java.lang.Throwable): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export class SerializedObserver<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.observers.SerializedObserver<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onNext(t: T): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public constructor(actual: io.reactivex.Observer<any>, delayError: boolean);
				public onNext(param0: T): void;
				public constructor(downstream: io.reactivex.Observer<any>);
				public onError(t: java.lang.Throwable): void;
				public onError(param0: java.lang.Throwable): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module observers {
			export class TestObserver<T>  extends io.reactivex.observers.BaseTestConsumer<any,io.reactivex.observers.TestObserver<any>> {
				public static class: java.lang.Class<io.reactivex.observers.TestObserver<any>>;
				public assertNotSubscribed(): any;
				public onSuccess(param0: any): void;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public onNext(t: any): void;
				public isDisposed(): boolean;
				public assertNotSubscribed(): io.reactivex.observers.TestObserver<any>;
				public constructor(downstream: io.reactivex.Observer<any>);
				public onError(param0: java.lang.Throwable): void;
				public constructor();
				public assertOf(check: io.reactivex.functions.Consumer<any>): io.reactivex.observers.TestObserver<any>;
				public hasSubscription(): boolean;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public assertSubscribed(): any;
				public assertSubscribed(): io.reactivex.observers.TestObserver<any>;
				public dispose(): void;
				public onNext(param0: any): void;
				public cancel(): void;
				public onSuccess(value: any): void;
				public static create(): io.reactivex.observers.TestObserver<any>;
				public onError(t: java.lang.Throwable): void;
				public isCancelled(): boolean;
				public static create(delegate: io.reactivex.Observer<any>): io.reactivex.observers.TestObserver<any>;
			}
			export module TestObserver {
				export class EmptyObserver extends io.reactivex.Observer<any> {
					public static class: java.lang.Class<io.reactivex.observers.TestObserver.EmptyObserver>;
					public static INSTANCE: io.reactivex.observers.TestObserver.EmptyObserver;
					public onNext(t: any): void;
					public onSubscribe(d: io.reactivex.disposables.Disposable): void;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public onError(t: java.lang.Throwable): void;
					public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
					public static values(): io.reactivex.observers.TestObserver.EmptyObserver[];
					public onComplete(): void;
					public static valueOf(name: string): io.reactivex.observers.TestObserver.EmptyObserver;
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module parallel {
			export class ParallelFailureHandling extends io.reactivex.functions.BiFunction<java.lang.Long,java.lang.Throwable,io.reactivex.parallel.ParallelFailureHandling> {
				public static class: java.lang.Class<io.reactivex.parallel.ParallelFailureHandling>;
				public static STOP: io.reactivex.parallel.ParallelFailureHandling;
				public static ERROR: io.reactivex.parallel.ParallelFailureHandling;
				public static SKIP: io.reactivex.parallel.ParallelFailureHandling;
				public static RETRY: io.reactivex.parallel.ParallelFailureHandling;
				public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
				public apply(t1: java.lang.Long, t2: java.lang.Throwable): io.reactivex.parallel.ParallelFailureHandling;
				public apply(param0: any, param1: any): any;
				public static valueOf(name: string): io.reactivex.parallel.ParallelFailureHandling;
				public static values(): io.reactivex.parallel.ParallelFailureHandling[];
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module parallel {
			export abstract class ParallelFlowable<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.parallel.ParallelFlowable<any>>;
				public runOn(scheduler: io.reactivex.Scheduler, prefetch: number): io.reactivex.parallel.ParallelFlowable<T>;
				public reduce(initialSupplier: java.util.concurrent.Callable<any>, reducer: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public concatMap(mapper: io.reactivex.functions.Function<any,any>, prefetch: number): io.reactivex.parallel.ParallelFlowable<any>;
				public map(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public map(mapper: io.reactivex.functions.Function<any,any>, errorHandler: io.reactivex.functions.BiFunction<any,any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public subscribe(param0: org.reactivestreams.Subscriber<any>[]): void;
				public doOnNext(onNext: io.reactivex.functions.Consumer<any>, errorHandler: io.reactivex.parallel.ParallelFailureHandling): io.reactivex.parallel.ParallelFlowable<T>;
				public to(converter: io.reactivex.functions.Function<any,any>): any;
				public runOn(scheduler: io.reactivex.Scheduler): io.reactivex.parallel.ParallelFlowable<T>;
				public constructor();
				public static from(source: org.reactivestreams.Publisher): io.reactivex.parallel.ParallelFlowable<any>;
				public doOnNext(onNext: io.reactivex.functions.Consumer<any>, errorHandler: io.reactivex.functions.BiFunction<any,any,io.reactivex.parallel.ParallelFailureHandling>): io.reactivex.parallel.ParallelFlowable<T>;
				public doAfterNext(onAfterNext: io.reactivex.functions.Consumer<any>): io.reactivex.parallel.ParallelFlowable<T>;
				public flatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public sequential(): io.reactivex.Flowable<T>;
				public static fromArray(...publishers: org.reactivestreams.Publisher[]): io.reactivex.parallel.ParallelFlowable<any>;
				public sequentialDelayError(): io.reactivex.Flowable<T>;
				public doOnComplete(onComplete: io.reactivex.functions.Action): io.reactivex.parallel.ParallelFlowable<T>;
				public doAfterTerminated(onAfterTerminate: io.reactivex.functions.Action): io.reactivex.parallel.ParallelFlowable<T>;
				public filter(predicate: io.reactivex.functions.Predicate<any>, errorHandler: io.reactivex.functions.BiFunction<any,any,io.reactivex.parallel.ParallelFailureHandling>): io.reactivex.parallel.ParallelFlowable<T>;
				public static from(source: org.reactivestreams.Publisher, parallelism: number, prefetch: number): io.reactivex.parallel.ParallelFlowable<any>;
				public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayError: boolean, maxConcurrency: number, prefetch: number): io.reactivex.parallel.ParallelFlowable<any>;
				public validate(subscribers: org.reactivestreams.Subscriber<any>[]): boolean;
				public static from(source: org.reactivestreams.Publisher, parallelism: number): io.reactivex.parallel.ParallelFlowable<any>;
				public map(mapper: io.reactivex.functions.Function<any,any>, errorHandler: io.reactivex.parallel.ParallelFailureHandling): io.reactivex.parallel.ParallelFlowable<any>;
				public doOnRequest(onRequest: io.reactivex.functions.LongConsumer): io.reactivex.parallel.ParallelFlowable<T>;
				public parallelism(): number;
				public filter(predicate: io.reactivex.functions.Predicate<any>, errorHandler: io.reactivex.parallel.ParallelFailureHandling): io.reactivex.parallel.ParallelFlowable<T>;
				public collect(collectionSupplier: java.util.concurrent.Callable<any>, collector: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public doOnError(onError: io.reactivex.functions.Consumer<java.lang.Throwable>): io.reactivex.parallel.ParallelFlowable<T>;
				public sorted(comparator: java.util.Comparator<any>, capacityHint: number): io.reactivex.Flowable<T>;
				public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>, tillTheEnd: boolean): io.reactivex.parallel.ParallelFlowable<any>;
				public toSortedList(comparator: java.util.Comparator<any>, capacityHint: number): io.reactivex.Flowable<java.util.List<T>>;
				public doOnNext(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.parallel.ParallelFlowable<T>;
				public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayError: boolean, maxConcurrency: number): io.reactivex.parallel.ParallelFlowable<any>;
				public as(converter: io.reactivex.parallel.ParallelFlowableConverter<any,any>): any;
				public sequentialDelayError(prefetch: number): io.reactivex.Flowable<T>;
				public concatMapDelayError(mapper: io.reactivex.functions.Function<any,any>, prefetch: number, tillTheEnd: boolean): io.reactivex.parallel.ParallelFlowable<any>;
				public compose(composer: io.reactivex.parallel.ParallelTransformer<any,any>): io.reactivex.parallel.ParallelFlowable<any>;
				public doOnSubscribe(onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.parallel.ParallelFlowable<T>;
				public flatMap(mapper: io.reactivex.functions.Function<any,any>, delayError: boolean): io.reactivex.parallel.ParallelFlowable<any>;
				public reduce(reducer: io.reactivex.functions.BiFunction<T,T,T>): io.reactivex.Flowable<T>;
				public toSortedList(comparator: java.util.Comparator<any>): io.reactivex.Flowable<java.util.List<T>>;
				public doOnCancel(onCancel: io.reactivex.functions.Action): io.reactivex.parallel.ParallelFlowable<T>;
				public filter(predicate: io.reactivex.functions.Predicate<any>): io.reactivex.parallel.ParallelFlowable<T>;
				public sorted(comparator: java.util.Comparator<any>): io.reactivex.Flowable<T>;
				public sequential(prefetch: number): io.reactivex.Flowable<T>;
				public concatMap(mapper: io.reactivex.functions.Function<any,any>): io.reactivex.parallel.ParallelFlowable<any>;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module parallel {
			export class ParallelFlowableConverter<T, R>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.parallel.ParallelFlowableConverter<any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.parallel.ParallelFlowableConverter<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: io.reactivex.parallel.ParallelFlowable<T>): R;
				});
				public constructor();
				public apply(param0: io.reactivex.parallel.ParallelFlowable<T>): R;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module parallel {
			export class ParallelTransformer<Upstream, Downstream>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.parallel.ParallelTransformer<any,any>>;
				/**
				 * Constructs a new instance of the io.reactivex.parallel.ParallelTransformer<any,any> interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					apply(param0: io.reactivex.parallel.ParallelFlowable<Upstream>): io.reactivex.parallel.ParallelFlowable<Downstream>;
				});
				public constructor();
				public apply(param0: io.reactivex.parallel.ParallelFlowable<Upstream>): io.reactivex.parallel.ParallelFlowable<Downstream>;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module plugins {
			export class RxJavaPlugins extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.plugins.RxJavaPlugins>;
				public static onAssembly(source: io.reactivex.Maybe<any>): io.reactivex.Maybe<any>;
				public static onAssembly(source: io.reactivex.parallel.ParallelFlowable<any>): io.reactivex.parallel.ParallelFlowable<any>;
				public static getOnConnectableObservableAssembly(): io.reactivex.functions.Function<any,any>;
				public static getInitNewThreadSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static setIoSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static getOnConnectableFlowableAssembly(): io.reactivex.functions.Function<any,any>;
				public static getInitSingleSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static getOnMaybeSubscribe(): io.reactivex.functions.BiFunction<any,any,any>;
				public static onComputationScheduler(defaultScheduler: io.reactivex.Scheduler): io.reactivex.Scheduler;
				public static onNewThreadScheduler(defaultScheduler: io.reactivex.Scheduler): io.reactivex.Scheduler;
				public static setSingleSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static onSubscribe(source: io.reactivex.Maybe<any>, observer: io.reactivex.MaybeObserver<any>): io.reactivex.MaybeObserver<any>;
				public static onAssembly(source: io.reactivex.Flowable<any>): io.reactivex.Flowable<any>;
				public static lockdown(): void;
				public static isFailOnNonBlockingScheduler(): boolean;
				public static setOnCompletableAssembly(onCompletableAssembly: io.reactivex.functions.Function<any,any>): void;
				public static getOnObservableAssembly(): io.reactivex.functions.Function<any,any>;
				public static onSingleScheduler(defaultScheduler: io.reactivex.Scheduler): io.reactivex.Scheduler;
				public static initSingleScheduler(defaultScheduler: java.util.concurrent.Callable<io.reactivex.Scheduler>): io.reactivex.Scheduler;
				public static setOnSingleSubscribe(onSingleSubscribe: io.reactivex.functions.BiFunction<any,any,any>): void;
				public static setOnObservableSubscribe(onObservableSubscribe: io.reactivex.functions.BiFunction<any,any,any>): void;
				public static initIoScheduler(defaultScheduler: java.util.concurrent.Callable<io.reactivex.Scheduler>): io.reactivex.Scheduler;
				public static setOnObservableAssembly(onObservableAssembly: io.reactivex.functions.Function<any,any>): void;
				public static setErrorHandler(handler: io.reactivex.functions.Consumer<any>): void;
				public static getIoSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static onSubscribe(source: io.reactivex.Single<any>, observer: io.reactivex.SingleObserver<any>): io.reactivex.SingleObserver<any>;
				public static getScheduleHandler(): io.reactivex.functions.Function<any,any>;
				public static createSingleScheduler(threadFactory: java.util.concurrent.ThreadFactory): io.reactivex.Scheduler;
				public static getInitComputationSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static setInitComputationSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static getOnSingleAssembly(): io.reactivex.functions.Function<any,any>;
				public static getOnObservableSubscribe(): io.reactivex.functions.BiFunction<any,any,any>;
				public static getOnCompletableAssembly(): io.reactivex.functions.Function<any,any>;
				public static onAssembly(source: io.reactivex.flowables.ConnectableFlowable<any>): io.reactivex.flowables.ConnectableFlowable<any>;
				public static onAssembly(source: io.reactivex.Single<any>): io.reactivex.Single<any>;
				public static getOnParallelAssembly(): io.reactivex.functions.Function<any,any>;
				public static getOnFlowableAssembly(): io.reactivex.functions.Function<any,any>;
				public static onError(error: java.lang.Throwable): void;
				public static getOnBeforeBlocking(): io.reactivex.functions.BooleanSupplier;
				public static getInitIoSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static onSchedule(run: java.lang.Runnable): java.lang.Runnable;
				public static setOnBeforeBlocking(handler: io.reactivex.functions.BooleanSupplier): void;
				public static setNewThreadSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static setOnFlowableAssembly(onFlowableAssembly: io.reactivex.functions.Function<any,any>): void;
				public static getOnFlowableSubscribe(): io.reactivex.functions.BiFunction<any,any,any>;
				public static setComputationSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static onAssembly(source: io.reactivex.observables.ConnectableObservable<any>): io.reactivex.observables.ConnectableObservable<any>;
				public static initComputationScheduler(defaultScheduler: java.util.concurrent.Callable<io.reactivex.Scheduler>): io.reactivex.Scheduler;
				public static setOnFlowableSubscribe(onFlowableSubscribe: io.reactivex.functions.BiFunction<any,any,any>): void;
				public static setOnCompletableSubscribe(onCompletableSubscribe: io.reactivex.functions.BiFunction<any,any,any>): void;
				public static onSubscribe(source: io.reactivex.Observable<any>, observer: io.reactivex.Observer<any>): io.reactivex.Observer<any>;
				public static createNewThreadScheduler(threadFactory: java.util.concurrent.ThreadFactory): io.reactivex.Scheduler;
				public static onBeforeBlocking(): boolean;
				public static setInitNewThreadSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static setOnSingleAssembly(onSingleAssembly: io.reactivex.functions.Function<any,any>): void;
				public static onAssembly(source: io.reactivex.Observable<any>): io.reactivex.Observable<any>;
				public static setOnParallelAssembly(handler: io.reactivex.functions.Function<any,any>): void;
				public static onIoScheduler(defaultScheduler: io.reactivex.Scheduler): io.reactivex.Scheduler;
				public static setOnMaybeAssembly(onMaybeAssembly: io.reactivex.functions.Function<any,any>): void;
				public static getErrorHandler(): io.reactivex.functions.Consumer<any>;
				public static createIoScheduler(threadFactory: java.util.concurrent.ThreadFactory): io.reactivex.Scheduler;
				public static setInitIoSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static isLockdown(): boolean;
				public static getOnSingleSubscribe(): io.reactivex.functions.BiFunction<any,any,any>;
				public static getComputationSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static setScheduleHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static onSubscribe(source: io.reactivex.Flowable<any>, subscriber: org.reactivestreams.Subscriber): org.reactivestreams.Subscriber;
				public static onAssembly(source: io.reactivex.Completable): io.reactivex.Completable;
				public static setOnMaybeSubscribe(onMaybeSubscribe: io.reactivex.functions.BiFunction<any,io.reactivex.MaybeObserver<any>,any>): void;
				public static setOnConnectableFlowableAssembly(onConnectableFlowableAssembly: io.reactivex.functions.Function<any,any>): void;
				public static getSingleSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static initNewThreadScheduler(defaultScheduler: java.util.concurrent.Callable<io.reactivex.Scheduler>): io.reactivex.Scheduler;
				public static setOnConnectableObservableAssembly(onConnectableObservableAssembly: io.reactivex.functions.Function<any,any>): void;
				public static createComputationScheduler(threadFactory: java.util.concurrent.ThreadFactory): io.reactivex.Scheduler;
				public static getNewThreadSchedulerHandler(): io.reactivex.functions.Function<any,any>;
				public static setInitSingleSchedulerHandler(handler: io.reactivex.functions.Function<any,any>): void;
				public static getOnCompletableSubscribe(): io.reactivex.functions.BiFunction<any,any,any>;
				public static getOnMaybeAssembly(): io.reactivex.functions.Function<any,any>;
				public static reset(): void;
				public static onSubscribe(source: io.reactivex.Completable, observer: io.reactivex.CompletableObserver): io.reactivex.CompletableObserver;
				public static setFailOnNonBlockingScheduler(enable: boolean): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class AsyncProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.AsyncProcessor<any>>;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public getValue(): any;
				public hasSubscribers(): boolean;
				/** @deprecated */
				public getValues(): any[];
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public onComplete(): void;
				public getThrowable(): java.lang.Throwable;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public static create(): io.reactivex.processors.AsyncProcessor<any>;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				/** @deprecated */
				public getValues(array: any[]): any[];
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasValue(): boolean;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
			}
			export module AsyncProcessor {
				export class AsyncSubscription<T>  extends io.reactivex.internal.subscriptions.DeferredScalarSubscription<any> {
					public static class: java.lang.Class<io.reactivex.processors.AsyncProcessor.AsyncSubscription<any>>;
					public cancel(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class BehaviorProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.BehaviorProcessor<any>>;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public offer(t: any): boolean;
				public getValue(): any;
				public hasSubscribers(): boolean;
				/** @deprecated */
				public getValues(): any[];
				public static createDefault(defaultValue: any): io.reactivex.processors.BehaviorProcessor<any>;
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public onComplete(): void;
				public getThrowable(): java.lang.Throwable;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				/** @deprecated */
				public getValues(array: any[]): any[];
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasValue(): boolean;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public static create(): io.reactivex.processors.BehaviorProcessor<any>;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
			}
			export module BehaviorProcessor {
				export class BehaviorSubscription<T>  extends java.util.concurrent.atomic.AtomicLong {
					public static class: java.lang.Class<io.reactivex.processors.BehaviorProcessor.BehaviorSubscription<any>>;
					public request(n: number): void;
					public isFull(): boolean;
					public cancel(): void;
					public test(param0: any): boolean;
					public request(param0: number): void;
					public test(o: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export abstract class FlowableProcessor<T>  extends io.reactivex.Flowable<any> {
				public static class: java.lang.Class<io.reactivex.processors.FlowableProcessor<any>>;
				public hasThrowable(): boolean;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public toSerialized(): io.reactivex.processors.FlowableProcessor<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasSubscribers(): boolean;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public onComplete(): void;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public getThrowable(): java.lang.Throwable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class MulticastProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.MulticastProcessor<any>>;
				public static create(refCount: boolean): io.reactivex.processors.MulticastProcessor<any>;
				public hasThrowable(): boolean;
				public static create(bufferSize: number): io.reactivex.processors.MulticastProcessor<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public offer(t: any): boolean;
				public hasSubscribers(): boolean;
				public static create(): io.reactivex.processors.MulticastProcessor<any>;
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public startUnbounded(): void;
				public onComplete(): void;
				public start(): void;
				public getThrowable(): java.lang.Throwable;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public static create(bufferSize: number, refCount: boolean): io.reactivex.processors.MulticastProcessor<any>;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
			}
			export module MulticastProcessor {
				export class MulticastSubscription<T>  extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription  {
					public static class: java.lang.Class<io.reactivex.processors.MulticastProcessor.MulticastSubscription<any>>;
					public request(n: number): void;
					public cancel(): void;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class PublishProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.PublishProcessor<any>>;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public hasThrowable(): boolean;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public offer(t: any): boolean;
				public hasSubscribers(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.processors.PublishProcessor<any>;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public onComplete(): void;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribeActual(t: org.reactivestreams.Subscriber<any>): void;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public getThrowable(): java.lang.Throwable;
			}
			export module PublishProcessor {
				export class PublishSubscription<T>  extends java.util.concurrent.atomic.AtomicLong implements org.reactivestreams.Subscription  {
					public static class: java.lang.Class<io.reactivex.processors.PublishProcessor.PublishSubscription<any>>;
					public onNext(t: any): void;
					public onError(t: java.lang.Throwable): void;
					public request(n: number): void;
					public isCancelled(): boolean;
					public cancel(): void;
					public onComplete(): void;
					public request(param0: number): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class ReplayProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor<any>>;
				public cleanupBuffer(): void;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.processors.ReplayProcessor<any>;
				public getValue(): any;
				public hasSubscribers(): boolean;
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public static createWithSize(maxSize: number): io.reactivex.processors.ReplayProcessor<any>;
				public onComplete(): void;
				public static createWithTime(maxAge: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.processors.ReplayProcessor<any>;
				public getValues(array: any[]): any[];
				public getThrowable(): java.lang.Throwable;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public static create(capacityHint: number): io.reactivex.processors.ReplayProcessor<any>;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasValue(): boolean;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public getValues(): any[];
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public static createWithTimeAndSize(maxAge: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.processors.ReplayProcessor<any>;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
			}
			export module ReplayProcessor {
				export class Node<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.processors.ReplayProcessor.Node<any>> {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.Node<any>>;
				}
				export class ReplayBuffer<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.ReplayBuffer<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.processors.ReplayProcessor$ReplayBuffer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						next(param0: T): void;
						error(param0: java.lang.Throwable): void;
						complete(): void;
						replay(param0: io.reactivex.processors.ReplayProcessor.ReplaySubscription<T>): void;
						size(): number;
						getValue(): T;
						getValues(param0: T[]): T[];
						isDone(): boolean;
						getError(): java.lang.Throwable;
						trimHead(): void;
					});
					public constructor();
					public getValues(param0: T[]): T[];
					public error(param0: java.lang.Throwable): void;
					public isDone(): boolean;
					public replay(param0: io.reactivex.processors.ReplayProcessor.ReplaySubscription<T>): void;
					public next(param0: T): void;
					public getValue(): T;
					public trimHead(): void;
					public complete(): void;
					public size(): number;
					public getError(): java.lang.Throwable;
				}
				export class ReplaySubscription<T>  extends java.util.concurrent.atomic.AtomicInteger implements org.reactivestreams.Subscription  {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>>;
					public request(n: number): void;
					public cancel(): void;
					public request(param0: number): void;
				}
				export class SizeAndTimeBoundReplayBuffer<T>  extends io.reactivex.processors.ReplayProcessor.ReplayBuffer<any> {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.SizeAndTimeBoundReplayBuffer<any>>;
					public getValue(): any;
					public next(param0: any): void;
					public error(param0: java.lang.Throwable): void;
					public getValues(array: any[]): any[];
					public next(value: any): void;
					public size(): number;
					public replay(param0: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
					public getError(): java.lang.Throwable;
					public getValues(param0: any[]): any[];
					public isDone(): boolean;
					public trimHead(): void;
					public error(ex: java.lang.Throwable): void;
					public complete(): void;
					public replay(rs: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
				}
				export class SizeBoundReplayBuffer<T>  extends io.reactivex.processors.ReplayProcessor.ReplayBuffer<any> {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.SizeBoundReplayBuffer<any>>;
					public getValue(): any;
					public next(param0: any): void;
					public error(param0: java.lang.Throwable): void;
					public getValues(array: any[]): any[];
					public next(value: any): void;
					public size(): number;
					public replay(param0: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
					public getError(): java.lang.Throwable;
					public getValues(param0: any[]): any[];
					public isDone(): boolean;
					public trimHead(): void;
					public error(ex: java.lang.Throwable): void;
					public complete(): void;
					public replay(rs: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
				}
				export class TimedNode<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.processors.ReplayProcessor.TimedNode<any>> {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.TimedNode<any>>;
				}
				export class UnboundedReplayBuffer<T>  extends io.reactivex.processors.ReplayProcessor.ReplayBuffer<any> {
					public static class: java.lang.Class<io.reactivex.processors.ReplayProcessor.UnboundedReplayBuffer<any>>;
					public getValue(): any;
					public next(param0: any): void;
					public error(param0: java.lang.Throwable): void;
					public getValues(array: any[]): any[];
					public next(value: any): void;
					public size(): number;
					public replay(param0: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
					public getError(): java.lang.Throwable;
					public getValues(param0: any[]): any[];
					public isDone(): boolean;
					public trimHead(): void;
					public error(ex: java.lang.Throwable): void;
					public complete(): void;
					public replay(rs: io.reactivex.processors.ReplayProcessor.ReplaySubscription<any>): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class SerializedProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.SerializedProcessor<any>>;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public hasThrowable(): boolean;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasSubscribers(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public getThrowable(): java.lang.Throwable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module processors {
			export class UnicastProcessor<T>  extends io.reactivex.processors.FlowableProcessor<any> {
				public static class: java.lang.Class<io.reactivex.processors.UnicastProcessor<any>>;
				public static create(delayError: boolean): io.reactivex.processors.UnicastProcessor<any>;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasSubscribers(): boolean;
				public subscribeActual(s: org.reactivestreams.Subscriber<any>): void;
				public onComplete(): void;
				public static create(): io.reactivex.processors.UnicastProcessor<any>;
				public static create(capacityHint: number): io.reactivex.processors.UnicastProcessor<any>;
				public getThrowable(): java.lang.Throwable;
				public subscribeActual(param0: org.reactivestreams.Subscriber<any>): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public static create(capacityHint: number, onCancelled: java.lang.Runnable): io.reactivex.processors.UnicastProcessor<any>;
				public onNext(t: any): void;
				public subscribe(s: io.reactivex.FlowableSubscriber<any>): void;
				public subscribe(s: org.reactivestreams.Subscriber<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.FlowableOnSubscribe<any>, mode: io.reactivex.BackpressureStrategy): io.reactivex.Flowable<any>;
				public hasComplete(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: org.reactivestreams.Subscriber<any>): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public static create(capacityHint: number, onCancelled: java.lang.Runnable, delayError: boolean): io.reactivex.processors.UnicastProcessor<any>;
			}
			export module UnicastProcessor {
				export class UnicastQueueSubscription extends io.reactivex.internal.subscriptions.BasicIntQueueSubscription<any> {
					public static class: java.lang.Class<io.reactivex.processors.UnicastProcessor.UnicastQueueSubscription>;
					public poll(): any;
					public isEmpty(): boolean;
					public request(n: number): void;
					public clear(): void;
					public requestFusion(requestedMode: number): number;
					public cancel(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module schedulers {
			export class SchedulerRunnableIntrospection extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.schedulers.SchedulerRunnableIntrospection>;
				/**
				 * Constructs a new instance of the io.reactivex.schedulers.SchedulerRunnableIntrospection interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
				 */
				public constructor(implementation: {
					getWrappedRunnable(): java.lang.Runnable;
				});
				public constructor();
				public getWrappedRunnable(): java.lang.Runnable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module schedulers {
			export class Schedulers extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.schedulers.Schedulers>;
				public static single(): io.reactivex.Scheduler;
				public static from(executor: java.util.concurrent.Executor): io.reactivex.Scheduler;
				public static from(executor: java.util.concurrent.Executor, interruptibleWorker: boolean): io.reactivex.Scheduler;
				public static io(): io.reactivex.Scheduler;
				public static shutdown(): void;
				public static start(): void;
				public static trampoline(): io.reactivex.Scheduler;
				public static computation(): io.reactivex.Scheduler;
				public static newThread(): io.reactivex.Scheduler;
			}
			export module Schedulers {
				export class ComputationHolder extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.ComputationHolder>;
				}
				export class ComputationTask extends java.util.concurrent.Callable<io.reactivex.Scheduler> {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.ComputationTask>;
					public call(): io.reactivex.Scheduler;
					public call(): any;
				}
				export class IOTask extends java.util.concurrent.Callable<io.reactivex.Scheduler> {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.IOTask>;
					public call(): io.reactivex.Scheduler;
					public call(): any;
				}
				export class IoHolder extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.IoHolder>;
				}
				export class NewThreadHolder extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.NewThreadHolder>;
				}
				export class NewThreadTask extends java.util.concurrent.Callable<io.reactivex.Scheduler> {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.NewThreadTask>;
					public call(): io.reactivex.Scheduler;
					public call(): any;
				}
				export class SingleHolder extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.SingleHolder>;
				}
				export class SingleTask extends java.util.concurrent.Callable<io.reactivex.Scheduler> {
					public static class: java.lang.Class<io.reactivex.schedulers.Schedulers.SingleTask>;
					public call(): io.reactivex.Scheduler;
					public call(): any;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module schedulers {
			export class TestScheduler extends io.reactivex.Scheduler {
				public static class: java.lang.Class<io.reactivex.schedulers.TestScheduler>;
				public advanceTimeBy(delayTime: number, param1: java.util.concurrent.TimeUnit): void;
				public advanceTimeTo(delayTime: number, param1: java.util.concurrent.TimeUnit): void;
				public triggerActions(): void;
				public now(unit: java.util.concurrent.TimeUnit): number;
				public createWorker(): io.reactivex.Scheduler.Worker;
				public constructor(delayTime: number, param1: java.util.concurrent.TimeUnit);
				public constructor();
			}
			export module TestScheduler {
				export class TestWorker extends io.reactivex.Scheduler.Worker {
					public static class: java.lang.Class<io.reactivex.schedulers.TestScheduler.TestWorker>;
					public schedule(run: java.lang.Runnable): io.reactivex.disposables.Disposable;
					public isDisposed(): boolean;
					public schedule(run: java.lang.Runnable, delayTime: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
					public now(unit: java.util.concurrent.TimeUnit): number;
					public dispose(): void;
					public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): io.reactivex.disposables.Disposable;
				}
				export module TestWorker {
					export class QueueRemove extends java.lang.Object implements java.lang.Runnable {
						public static class: java.lang.Class<io.reactivex.schedulers.TestScheduler.TestWorker.QueueRemove>;
						public run(): void;
					}
				}
				export class TimedRunnable extends java.lang.Comparable<io.reactivex.schedulers.TestScheduler.TimedRunnable> {
					public static class: java.lang.Class<io.reactivex.schedulers.TestScheduler.TimedRunnable>;
					public toString(): string;
					public compareTo(o: io.reactivex.schedulers.TestScheduler.TimedRunnable): number;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module schedulers {
			export class Timed<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.schedulers.Timed<any>>;
				public unit(): java.util.concurrent.TimeUnit;
				public equals(obj: any): boolean;
				public equals(other: any): boolean;
				public hashCode(): number;
				public time(): number;
				public time(unit: java.util.concurrent.TimeUnit): number;
				public value(): T;
				public toString(): string;
				public constructor(value: T, time: number, param2: java.util.concurrent.TimeUnit);
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class AsyncSubject<T>  extends io.reactivex.subjects.Subject<any> {
				public static class: java.lang.Class<io.reactivex.subjects.AsyncSubject<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public hasThrowable(): boolean;
				public subscribeActual(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.subjects.AsyncSubject<any>;
				public getValue(): any;
				/** @deprecated */
				public getValues(): any[];
				public onError(param0: java.lang.Throwable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public getThrowable(): java.lang.Throwable;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public hasObservers(): boolean;
				public onNext(t: any): void;
				/** @deprecated */
				public getValues(array: any[]): any[];
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
				public hasValue(): boolean;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public onError(t: java.lang.Throwable): void;
			}
			export module AsyncSubject {
				export class AsyncDisposable<T>  extends io.reactivex.internal.observers.DeferredScalarDisposable<any> {
					public static class: java.lang.Class<io.reactivex.subjects.AsyncSubject.AsyncDisposable<any>>;
					public dispose(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class BehaviorSubject<T>  extends io.reactivex.subjects.Subject<any> {
				public static class: java.lang.Class<io.reactivex.subjects.BehaviorSubject<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public subscribeActual(observer: io.reactivex.Observer<any>): void;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static createDefault(defaultValue: any): io.reactivex.subjects.BehaviorSubject<any>;
				public getValue(): any;
				/** @deprecated */
				public getValues(): any[];
				public onError(param0: java.lang.Throwable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public getThrowable(): java.lang.Throwable;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public hasObservers(): boolean;
				public onNext(t: any): void;
				/** @deprecated */
				public getValues(array: any[]): any[];
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
				public hasValue(): boolean;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.subjects.BehaviorSubject<any>;
				public subscribe(): io.reactivex.disposables.Disposable;
				public onError(t: java.lang.Throwable): void;
			}
			export module BehaviorSubject {
				export class BehaviorDisposable<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.subjects.BehaviorSubject.BehaviorDisposable<any>>;
					public isDisposed(): boolean;
					public dispose(): void;
					public test(param0: T): boolean;
					public test(o: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class CompletableSubject extends io.reactivex.Completable implements io.reactivex.CompletableObserver {
				public static class: java.lang.Class<io.reactivex.subjects.CompletableSubject>;
				public subscribe(onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public subscribeActual(observer: io.reactivex.CompletableObserver): void;
				public hasObservers(): boolean;
				public subscribeActual(param0: io.reactivex.CompletableObserver): void;
				public subscribe(observer: io.reactivex.CompletableObserver): void;
				public hasThrowable(): boolean;
				public subscribe(onComplete: io.reactivex.functions.Action, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.subjects.CompletableSubject;
				public onError(param0: java.lang.Throwable): void;
				public onError(e: java.lang.Throwable): void;
				public static create(source: io.reactivex.CompletableOnSubscribe): io.reactivex.Completable;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribe(param0: io.reactivex.CompletableObserver): void;
				public getThrowable(): java.lang.Throwable;
			}
			export module CompletableSubject {
				export class CompletableDisposable extends java.util.concurrent.atomic.AtomicReference<io.reactivex.subjects.CompletableSubject> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.subjects.CompletableSubject.CompletableDisposable>;
					public isDisposed(): boolean;
					public dispose(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class MaybeSubject<T>  extends io.reactivex.Maybe<any> implements io.reactivex.MaybeObserver<any>  {
				public static class: java.lang.Class<io.reactivex.subjects.MaybeSubject<any>>;
				public onSuccess(param0: any): void;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public hasObservers(): boolean;
				public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(observer: io.reactivex.MaybeObserver<any>): void;
				public hasThrowable(): boolean;
				public subscribeActual(observer: io.reactivex.MaybeObserver<any>): void;
				public getValue(): any;
				public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public onError(e: java.lang.Throwable): void;
				public subscribe(param0: io.reactivex.MaybeObserver<any>): void;
				public hasValue(): boolean;
				public static create(onSubscribe: io.reactivex.MaybeOnSubscribe<any>): io.reactivex.Maybe<any>;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public onSuccess(value: any): void;
				public static create(): io.reactivex.subjects.MaybeSubject<any>;
				public subscribe(): io.reactivex.disposables.Disposable;
				public subscribeActual(param0: io.reactivex.MaybeObserver<any>): void;
				public getThrowable(): java.lang.Throwable;
			}
			export module MaybeSubject {
				export class MaybeDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.subjects.MaybeSubject<any>> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.subjects.MaybeSubject.MaybeDisposable<any>>;
					public isDisposed(): boolean;
					public dispose(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class PublishSubject<T>  extends io.reactivex.subjects.Subject<any> {
				public static class: java.lang.Class<io.reactivex.subjects.PublishSubject<any>>;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public hasObservers(): boolean;
				public static create(): io.reactivex.subjects.PublishSubject<any>;
				public onNext(t: any): void;
				public hasThrowable(): boolean;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribeActual(t: io.reactivex.Observer<any>): void;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public onError(t: java.lang.Throwable): void;
				public getThrowable(): java.lang.Throwable;
			}
			export module PublishSubject {
				export class PublishDisposable<T>  extends java.util.concurrent.atomic.AtomicBoolean implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.subjects.PublishSubject.PublishDisposable<any>>;
					public onNext(t: any): void;
					public isDisposed(): boolean;
					public onError(t: java.lang.Throwable): void;
					public dispose(): void;
					public onComplete(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class ReplaySubject<T>  extends io.reactivex.subjects.Subject<any> {
				public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject<any>>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public subscribeActual(observer: io.reactivex.Observer<any>): void;
				public cleanupBuffer(): void;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public getValue(): any;
				public onError(param0: java.lang.Throwable): void;
				public static createWithSize(maxSize: number): io.reactivex.subjects.ReplaySubject<any>;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public getValues(array: any[]): any[];
				public static createWithTimeAndSize(maxAge: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler, scheduler: number): io.reactivex.subjects.ReplaySubject<any>;
				public getThrowable(): java.lang.Throwable;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public hasObservers(): boolean;
				public onNext(t: any): void;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public static createWithTime(maxAge: number, param1: java.util.concurrent.TimeUnit, unit: io.reactivex.Scheduler): io.reactivex.subjects.ReplaySubject<any>;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
				public hasValue(): boolean;
				public getValues(): any[];
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(): io.reactivex.subjects.ReplaySubject<any>;
				public static create(capacityHint: number): io.reactivex.subjects.ReplaySubject<any>;
				public subscribe(): io.reactivex.disposables.Disposable;
				public onError(t: java.lang.Throwable): void;
			}
			export module ReplaySubject {
				export class Node<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.subjects.ReplaySubject.Node<any>> {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.Node<any>>;
				}
				export class ReplayBuffer<T>  extends java.lang.Object {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.ReplayBuffer<any>>;
					/**
					 * Constructs a new instance of the io.reactivex.subjects.ReplaySubject$ReplayBuffer interface with the provided implementation. An empty constructor exists calling super() when extending the interface class.
					 */
					public constructor(implementation: {
						add(param0: T): void;
						addFinal(param0: any): void;
						replay(param0: io.reactivex.subjects.ReplaySubject.ReplayDisposable<T>): void;
						size(): number;
						getValue(): T;
						getValues(param0: T[]): T[];
						get(): any;
						compareAndSet(param0: any, param1: any): boolean;
						trimHead(): void;
					});
					public constructor();
					public getValues(param0: T[]): T[];
					public replay(param0: io.reactivex.subjects.ReplaySubject.ReplayDisposable<T>): void;
					public get(): any;
					public addFinal(param0: any): void;
					public getValue(): T;
					public trimHead(): void;
					public size(): number;
					public compareAndSet(param0: any, param1: any): boolean;
					public add(param0: T): void;
				}
				export class ReplayDisposable<T>  extends java.util.concurrent.atomic.AtomicInteger implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>>;
					public isDisposed(): boolean;
					public dispose(): void;
				}
				export class SizeAndTimeBoundReplayBuffer<T>  extends java.util.concurrent.atomic.AtomicReference<any> implements io.reactivex.subjects.ReplaySubject.ReplayBuffer<any>  {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.SizeAndTimeBoundReplayBuffer<any>>;
					public getValue(): any;
					public add(value: any): void;
					public add(param0: any): void;
					public getValues(array: any[]): any[];
					public compareAndSet(expect: any, update: any): boolean;
					public replay(rs: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public size(): number;
					public addFinal(notificationLite: any): void;
					public getValues(param0: any[]): any[];
					public get(): any;
					public replay(param0: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public addFinal(param0: any): void;
					public trimHead(): void;
					public compareAndSet(param0: any, param1: any): boolean;
				}
				export class SizeBoundReplayBuffer<T>  extends java.util.concurrent.atomic.AtomicReference<any> implements io.reactivex.subjects.ReplaySubject.ReplayBuffer<any>  {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.SizeBoundReplayBuffer<any>>;
					public getValue(): any;
					public add(value: any): void;
					public add(param0: any): void;
					public getValues(array: any[]): any[];
					public compareAndSet(expect: any, update: any): boolean;
					public replay(rs: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public size(): number;
					public addFinal(notificationLite: any): void;
					public getValues(param0: any[]): any[];
					public get(): any;
					public replay(param0: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public addFinal(param0: any): void;
					public trimHead(): void;
					public compareAndSet(param0: any, param1: any): boolean;
				}
				export class TimedNode<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.subjects.ReplaySubject.TimedNode<any>> {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.TimedNode<any>>;
				}
				export class UnboundedReplayBuffer<T>  extends java.util.concurrent.atomic.AtomicReference<any> implements io.reactivex.subjects.ReplaySubject.ReplayBuffer<any>  {
					public static class: java.lang.Class<io.reactivex.subjects.ReplaySubject.UnboundedReplayBuffer<any>>;
					public getValue(): any;
					public add(value: any): void;
					public add(param0: any): void;
					public getValues(array: any[]): any[];
					public compareAndSet(expect: any, update: any): boolean;
					public replay(rs: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public size(): number;
					public addFinal(notificationLite: any): void;
					public getValues(param0: any[]): any[];
					public get(): any;
					public replay(param0: io.reactivex.subjects.ReplaySubject.ReplayDisposable<any>): void;
					public addFinal(param0: any): void;
					public trimHead(): void;
					public compareAndSet(param0: any, param1: any): boolean;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class SerializedSubject<T>  extends io.reactivex.subjects.Subject<any> implements io.reactivex.internal.util.AppendOnlyLinkedArrayList.NonThrowingPredicate<any>  {
				public static class: java.lang.Class<io.reactivex.subjects.SerializedSubject<any>>;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public hasObservers(): boolean;
				public onNext(t: any): void;
				public subscribeActual(observer: io.reactivex.Observer<any>): void;
				public test(): io.reactivex.observers.TestObserver<any>;
				public hasThrowable(): boolean;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public test(dispose: boolean): io.reactivex.observers.TestObserver<any>;
				public subscribe(): io.reactivex.disposables.Disposable;
				public test(o: any): boolean;
				public onError(t: java.lang.Throwable): void;
				public test(param0: any): boolean;
				public getThrowable(): java.lang.Throwable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class SingleSubject<T>  extends io.reactivex.Single<any> implements io.reactivex.SingleObserver<any>  {
				public static class: java.lang.Class<io.reactivex.subjects.SingleSubject<any>>;
				public onSuccess(param0: any): void;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public hasObservers(): boolean;
				public subscribe(param0: io.reactivex.SingleObserver<any>): void;
				public subscribe(onCallback: io.reactivex.functions.BiConsumer<any,any>): io.reactivex.disposables.Disposable;
				public subscribe(onSuccess: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public hasThrowable(): boolean;
				public getValue(): any;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onSuccess: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public onError(e: java.lang.Throwable): void;
				public hasValue(): boolean;
				public static create(source: io.reactivex.SingleOnSubscribe<any>): io.reactivex.Single<any>;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public subscribe(observer: io.reactivex.SingleObserver<any>): void;
				public subscribeActual(param0: io.reactivex.SingleObserver<any>): void;
				public static create(): io.reactivex.subjects.SingleSubject<any>;
				public onSuccess(value: any): void;
				public subscribeActual(observer: io.reactivex.SingleObserver<any>): void;
				public subscribe(): io.reactivex.disposables.Disposable;
				public getThrowable(): java.lang.Throwable;
			}
			export module SingleSubject {
				export class SingleDisposable<T>  extends java.util.concurrent.atomic.AtomicReference<io.reactivex.subjects.SingleSubject<any>> implements io.reactivex.disposables.Disposable  {
					public static class: java.lang.Class<io.reactivex.subjects.SingleSubject.SingleDisposable<any>>;
					public isDisposed(): boolean;
					public dispose(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export abstract class Subject<T>  extends io.reactivex.Observable<any> implements io.reactivex.Observer<any>  {
				public static class: java.lang.Class<io.reactivex.subjects.Subject<any>>;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public hasObservers(): boolean;
				public hasThrowable(): boolean;
				public toSerialized(): io.reactivex.subjects.Subject<any>;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public onError(param0: java.lang.Throwable): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public constructor();
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public onComplete(): void;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public getThrowable(): java.lang.Throwable;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subjects {
			export class UnicastSubject<T>  extends io.reactivex.subjects.Subject<any> {
				public static class: java.lang.Class<io.reactivex.subjects.UnicastSubject<any>>;
				public static create(): io.reactivex.subjects.UnicastSubject<any>;
				public onSubscribe(d: io.reactivex.disposables.Disposable): void;
				public subscribeActual(observer: io.reactivex.Observer<any>): void;
				public hasThrowable(): boolean;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action): io.reactivex.disposables.Disposable;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(capacityHint: number, onTerminate: java.lang.Runnable, delayError: boolean): io.reactivex.subjects.UnicastSubject<any>;
				public onError(param0: java.lang.Throwable): void;
				public onSubscribe(param0: io.reactivex.disposables.Disposable): void;
				public static create(delayError: boolean): io.reactivex.subjects.UnicastSubject<any>;
				public onComplete(): void;
				public static create(capacityHint: number, onTerminate: java.lang.Runnable): io.reactivex.subjects.UnicastSubject<any>;
				public getThrowable(): java.lang.Throwable;
				public subscribe(param0: io.reactivex.Observer<any>): void;
				public subscribeActual(param0: io.reactivex.Observer<any>): void;
				public hasObservers(): boolean;
				public onNext(t: any): void;
				public static create(capacityHint: number): io.reactivex.subjects.UnicastSubject<any>;
				public subscribe(observer: io.reactivex.Observer<any>): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>, onError: io.reactivex.functions.Consumer<any>, onComplete: io.reactivex.functions.Action, onSubscribe: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public static create(source: io.reactivex.ObservableOnSubscribe<any>): io.reactivex.Observable<any>;
				public hasComplete(): boolean;
				public onNext(param0: any): void;
				public subscribe(onNext: io.reactivex.functions.Consumer<any>): io.reactivex.disposables.Disposable;
				public subscribe(): io.reactivex.disposables.Disposable;
				public onError(t: java.lang.Throwable): void;
			}
			export module UnicastSubject {
				export class UnicastQueueDisposable extends io.reactivex.internal.observers.BasicIntQueueDisposable<any> {
					public static class: java.lang.Class<io.reactivex.subjects.UnicastSubject.UnicastQueueDisposable>;
					public poll(): any;
					public isDisposed(): boolean;
					public requestFusion(mode: number): number;
					public isEmpty(): boolean;
					public clear(): void;
					public dispose(): void;
				}
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export abstract class DefaultSubscriber<T>  extends io.reactivex.FlowableSubscriber<any> {
				public static class: java.lang.Class<io.reactivex.subscribers.DefaultSubscriber<any>>;
				public request(n: number): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onStart(): void;
				public onComplete(): void;
				public onNext(param0: any): void;
				public cancel(): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export abstract class DisposableSubscriber<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.subscribers.DisposableSubscriber<any>>;
				public request(n: number): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onStart(): void;
				public onComplete(): void;
				public isDisposed(): boolean;
				public dispose(): void;
				public cancel(): void;
				public onNext(param0: T): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export abstract class ResourceSubscriber<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.subscribers.ResourceSubscriber<any>>;
				public request(n: number): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onStart(): void;
				public onComplete(): void;
				public dispose(): void;
				public isDisposed(): boolean;
				public add(resource: io.reactivex.disposables.Disposable): void;
				public onNext(param0: T): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export class SafeSubscriber<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.subscribers.SafeSubscriber<any>>;
				public request(n: number): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: T): void;
				public request(param0: number): void;
				public onComplete(): void;
				public cancel(): void;
				public constructor(downstream: org.reactivestreams.Subscriber<any>);
				public onNext(param0: T): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public onError(param0: java.lang.Throwable): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export class SerializedSubscriber<T>  extends java.lang.Object {
				public static class: java.lang.Class<io.reactivex.subscribers.SerializedSubscriber<any>>;
				public request(n: number): void;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: T): void;
				public request(param0: number): void;
				public onComplete(): void;
				public cancel(): void;
				public constructor(downstream: org.reactivestreams.Subscriber<any>);
				public constructor(actual: org.reactivestreams.Subscriber<any>, delayError: boolean);
				public onNext(param0: T): void;
				public onError(t: java.lang.Throwable): void;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
				public onError(param0: java.lang.Throwable): void;
			}
		}
	}
}

declare module io {
	export module reactivex {
		export module subscribers {
			export class TestSubscriber<T>  extends io.reactivex.observers.BaseTestConsumer<any,io.reactivex.subscribers.TestSubscriber<any>> {
				public static class: java.lang.Class<io.reactivex.subscribers.TestSubscriber<any>>;
				public requestMore(n: number): io.reactivex.subscribers.TestSubscriber<any>;
				public isDisposed(): boolean;
				public assertSubscribed(): io.reactivex.subscribers.TestSubscriber<any>;
				public static create(initialRequested: number): io.reactivex.subscribers.TestSubscriber<any>;
				public assertOf(check: io.reactivex.functions.Consumer<any>): io.reactivex.subscribers.TestSubscriber<any>;
				public static create(delegate: org.reactivestreams.Subscriber): io.reactivex.subscribers.TestSubscriber<any>;
				public onError(param0: java.lang.Throwable): void;
				public constructor();
				public request(n: number): void;
				public hasSubscription(): boolean;
				public constructor(initialRequest: number);
				public onComplete(): void;
				public cancel(): void;
				public assertNotSubscribed(): io.reactivex.subscribers.TestSubscriber<any>;
				public assertNotSubscribed(): any;
				public onSubscribe(s: org.reactivestreams.Subscription): void;
				public onNext(t: any): void;
				public constructor(downstream: org.reactivestreams.Subscriber<any>);
				public constructor(actual: org.reactivestreams.Subscriber<any>, initialRequest: number);
				public request(param0: number): void;
				public onStart(): void;
				public assertSubscribed(): any;
				public static create(): io.reactivex.subscribers.TestSubscriber<any>;
				public dispose(): void;
				public onNext(param0: any): void;
				public onError(t: java.lang.Throwable): void;
				public isCancelled(): boolean;
				public onSubscribe(param0: org.reactivestreams.Subscription): void;
			}
			export module TestSubscriber {
				export class EmptySubscriber extends io.reactivex.FlowableSubscriber<any> {
					public static class: java.lang.Class<io.reactivex.subscribers.TestSubscriber.EmptySubscriber>;
					public static INSTANCE: io.reactivex.subscribers.TestSubscriber.EmptySubscriber;
					public onNext(t: any): void;
					public static valueOf(enumType: java.lang.Class<any>, name: string): java.lang.Enum<any>;
					public onError(t: java.lang.Throwable): void;
					public static valueOf(name: string): io.reactivex.subscribers.TestSubscriber.EmptySubscriber;
					public onSubscribe(s: org.reactivestreams.Subscription): void;
					public onComplete(): void;
					public onSubscribe(param0: org.reactivestreams.Subscription): void;
					public static values(): io.reactivex.subscribers.TestSubscriber.EmptySubscriber[];
					public onError(param0: java.lang.Throwable): void;
					public onNext(param0: any): void;
				}
			}
		}
	}
}

//Generics information:
//io.reactivex.CompletableConverter:1
//io.reactivex.Emitter:1
//io.reactivex.Flowable:1
//io.reactivex.FlowableConverter:2
//io.reactivex.FlowableEmitter:1
//io.reactivex.FlowableOnSubscribe:1
//io.reactivex.FlowableOperator:2
//io.reactivex.FlowableSubscriber:1
//io.reactivex.FlowableTransformer:2
//io.reactivex.Maybe:1
//io.reactivex.MaybeConverter:2
//io.reactivex.MaybeEmitter:1
//io.reactivex.MaybeObserver:1
//io.reactivex.MaybeOnSubscribe:1
//io.reactivex.MaybeOperator:2
//io.reactivex.MaybeSource:1
//io.reactivex.MaybeTransformer:2
//io.reactivex.Notification:1
//io.reactivex.Observable:1
//io.reactivex.ObservableConverter:2
//io.reactivex.ObservableEmitter:1
//io.reactivex.ObservableOnSubscribe:1
//io.reactivex.ObservableOperator:2
//io.reactivex.ObservableSource:1
//io.reactivex.ObservableTransformer:2
//io.reactivex.Observer:1
//io.reactivex.Single:1
//io.reactivex.SingleConverter:2
//io.reactivex.SingleEmitter:1
//io.reactivex.SingleObserver:1
//io.reactivex.SingleOnSubscribe:1
//io.reactivex.SingleOperator:2
//io.reactivex.SingleSource:1
//io.reactivex.SingleTransformer:2
//io.reactivex.disposables.ReferenceDisposable:1
//io.reactivex.flowables.ConnectableFlowable:1
//io.reactivex.flowables.GroupedFlowable:2
//io.reactivex.functions.BiConsumer:2
//io.reactivex.functions.BiFunction:3
//io.reactivex.functions.BiPredicate:2
//io.reactivex.functions.Consumer:1
//io.reactivex.functions.Function:2
//io.reactivex.functions.Function3:4
//io.reactivex.functions.Function4:5
//io.reactivex.functions.Function5:6
//io.reactivex.functions.Function6:7
//io.reactivex.functions.Function7:8
//io.reactivex.functions.Function8:9
//io.reactivex.functions.Function9:10
//io.reactivex.functions.IntFunction:1
//io.reactivex.functions.Predicate:1
//io.reactivex.internal.functions.Functions.ActionConsumer:1
//io.reactivex.internal.functions.Functions.Array2Func:3
//io.reactivex.internal.functions.Functions.Array3Func:4
//io.reactivex.internal.functions.Functions.Array4Func:5
//io.reactivex.internal.functions.Functions.Array5Func:6
//io.reactivex.internal.functions.Functions.Array6Func:7
//io.reactivex.internal.functions.Functions.Array7Func:8
//io.reactivex.internal.functions.Functions.Array8Func:9
//io.reactivex.internal.functions.Functions.Array9Func:10
//io.reactivex.internal.functions.Functions.ArrayListCapacityCallable:1
//io.reactivex.internal.functions.Functions.BooleanSupplierPredicateReverse:1
//io.reactivex.internal.functions.Functions.CastToClass:2
//io.reactivex.internal.functions.Functions.ClassFilter:2
//io.reactivex.internal.functions.Functions.EqualsPredicate:1
//io.reactivex.internal.functions.Functions.JustValue:2
//io.reactivex.internal.functions.Functions.ListSorter:1
//io.reactivex.internal.functions.Functions.NotificationOnComplete:1
//io.reactivex.internal.functions.Functions.NotificationOnError:1
//io.reactivex.internal.functions.Functions.NotificationOnNext:1
//io.reactivex.internal.functions.Functions.TimestampFunction:1
//io.reactivex.internal.functions.Functions.ToMapKeySelector:2
//io.reactivex.internal.functions.Functions.ToMapKeyValueSelector:3
//io.reactivex.internal.functions.Functions.ToMultimapKeyValueSelector:3
//io.reactivex.internal.fuseable.ConditionalSubscriber:1
//io.reactivex.internal.fuseable.FuseToFlowable:1
//io.reactivex.internal.fuseable.FuseToMaybe:1
//io.reactivex.internal.fuseable.FuseToObservable:1
//io.reactivex.internal.fuseable.HasUpstreamMaybeSource:1
//io.reactivex.internal.fuseable.HasUpstreamObservableSource:1
//io.reactivex.internal.fuseable.HasUpstreamPublisher:1
//io.reactivex.internal.fuseable.HasUpstreamSingleSource:1
//io.reactivex.internal.fuseable.QueueDisposable:1
//io.reactivex.internal.fuseable.QueueFuseable:1
//io.reactivex.internal.fuseable.QueueSubscription:1
//io.reactivex.internal.fuseable.ScalarCallable:1
//io.reactivex.internal.fuseable.SimplePlainQueue:1
//io.reactivex.internal.fuseable.SimpleQueue:1
//io.reactivex.internal.observers.BasicFuseableObserver:2
//io.reactivex.internal.observers.BasicIntQueueDisposable:1
//io.reactivex.internal.observers.BasicQueueDisposable:1
//io.reactivex.internal.observers.BiConsumerSingleObserver:1
//io.reactivex.internal.observers.BlockingBaseObserver:1
//io.reactivex.internal.observers.BlockingFirstObserver:1
//io.reactivex.internal.observers.BlockingLastObserver:1
//io.reactivex.internal.observers.BlockingMultiObserver:1
//io.reactivex.internal.observers.BlockingObserver:1
//io.reactivex.internal.observers.ConsumerSingleObserver:1
//io.reactivex.internal.observers.DeferredScalarDisposable:1
//io.reactivex.internal.observers.DeferredScalarObserver:2
//io.reactivex.internal.observers.DisposableLambdaObserver:1
//io.reactivex.internal.observers.ForEachWhileObserver:1
//io.reactivex.internal.observers.FutureObserver:1
//io.reactivex.internal.observers.FutureSingleObserver:1
//io.reactivex.internal.observers.InnerQueuedObserver:1
//io.reactivex.internal.observers.InnerQueuedObserverSupport:1
//io.reactivex.internal.observers.LambdaObserver:1
//io.reactivex.internal.observers.QueueDrainObserver:3
//io.reactivex.internal.observers.ResumeSingleObserver:1
//io.reactivex.internal.observers.SubscriberCompletableObserver:1
//io.reactivex.internal.operators.completable.CompletableFromObservable:1
//io.reactivex.internal.operators.completable.CompletableFromObservable.CompletableFromObservableObserver:1
//io.reactivex.internal.operators.completable.CompletableFromPublisher:1
//io.reactivex.internal.operators.completable.CompletableFromPublisher.FromPublisherSubscriber:1
//io.reactivex.internal.operators.completable.CompletableFromSingle:1
//io.reactivex.internal.operators.completable.CompletableFromSingle.CompletableFromSingleObserver:1
//io.reactivex.internal.operators.completable.CompletableMaterialize:1
//io.reactivex.internal.operators.completable.CompletableToFlowable:1
//io.reactivex.internal.operators.completable.CompletableToObservable:1
//io.reactivex.internal.operators.completable.CompletableToSingle:1
//io.reactivex.internal.operators.completable.CompletableUsing:1
//io.reactivex.internal.operators.completable.CompletableUsing.UsingObserver:1
//io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream:2
//io.reactivex.internal.operators.flowable.BlockingFlowableIterable:1
//io.reactivex.internal.operators.flowable.BlockingFlowableIterable.BlockingFlowableIterator:1
//io.reactivex.internal.operators.flowable.BlockingFlowableLatest:1
//io.reactivex.internal.operators.flowable.BlockingFlowableLatest.LatestSubscriberIterator:1
//io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent:1
//io.reactivex.internal.operators.flowable.BlockingFlowableMostRecent.MostRecentSubscriber:1
//io.reactivex.internal.operators.flowable.BlockingFlowableNext:1
//io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextIterator:1
//io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAll:1
//io.reactivex.internal.operators.flowable.FlowableAll.AllSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAllSingle:1
//io.reactivex.internal.operators.flowable.FlowableAllSingle.AllSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAmb:1
//io.reactivex.internal.operators.flowable.FlowableAmb.AmbCoordinator:1
//io.reactivex.internal.operators.flowable.FlowableAmb.AmbInnerSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAny:1
//io.reactivex.internal.operators.flowable.FlowableAny.AnySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAnySingle:1
//io.reactivex.internal.operators.flowable.FlowableAnySingle.AnySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableAutoConnect:1
//io.reactivex.internal.operators.flowable.FlowableBuffer:2
//io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferExactSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferOverlappingSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBuffer.PublisherBufferSkipSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBufferBoundary:4
//io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferBoundarySubscriber:4
//io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferBoundarySubscriber.BufferOpenSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableBufferBoundary.BufferCloseSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier:3
//io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier.BufferBoundarySubscriber:3
//io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier.BufferBoundarySupplierSubscriber:3
//io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary:3
//io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary.BufferBoundarySubscriber:3
//io.reactivex.internal.operators.flowable.FlowableBufferExactBoundary.BufferExactBoundarySubscriber:3
//io.reactivex.internal.operators.flowable.FlowableBufferTimed:2
//io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferExactBoundedSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferExactUnboundedSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableBufferTimed.BufferSkipBoundedSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableCache:1
//io.reactivex.internal.operators.flowable.FlowableCache.CacheSubscription:1
//io.reactivex.internal.operators.flowable.FlowableCache.Node:1
//io.reactivex.internal.operators.flowable.FlowableCollect:2
//io.reactivex.internal.operators.flowable.FlowableCollect.CollectSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableCollectSingle:2
//io.reactivex.internal.operators.flowable.FlowableCollectSingle.CollectSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableCombineLatest:2
//io.reactivex.internal.operators.flowable.FlowableCombineLatest.CombineLatestCoordinator:2
//io.reactivex.internal.operators.flowable.FlowableCombineLatest.CombineLatestInnerSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableConcatArray:1
//io.reactivex.internal.operators.flowable.FlowableConcatArray.ConcatArraySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableConcatMap:2
//io.reactivex.internal.operators.flowable.FlowableConcatMap.BaseConcatMapSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapDelayed:2
//io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapImmediate:2
//io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapInner:1
//io.reactivex.internal.operators.flowable.FlowableConcatMap.ConcatMapSupport:1
//io.reactivex.internal.operators.flowable.FlowableConcatMap.SimpleScalarSubscription:1
//io.reactivex.internal.operators.flowable.FlowableConcatMapEager:2
//io.reactivex.internal.operators.flowable.FlowableConcatMapEager.ConcatMapEagerDelayErrorSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableConcatMapEagerPublisher:2
//io.reactivex.internal.operators.flowable.FlowableConcatMapPublisher:2
//io.reactivex.internal.operators.flowable.FlowableConcatWithCompletable:1
//io.reactivex.internal.operators.flowable.FlowableConcatWithCompletable.ConcatWithSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableConcatWithMaybe:1
//io.reactivex.internal.operators.flowable.FlowableConcatWithMaybe.ConcatWithSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableConcatWithSingle:1
//io.reactivex.internal.operators.flowable.FlowableConcatWithSingle.ConcatWithSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableCount:1
//io.reactivex.internal.operators.flowable.FlowableCountSingle:1
//io.reactivex.internal.operators.flowable.FlowableCreate:1
//io.reactivex.internal.operators.flowable.FlowableCreate.BaseEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.BufferAsyncEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.DropAsyncEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.ErrorAsyncEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.LatestAsyncEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.MissingEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.NoOverflowBaseAsyncEmitter:1
//io.reactivex.internal.operators.flowable.FlowableCreate.SerializedEmitter:1
//io.reactivex.internal.operators.flowable.FlowableDebounce:2
//io.reactivex.internal.operators.flowable.FlowableDebounce.DebounceSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDebounce.DebounceSubscriber.DebounceInnerSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDebounceTimed:1
//io.reactivex.internal.operators.flowable.FlowableDebounceTimed.DebounceEmitter:1
//io.reactivex.internal.operators.flowable.FlowableDebounceTimed.DebounceTimedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDefer:1
//io.reactivex.internal.operators.flowable.FlowableDelay:1
//io.reactivex.internal.operators.flowable.FlowableDelay.DelaySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther:2
//io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther.MainSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDematerialize:2
//io.reactivex.internal.operators.flowable.FlowableDematerialize.DematerializeSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDetach:1
//io.reactivex.internal.operators.flowable.FlowableDetach.DetachSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDistinct:2
//io.reactivex.internal.operators.flowable.FlowableDistinct.DistinctSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged:2
//io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged.DistinctUntilChangedConditionalSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged.DistinctUntilChangedSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableDoAfterNext:1
//io.reactivex.internal.operators.flowable.FlowableDoAfterNext.DoAfterConditionalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoAfterNext.DoAfterSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoFinally:1
//io.reactivex.internal.operators.flowable.FlowableDoFinally.DoFinallyConditionalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoFinally.DoFinallySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoOnEach:1
//io.reactivex.internal.operators.flowable.FlowableDoOnEach.DoOnEachConditionalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoOnEach.DoOnEachSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle:1
//io.reactivex.internal.operators.flowable.FlowableDoOnLifecycle.SubscriptionLambdaSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableElementAt:1
//io.reactivex.internal.operators.flowable.FlowableElementAt.ElementAtSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableElementAtMaybe:1
//io.reactivex.internal.operators.flowable.FlowableElementAtMaybe.ElementAtSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableElementAtSingle:1
//io.reactivex.internal.operators.flowable.FlowableElementAtSingle.ElementAtSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableError:1
//io.reactivex.internal.operators.flowable.FlowableFilter:1
//io.reactivex.internal.operators.flowable.FlowableFilter.FilterConditionalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableFilter.FilterSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableFlatMap:2
//io.reactivex.internal.operators.flowable.FlowableFlatMap.InnerSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableFlatMap.MergeSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable:1
//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletable.FlatMapCompletableMainSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable:1
//io.reactivex.internal.operators.flowable.FlowableFlatMapCompletableCompletable.FlatMapCompletableMainSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe:2
//io.reactivex.internal.operators.flowable.FlowableFlatMapMaybe.FlatMapMaybeSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableFlatMapPublisher:2
//io.reactivex.internal.operators.flowable.FlowableFlatMapSingle:2
//io.reactivex.internal.operators.flowable.FlowableFlatMapSingle.FlatMapSingleSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableFlattenIterable:2
//io.reactivex.internal.operators.flowable.FlowableFlattenIterable.FlattenIterableSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableFromArray:1
//io.reactivex.internal.operators.flowable.FlowableFromArray.ArrayConditionalSubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromArray.ArraySubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromArray.BaseArraySubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromCallable:1
//io.reactivex.internal.operators.flowable.FlowableFromFuture:1
//io.reactivex.internal.operators.flowable.FlowableFromIterable:1
//io.reactivex.internal.operators.flowable.FlowableFromIterable.BaseRangeSubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromIterable.IteratorConditionalSubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromIterable.IteratorSubscription:1
//io.reactivex.internal.operators.flowable.FlowableFromObservable:1
//io.reactivex.internal.operators.flowable.FlowableFromObservable.SubscriberObserver:1
//io.reactivex.internal.operators.flowable.FlowableFromPublisher:1
//io.reactivex.internal.operators.flowable.FlowableGenerate:2
//io.reactivex.internal.operators.flowable.FlowableGenerate.GeneratorSubscription:2
//io.reactivex.internal.operators.flowable.FlowableGroupBy:3
//io.reactivex.internal.operators.flowable.FlowableGroupBy.EvictionAction:2
//io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupBySubscriber:3
//io.reactivex.internal.operators.flowable.FlowableGroupBy.GroupedUnicast:2
//io.reactivex.internal.operators.flowable.FlowableGroupBy.State:2
//io.reactivex.internal.operators.flowable.FlowableGroupJoin:5
//io.reactivex.internal.operators.flowable.FlowableGroupJoin.GroupJoinSubscription:5
//io.reactivex.internal.operators.flowable.FlowableHide:1
//io.reactivex.internal.operators.flowable.FlowableHide.HideSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableIgnoreElements:1
//io.reactivex.internal.operators.flowable.FlowableIgnoreElements.IgnoreElementsSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable:1
//io.reactivex.internal.operators.flowable.FlowableIgnoreElementsCompletable.IgnoreElementsSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.BufferedReplayCallable:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.BufferedTimedReplay:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapIntoIterable:2
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapWithCombinerInner:3
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.FlatMapWithCombinerOuter:3
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.ItemDelayFunction:2
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.ReplayCallable:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.ReplayFunction:2
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.SimpleBiGenerator:2
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.SimpleGenerator:2
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnComplete:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnError:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.SubscriberOnNext:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.TimedReplay:1
//io.reactivex.internal.operators.flowable.FlowableInternalHelper.ZipIterableFunction:2
//io.reactivex.internal.operators.flowable.FlowableJoin:5
//io.reactivex.internal.operators.flowable.FlowableJoin.JoinSubscription:5
//io.reactivex.internal.operators.flowable.FlowableJust:1
//io.reactivex.internal.operators.flowable.FlowableLastMaybe:1
//io.reactivex.internal.operators.flowable.FlowableLastMaybe.LastSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableLastSingle:1
//io.reactivex.internal.operators.flowable.FlowableLastSingle.LastSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableLift:2
//io.reactivex.internal.operators.flowable.FlowableLimit:1
//io.reactivex.internal.operators.flowable.FlowableLimit.LimitSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableMap:2
//io.reactivex.internal.operators.flowable.FlowableMap.MapConditionalSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableMap.MapSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableMapNotification:2
//io.reactivex.internal.operators.flowable.FlowableMapNotification.MapNotificationSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableMapPublisher:2
//io.reactivex.internal.operators.flowable.FlowableMaterialize:1
//io.reactivex.internal.operators.flowable.FlowableMaterialize.MaterializeSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithCompletable:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithCompletable.MergeWithSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe.MergeWithObserver:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithMaybe.MergeWithObserver.OtherObserver:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithSingle:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithSingle.MergeWithObserver:1
//io.reactivex.internal.operators.flowable.FlowableMergeWithSingle.MergeWithObserver.OtherObserver:1
//io.reactivex.internal.operators.flowable.FlowableObserveOn:1
//io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableObserveOn.ObserveOnConditionalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableObserveOn.ObserveOnSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer.BackpressureBufferSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureBufferStrategy.OnBackpressureBufferStrategySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureDrop.BackpressureDropSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureError:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureError.BackpressureErrorSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest:1
//io.reactivex.internal.operators.flowable.FlowableOnBackpressureLatest.BackpressureLatestSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnErrorNext:1
//io.reactivex.internal.operators.flowable.FlowableOnErrorNext.OnErrorNextSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableOnErrorReturn:1
//io.reactivex.internal.operators.flowable.FlowableOnErrorReturn.OnErrorReturnSubscriber:1
//io.reactivex.internal.operators.flowable.FlowablePublish:1
//io.reactivex.internal.operators.flowable.FlowablePublish.FlowablePublisher:1
//io.reactivex.internal.operators.flowable.FlowablePublish.InnerSubscriber:1
//io.reactivex.internal.operators.flowable.FlowablePublish.PublishSubscriber:1
//io.reactivex.internal.operators.flowable.FlowablePublishAlt:1
//io.reactivex.internal.operators.flowable.FlowablePublishAlt.InnerSubscription:1
//io.reactivex.internal.operators.flowable.FlowablePublishAlt.PublishConnection:1
//io.reactivex.internal.operators.flowable.FlowablePublishClassic:1
//io.reactivex.internal.operators.flowable.FlowablePublishMulticast:2
//io.reactivex.internal.operators.flowable.FlowablePublishMulticast.MulticastProcessor:1
//io.reactivex.internal.operators.flowable.FlowablePublishMulticast.MulticastSubscription:1
//io.reactivex.internal.operators.flowable.FlowablePublishMulticast.OutputCanceller:1
//io.reactivex.internal.operators.flowable.FlowableReduce:1
//io.reactivex.internal.operators.flowable.FlowableReduce.ReduceSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableReduceMaybe:1
//io.reactivex.internal.operators.flowable.FlowableReduceMaybe.ReduceSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle:2
//io.reactivex.internal.operators.flowable.FlowableReduceSeedSingle.ReduceSeedObserver:2
//io.reactivex.internal.operators.flowable.FlowableReduceWithSingle:2
//io.reactivex.internal.operators.flowable.FlowableRefCount:1
//io.reactivex.internal.operators.flowable.FlowableRefCount.RefCountSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRepeat:1
//io.reactivex.internal.operators.flowable.FlowableRepeat.RepeatSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRepeatUntil:1
//io.reactivex.internal.operators.flowable.FlowableRepeatUntil.RepeatSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRepeatWhen:1
//io.reactivex.internal.operators.flowable.FlowableRepeatWhen.RepeatWhenSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenReceiver:2
//io.reactivex.internal.operators.flowable.FlowableRepeatWhen.WhenSourceSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableReplay:1
//io.reactivex.internal.operators.flowable.FlowableReplay.BoundedReplayBuffer:1
//io.reactivex.internal.operators.flowable.FlowableReplay.ConnectableFlowableReplay:1
//io.reactivex.internal.operators.flowable.FlowableReplay.InnerSubscription:1
//io.reactivex.internal.operators.flowable.FlowableReplay.MulticastFlowable:2
//io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBuffer:1
//io.reactivex.internal.operators.flowable.FlowableReplay.ReplayBufferTask:1
//io.reactivex.internal.operators.flowable.FlowableReplay.ReplayPublisher:1
//io.reactivex.internal.operators.flowable.FlowableReplay.ReplaySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableReplay.ScheduledReplayBufferTask:1
//io.reactivex.internal.operators.flowable.FlowableReplay.SizeAndTimeBoundReplayBuffer:1
//io.reactivex.internal.operators.flowable.FlowableReplay.SizeBoundReplayBuffer:1
//io.reactivex.internal.operators.flowable.FlowableReplay.UnboundedReplayBuffer:1
//io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate:1
//io.reactivex.internal.operators.flowable.FlowableRetryBiPredicate.RetryBiSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRetryPredicate:1
//io.reactivex.internal.operators.flowable.FlowableRetryPredicate.RetrySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableRetryWhen:1
//io.reactivex.internal.operators.flowable.FlowableRetryWhen.RetryWhenSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSamplePublisher:1
//io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SampleMainEmitLast:1
//io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SampleMainNoLast:1
//io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplePublisherSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSamplePublisher.SamplerSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSampleTimed:1
//io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedEmitLast:1
//io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedNoLast:1
//io.reactivex.internal.operators.flowable.FlowableSampleTimed.SampleTimedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableScalarXMap.ScalarXMapFlowable:2
//io.reactivex.internal.operators.flowable.FlowableScan:1
//io.reactivex.internal.operators.flowable.FlowableScan.ScanSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableScanSeed:2
//io.reactivex.internal.operators.flowable.FlowableScanSeed.ScanSeedSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableSequenceEqual:1
//io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualCoordinator:1
//io.reactivex.internal.operators.flowable.FlowableSequenceEqual.EqualSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle:1
//io.reactivex.internal.operators.flowable.FlowableSequenceEqualSingle.EqualCoordinator:1
//io.reactivex.internal.operators.flowable.FlowableSerialized:1
//io.reactivex.internal.operators.flowable.FlowableSingle:1
//io.reactivex.internal.operators.flowable.FlowableSingle.SingleElementSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSingleMaybe:1
//io.reactivex.internal.operators.flowable.FlowableSingleMaybe.SingleElementSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSingleSingle:1
//io.reactivex.internal.operators.flowable.FlowableSingleSingle.SingleElementSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSkip:1
//io.reactivex.internal.operators.flowable.FlowableSkip.SkipSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSkipLast:1
//io.reactivex.internal.operators.flowable.FlowableSkipLast.SkipLastSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSkipLastTimed:1
//io.reactivex.internal.operators.flowable.FlowableSkipLastTimed.SkipLastTimedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSkipUntil:2
//io.reactivex.internal.operators.flowable.FlowableSkipUntil.SkipUntilMainSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSkipWhile:1
//io.reactivex.internal.operators.flowable.FlowableSkipWhile.SkipWhileSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSubscribeOn:1
//io.reactivex.internal.operators.flowable.FlowableSubscribeOn.SubscribeOnSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty:1
//io.reactivex.internal.operators.flowable.FlowableSwitchIfEmpty.SwitchIfEmptySubscriber:1
//io.reactivex.internal.operators.flowable.FlowableSwitchMap:2
//io.reactivex.internal.operators.flowable.FlowableSwitchMap.SwitchMapInnerSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableSwitchMap.SwitchMapSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableTake:1
//io.reactivex.internal.operators.flowable.FlowableTake.TakeSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakeLast:1
//io.reactivex.internal.operators.flowable.FlowableTakeLast.TakeLastSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakeLastOne:1
//io.reactivex.internal.operators.flowable.FlowableTakeLastOne.TakeLastOneSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakeLastTimed:1
//io.reactivex.internal.operators.flowable.FlowableTakeLastTimed.TakeLastTimedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakePublisher:1
//io.reactivex.internal.operators.flowable.FlowableTakeUntil:2
//io.reactivex.internal.operators.flowable.FlowableTakeUntil.TakeUntilMainSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate:1
//io.reactivex.internal.operators.flowable.FlowableTakeUntilPredicate.InnerSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTakeWhile:1
//io.reactivex.internal.operators.flowable.FlowableTakeWhile.TakeWhileSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed:1
//io.reactivex.internal.operators.flowable.FlowableThrottleFirstTimed.DebounceTimedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableThrottleLatest:1
//io.reactivex.internal.operators.flowable.FlowableThrottleLatest.ThrottleLatestSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeInterval:1
//io.reactivex.internal.operators.flowable.FlowableTimeInterval.TimeIntervalSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeout:3
//io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutFallbackSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeout.TimeoutSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeoutTimed:1
//io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.FallbackSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutFallbackSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableToList:2
//io.reactivex.internal.operators.flowable.FlowableToList.ToListSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableToListSingle:2
//io.reactivex.internal.operators.flowable.FlowableToListSingle.ToListSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn:1
//io.reactivex.internal.operators.flowable.FlowableUnsubscribeOn.UnsubscribeSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableUsing:2
//io.reactivex.internal.operators.flowable.FlowableUsing.UsingSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindow:1
//io.reactivex.internal.operators.flowable.FlowableWindow.WindowExactSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindow.WindowOverlapSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindow.WindowSkipSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindowBoundary:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundary.WindowBoundaryInnerSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundary.WindowBoundaryMainSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector:3
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.OperatorWindowBoundaryCloseSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.OperatorWindowBoundaryOpenSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.WindowBoundaryMainSubscriber:3
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySelector.WindowOperation:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier.WindowBoundaryInnerSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowBoundarySupplier.WindowBoundaryMainSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableWindowTimed:1
//io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowExactBoundedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowExactUnboundedSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowSkipSubscriber:1
//io.reactivex.internal.operators.flowable.FlowableWindowTimed.WindowSkipSubscriber.SubjectWork:1
//io.reactivex.internal.operators.flowable.FlowableWithLatestFrom:3
//io.reactivex.internal.operators.flowable.FlowableWithLatestFrom.WithLatestFromSubscriber:3
//io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany:2
//io.reactivex.internal.operators.flowable.FlowableWithLatestFromMany.WithLatestFromSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableZip:2
//io.reactivex.internal.operators.flowable.FlowableZip.ZipCoordinator:2
//io.reactivex.internal.operators.flowable.FlowableZip.ZipSubscriber:2
//io.reactivex.internal.operators.flowable.FlowableZipIterable:3
//io.reactivex.internal.operators.flowable.FlowableZipIterable.ZipIterableSubscriber:3
//io.reactivex.internal.operators.maybe.AbstractMaybeWithUpstream:2
//io.reactivex.internal.operators.maybe.MaybeAmb:1
//io.reactivex.internal.operators.maybe.MaybeAmb.AmbMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeCache:1
//io.reactivex.internal.operators.maybe.MaybeCache.CacheDisposable:1
//io.reactivex.internal.operators.maybe.MaybeCallbackObserver:1
//io.reactivex.internal.operators.maybe.MaybeConcatArray:1
//io.reactivex.internal.operators.maybe.MaybeConcatArray.ConcatMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError:1
//io.reactivex.internal.operators.maybe.MaybeConcatArrayDelayError.ConcatMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeConcatIterable:1
//io.reactivex.internal.operators.maybe.MaybeConcatIterable.ConcatMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeContains:1
//io.reactivex.internal.operators.maybe.MaybeCount:1
//io.reactivex.internal.operators.maybe.MaybeCreate:1
//io.reactivex.internal.operators.maybe.MaybeCreate.Emitter:1
//io.reactivex.internal.operators.maybe.MaybeDefer:1
//io.reactivex.internal.operators.maybe.MaybeDelay:1
//io.reactivex.internal.operators.maybe.MaybeDelay.DelayMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher:2
//io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher.DelayMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeDelayOtherPublisher.OtherSubscriber:1
//io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher:2
//io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher.DelayMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeDelaySubscriptionOtherPublisher.OtherSubscriber:1
//io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable:1
//io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable.DelayWithMainObserver:1
//io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable.OtherObserver:1
//io.reactivex.internal.operators.maybe.MaybeDetach:1
//io.reactivex.internal.operators.maybe.MaybeDetach.DetachMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess:1
//io.reactivex.internal.operators.maybe.MaybeDoAfterSuccess.DoAfterObserver:1
//io.reactivex.internal.operators.maybe.MaybeDoFinally:1
//io.reactivex.internal.operators.maybe.MaybeDoFinally.DoFinallyObserver:1
//io.reactivex.internal.operators.maybe.MaybeDoOnEvent:1
//io.reactivex.internal.operators.maybe.MaybeDoOnEvent.DoOnEventMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeDoOnTerminate:1
//io.reactivex.internal.operators.maybe.MaybeEqualSingle:1
//io.reactivex.internal.operators.maybe.MaybeEqualSingle.EqualCoordinator:1
//io.reactivex.internal.operators.maybe.MaybeEqualSingle.EqualObserver:1
//io.reactivex.internal.operators.maybe.MaybeError:1
//io.reactivex.internal.operators.maybe.MaybeErrorCallable:1
//io.reactivex.internal.operators.maybe.MaybeFilter:1
//io.reactivex.internal.operators.maybe.MaybeFilter.FilterMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeFilterSingle:1
//io.reactivex.internal.operators.maybe.MaybeFilterSingle.FilterMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector:3
//io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector.FlatMapBiMainObserver:3
//io.reactivex.internal.operators.maybe.MaybeFlatMapBiSelector.FlatMapBiMainObserver.InnerObserver:3
//io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable:1
//io.reactivex.internal.operators.maybe.MaybeFlatMapCompletable.FlatMapCompletableObserver:1
//io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapIterableFlowable.FlatMapIterableObserver:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapIterableObservable.FlatMapIterableObserver:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapNotification:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapNotification.FlatMapMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingle:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingle.FlatMapMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingle.FlatMapSingleObserver:1
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement.FlatMapMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeFlatMapSingleElement.FlatMapSingleObserver:1
//io.reactivex.internal.operators.maybe.MaybeFlatten:2
//io.reactivex.internal.operators.maybe.MaybeFlatten.FlatMapMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeFromAction:1
//io.reactivex.internal.operators.maybe.MaybeFromCallable:1
//io.reactivex.internal.operators.maybe.MaybeFromCompletable:1
//io.reactivex.internal.operators.maybe.MaybeFromCompletable.FromCompletableObserver:1
//io.reactivex.internal.operators.maybe.MaybeFromFuture:1
//io.reactivex.internal.operators.maybe.MaybeFromRunnable:1
//io.reactivex.internal.operators.maybe.MaybeFromSingle:1
//io.reactivex.internal.operators.maybe.MaybeFromSingle.FromSingleObserver:1
//io.reactivex.internal.operators.maybe.MaybeHide:1
//io.reactivex.internal.operators.maybe.MaybeHide.HideMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeIgnoreElement:1
//io.reactivex.internal.operators.maybe.MaybeIgnoreElement.IgnoreMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable:1
//io.reactivex.internal.operators.maybe.MaybeIgnoreElementCompletable.IgnoreMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeIsEmpty:1
//io.reactivex.internal.operators.maybe.MaybeIsEmpty.IsEmptyMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeIsEmptySingle:1
//io.reactivex.internal.operators.maybe.MaybeIsEmptySingle.IsEmptyMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeJust:1
//io.reactivex.internal.operators.maybe.MaybeLift:2
//io.reactivex.internal.operators.maybe.MaybeMap:2
//io.reactivex.internal.operators.maybe.MaybeMap.MapMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeMaterialize:1
//io.reactivex.internal.operators.maybe.MaybeMergeArray:1
//io.reactivex.internal.operators.maybe.MaybeMergeArray.ClqSimpleQueue:1
//io.reactivex.internal.operators.maybe.MaybeMergeArray.MergeMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeMergeArray.MpscFillOnceSimpleQueue:1
//io.reactivex.internal.operators.maybe.MaybeMergeArray.SimpleQueueWithConsumerIndex:1
//io.reactivex.internal.operators.maybe.MaybeObserveOn:1
//io.reactivex.internal.operators.maybe.MaybeObserveOn.ObserveOnMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorComplete:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorComplete.OnErrorCompleteMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorNext:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorNext.OnErrorNextMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorNext.OnErrorNextMaybeObserver.NextMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorReturn:1
//io.reactivex.internal.operators.maybe.MaybeOnErrorReturn.OnErrorReturnMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybePeek:1
//io.reactivex.internal.operators.maybe.MaybePeek.MaybePeekObserver:1
//io.reactivex.internal.operators.maybe.MaybeSubscribeOn:1
//io.reactivex.internal.operators.maybe.MaybeSubscribeOn.SubscribeOnMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeSubscribeOn.SubscribeTask:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty.SwitchIfEmptyMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmpty.SwitchIfEmptyMaybeObserver.OtherMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle.SwitchIfEmptyMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeSwitchIfEmptySingle.SwitchIfEmptyMaybeObserver.OtherSingleObserver:1
//io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe:2
//io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe.TakeUntilMainMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeTakeUntilMaybe.TakeUntilMainMaybeObserver.TakeUntilOtherMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher:2
//io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher.TakeUntilMainMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeTakeUntilPublisher.TakeUntilMainMaybeObserver.TakeUntilOtherMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe:2
//io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutFallbackMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutMainMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeTimeoutMaybe.TimeoutOtherMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher:2
//io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutFallbackMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutMainMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeTimeoutPublisher.TimeoutOtherMaybeObserver:2
//io.reactivex.internal.operators.maybe.MaybeToFlowable:1
//io.reactivex.internal.operators.maybe.MaybeToFlowable.MaybeToFlowableSubscriber:1
//io.reactivex.internal.operators.maybe.MaybeToObservable:1
//io.reactivex.internal.operators.maybe.MaybeToObservable.MaybeToObservableObserver:1
//io.reactivex.internal.operators.maybe.MaybeToSingle:1
//io.reactivex.internal.operators.maybe.MaybeToSingle.ToSingleMaybeSubscriber:1
//io.reactivex.internal.operators.maybe.MaybeUnsafeCreate:1
//io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn:1
//io.reactivex.internal.operators.maybe.MaybeUnsubscribeOn.UnsubscribeOnMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeUsing:2
//io.reactivex.internal.operators.maybe.MaybeUsing.UsingObserver:2
//io.reactivex.internal.operators.maybe.MaybeZipArray:2
//io.reactivex.internal.operators.maybe.MaybeZipArray.ZipCoordinator:2
//io.reactivex.internal.operators.maybe.MaybeZipArray.ZipMaybeObserver:1
//io.reactivex.internal.operators.maybe.MaybeZipIterable:2
//io.reactivex.internal.operators.mixed.CompletableAndThenObservable:1
//io.reactivex.internal.operators.mixed.CompletableAndThenObservable.AndThenObservableObserver:1
//io.reactivex.internal.operators.mixed.CompletableAndThenPublisher:1
//io.reactivex.internal.operators.mixed.CompletableAndThenPublisher.AndThenPublisherSubscriber:1
//io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable:1
//io.reactivex.internal.operators.mixed.FlowableConcatMapCompletable.ConcatMapCompletableObserver:1
//io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe:2
//io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber:2
//io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe.ConcatMapMaybeSubscriber.ConcatMapMaybeObserver:1
//io.reactivex.internal.operators.mixed.FlowableConcatMapSingle:2
//io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber:2
//io.reactivex.internal.operators.mixed.FlowableConcatMapSingle.ConcatMapSingleSubscriber.ConcatMapSingleObserver:1
//io.reactivex.internal.operators.mixed.FlowableSwitchMapCompletable:1
//io.reactivex.internal.operators.mixed.FlowableSwitchMapCompletable.SwitchMapCompletableObserver:1
//io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe:2
//io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe.SwitchMapMaybeSubscriber:2
//io.reactivex.internal.operators.mixed.FlowableSwitchMapMaybe.SwitchMapMaybeSubscriber.SwitchMapMaybeObserver:1
//io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle:2
//io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle.SwitchMapSingleSubscriber:2
//io.reactivex.internal.operators.mixed.FlowableSwitchMapSingle.SwitchMapSingleSubscriber.SwitchMapSingleObserver:1
//io.reactivex.internal.operators.mixed.MaterializeSingleObserver:1
//io.reactivex.internal.operators.mixed.MaybeFlatMapObservable:2
//io.reactivex.internal.operators.mixed.MaybeFlatMapObservable.FlatMapObserver:2
//io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher:2
//io.reactivex.internal.operators.mixed.MaybeFlatMapPublisher.FlatMapPublisherSubscriber:2
//io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable:1
//io.reactivex.internal.operators.mixed.ObservableConcatMapCompletable.ConcatMapCompletableObserver:1
//io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe:2
//io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe.ConcatMapMaybeMainObserver:2
//io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe.ConcatMapMaybeMainObserver.ConcatMapMaybeObserver:1
//io.reactivex.internal.operators.mixed.ObservableConcatMapSingle:2
//io.reactivex.internal.operators.mixed.ObservableConcatMapSingle.ConcatMapSingleMainObserver:2
//io.reactivex.internal.operators.mixed.ObservableConcatMapSingle.ConcatMapSingleMainObserver.ConcatMapSingleObserver:1
//io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable:1
//io.reactivex.internal.operators.mixed.ObservableSwitchMapCompletable.SwitchMapCompletableObserver:1
//io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe:2
//io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe.SwitchMapMaybeMainObserver:2
//io.reactivex.internal.operators.mixed.ObservableSwitchMapMaybe.SwitchMapMaybeMainObserver.SwitchMapMaybeObserver:1
//io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle:2
//io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle.SwitchMapSingleMainObserver:2
//io.reactivex.internal.operators.mixed.ObservableSwitchMapSingle.SwitchMapSingleMainObserver.SwitchMapSingleObserver:1
//io.reactivex.internal.operators.mixed.SingleFlatMapObservable:2
//io.reactivex.internal.operators.mixed.SingleFlatMapObservable.FlatMapObserver:2
//io.reactivex.internal.operators.observable.AbstractObservableWithUpstream:2
//io.reactivex.internal.operators.observable.BlockingObservableIterable:1
//io.reactivex.internal.operators.observable.BlockingObservableIterable.BlockingObservableIterator:1
//io.reactivex.internal.operators.observable.BlockingObservableLatest:1
//io.reactivex.internal.operators.observable.BlockingObservableLatest.BlockingObservableLatestIterator:1
//io.reactivex.internal.operators.observable.BlockingObservableMostRecent:1
//io.reactivex.internal.operators.observable.BlockingObservableMostRecent.MostRecentObserver:1
//io.reactivex.internal.operators.observable.BlockingObservableNext:1
//io.reactivex.internal.operators.observable.BlockingObservableNext.NextIterator:1
//io.reactivex.internal.operators.observable.BlockingObservableNext.NextObserver:1
//io.reactivex.internal.operators.observable.ObservableAll:1
//io.reactivex.internal.operators.observable.ObservableAll.AllObserver:1
//io.reactivex.internal.operators.observable.ObservableAllSingle:1
//io.reactivex.internal.operators.observable.ObservableAllSingle.AllObserver:1
//io.reactivex.internal.operators.observable.ObservableAmb:1
//io.reactivex.internal.operators.observable.ObservableAmb.AmbCoordinator:1
//io.reactivex.internal.operators.observable.ObservableAmb.AmbInnerObserver:1
//io.reactivex.internal.operators.observable.ObservableAny:1
//io.reactivex.internal.operators.observable.ObservableAny.AnyObserver:1
//io.reactivex.internal.operators.observable.ObservableAnySingle:1
//io.reactivex.internal.operators.observable.ObservableAnySingle.AnyObserver:1
//io.reactivex.internal.operators.observable.ObservableAutoConnect:1
//io.reactivex.internal.operators.observable.ObservableBuffer:2
//io.reactivex.internal.operators.observable.ObservableBuffer.BufferExactObserver:2
//io.reactivex.internal.operators.observable.ObservableBuffer.BufferSkipObserver:2
//io.reactivex.internal.operators.observable.ObservableBufferBoundary:4
//io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferBoundaryObserver:4
//io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferBoundaryObserver.BufferOpenObserver:1
//io.reactivex.internal.operators.observable.ObservableBufferBoundary.BufferCloseObserver:2
//io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier:3
//io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier.BufferBoundaryObserver:3
//io.reactivex.internal.operators.observable.ObservableBufferBoundarySupplier.BufferBoundarySupplierObserver:3
//io.reactivex.internal.operators.observable.ObservableBufferExactBoundary:3
//io.reactivex.internal.operators.observable.ObservableBufferExactBoundary.BufferBoundaryObserver:3
//io.reactivex.internal.operators.observable.ObservableBufferExactBoundary.BufferExactBoundaryObserver:3
//io.reactivex.internal.operators.observable.ObservableBufferTimed:2
//io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferExactBoundedObserver:2
//io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferExactUnboundedObserver:2
//io.reactivex.internal.operators.observable.ObservableBufferTimed.BufferSkipBoundedObserver:2
//io.reactivex.internal.operators.observable.ObservableCache:1
//io.reactivex.internal.operators.observable.ObservableCache.CacheDisposable:1
//io.reactivex.internal.operators.observable.ObservableCache.Node:1
//io.reactivex.internal.operators.observable.ObservableCollect:2
//io.reactivex.internal.operators.observable.ObservableCollect.CollectObserver:2
//io.reactivex.internal.operators.observable.ObservableCollectSingle:2
//io.reactivex.internal.operators.observable.ObservableCollectSingle.CollectObserver:2
//io.reactivex.internal.operators.observable.ObservableCombineLatest:2
//io.reactivex.internal.operators.observable.ObservableCombineLatest.CombinerObserver:2
//io.reactivex.internal.operators.observable.ObservableCombineLatest.LatestCoordinator:2
//io.reactivex.internal.operators.observable.ObservableConcatMap:2
//io.reactivex.internal.operators.observable.ObservableConcatMap.ConcatMapDelayErrorObserver:2
//io.reactivex.internal.operators.observable.ObservableConcatMap.ConcatMapDelayErrorObserver.DelayErrorInnerObserver:1
//io.reactivex.internal.operators.observable.ObservableConcatMap.SourceObserver:2
//io.reactivex.internal.operators.observable.ObservableConcatMap.SourceObserver.InnerObserver:1
//io.reactivex.internal.operators.observable.ObservableConcatMapEager:2
//io.reactivex.internal.operators.observable.ObservableConcatMapEager.ConcatMapEagerMainObserver:2
//io.reactivex.internal.operators.observable.ObservableConcatWithCompletable:1
//io.reactivex.internal.operators.observable.ObservableConcatWithCompletable.ConcatWithObserver:1
//io.reactivex.internal.operators.observable.ObservableConcatWithMaybe:1
//io.reactivex.internal.operators.observable.ObservableConcatWithMaybe.ConcatWithObserver:1
//io.reactivex.internal.operators.observable.ObservableConcatWithSingle:1
//io.reactivex.internal.operators.observable.ObservableConcatWithSingle.ConcatWithObserver:1
//io.reactivex.internal.operators.observable.ObservableCount:1
//io.reactivex.internal.operators.observable.ObservableCountSingle:1
//io.reactivex.internal.operators.observable.ObservableCreate:1
//io.reactivex.internal.operators.observable.ObservableCreate.CreateEmitter:1
//io.reactivex.internal.operators.observable.ObservableCreate.SerializedEmitter:1
//io.reactivex.internal.operators.observable.ObservableDebounce:2
//io.reactivex.internal.operators.observable.ObservableDebounce.DebounceObserver:2
//io.reactivex.internal.operators.observable.ObservableDebounce.DebounceObserver.DebounceInnerObserver:2
//io.reactivex.internal.operators.observable.ObservableDebounceTimed:1
//io.reactivex.internal.operators.observable.ObservableDebounceTimed.DebounceEmitter:1
//io.reactivex.internal.operators.observable.ObservableDebounceTimed.DebounceTimedObserver:1
//io.reactivex.internal.operators.observable.ObservableDefer:1
//io.reactivex.internal.operators.observable.ObservableDelay:1
//io.reactivex.internal.operators.observable.ObservableDelay.DelayObserver:1
//io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther:2
//io.reactivex.internal.operators.observable.ObservableDematerialize:2
//io.reactivex.internal.operators.observable.ObservableDematerialize.DematerializeObserver:2
//io.reactivex.internal.operators.observable.ObservableDetach:1
//io.reactivex.internal.operators.observable.ObservableDetach.DetachObserver:1
//io.reactivex.internal.operators.observable.ObservableDistinct:2
//io.reactivex.internal.operators.observable.ObservableDistinct.DistinctObserver:2
//io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged:2
//io.reactivex.internal.operators.observable.ObservableDistinctUntilChanged.DistinctUntilChangedObserver:2
//io.reactivex.internal.operators.observable.ObservableDoAfterNext:1
//io.reactivex.internal.operators.observable.ObservableDoAfterNext.DoAfterObserver:1
//io.reactivex.internal.operators.observable.ObservableDoFinally:1
//io.reactivex.internal.operators.observable.ObservableDoFinally.DoFinallyObserver:1
//io.reactivex.internal.operators.observable.ObservableDoOnEach:1
//io.reactivex.internal.operators.observable.ObservableDoOnEach.DoOnEachObserver:1
//io.reactivex.internal.operators.observable.ObservableDoOnLifecycle:1
//io.reactivex.internal.operators.observable.ObservableElementAt:1
//io.reactivex.internal.operators.observable.ObservableElementAt.ElementAtObserver:1
//io.reactivex.internal.operators.observable.ObservableElementAtMaybe:1
//io.reactivex.internal.operators.observable.ObservableElementAtMaybe.ElementAtObserver:1
//io.reactivex.internal.operators.observable.ObservableElementAtSingle:1
//io.reactivex.internal.operators.observable.ObservableElementAtSingle.ElementAtObserver:1
//io.reactivex.internal.operators.observable.ObservableError:1
//io.reactivex.internal.operators.observable.ObservableFilter:1
//io.reactivex.internal.operators.observable.ObservableFilter.FilterObserver:1
//io.reactivex.internal.operators.observable.ObservableFlatMap:2
//io.reactivex.internal.operators.observable.ObservableFlatMap.InnerObserver:2
//io.reactivex.internal.operators.observable.ObservableFlatMap.MergeObserver:2
//io.reactivex.internal.operators.observable.ObservableFlatMapCompletable:1
//io.reactivex.internal.operators.observable.ObservableFlatMapCompletable.FlatMapCompletableMainObserver:1
//io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable:1
//io.reactivex.internal.operators.observable.ObservableFlatMapCompletableCompletable.FlatMapCompletableMainObserver:1
//io.reactivex.internal.operators.observable.ObservableFlatMapMaybe:2
//io.reactivex.internal.operators.observable.ObservableFlatMapMaybe.FlatMapMaybeObserver:2
//io.reactivex.internal.operators.observable.ObservableFlatMapSingle:2
//io.reactivex.internal.operators.observable.ObservableFlatMapSingle.FlatMapSingleObserver:2
//io.reactivex.internal.operators.observable.ObservableFlattenIterable:2
//io.reactivex.internal.operators.observable.ObservableFlattenIterable.FlattenIterableObserver:2
//io.reactivex.internal.operators.observable.ObservableFromArray:1
//io.reactivex.internal.operators.observable.ObservableFromArray.FromArrayDisposable:1
//io.reactivex.internal.operators.observable.ObservableFromCallable:1
//io.reactivex.internal.operators.observable.ObservableFromFuture:1
//io.reactivex.internal.operators.observable.ObservableFromIterable:1
//io.reactivex.internal.operators.observable.ObservableFromIterable.FromIterableDisposable:1
//io.reactivex.internal.operators.observable.ObservableFromPublisher:1
//io.reactivex.internal.operators.observable.ObservableFromPublisher.PublisherSubscriber:1
//io.reactivex.internal.operators.observable.ObservableFromUnsafeSource:1
//io.reactivex.internal.operators.observable.ObservableGenerate:2
//io.reactivex.internal.operators.observable.ObservableGenerate.GeneratorDisposable:2
//io.reactivex.internal.operators.observable.ObservableGroupBy:3
//io.reactivex.internal.operators.observable.ObservableGroupBy.GroupByObserver:3
//io.reactivex.internal.operators.observable.ObservableGroupBy.GroupedUnicast:2
//io.reactivex.internal.operators.observable.ObservableGroupBy.State:2
//io.reactivex.internal.operators.observable.ObservableGroupJoin:5
//io.reactivex.internal.operators.observable.ObservableGroupJoin.GroupJoinDisposable:5
//io.reactivex.internal.operators.observable.ObservableHide:1
//io.reactivex.internal.operators.observable.ObservableHide.HideDisposable:1
//io.reactivex.internal.operators.observable.ObservableIgnoreElements:1
//io.reactivex.internal.operators.observable.ObservableIgnoreElements.IgnoreObservable:1
//io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable:1
//io.reactivex.internal.operators.observable.ObservableIgnoreElementsCompletable.IgnoreObservable:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.BufferedReplayCallable:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.BufferedTimedReplayCallable:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapIntoIterable:2
//io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapWithCombinerInner:3
//io.reactivex.internal.operators.observable.ObservableInternalHelper.FlatMapWithCombinerOuter:3
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ItemDelayFunction:2
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnComplete:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnError:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ObserverOnNext:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ReplayCallable:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ReplayFunction:2
//io.reactivex.internal.operators.observable.ObservableInternalHelper.SimpleBiGenerator:2
//io.reactivex.internal.operators.observable.ObservableInternalHelper.SimpleGenerator:2
//io.reactivex.internal.operators.observable.ObservableInternalHelper.TimedReplayCallable:1
//io.reactivex.internal.operators.observable.ObservableInternalHelper.ZipIterableFunction:2
//io.reactivex.internal.operators.observable.ObservableJoin:5
//io.reactivex.internal.operators.observable.ObservableJoin.JoinDisposable:5
//io.reactivex.internal.operators.observable.ObservableJust:1
//io.reactivex.internal.operators.observable.ObservableLastMaybe:1
//io.reactivex.internal.operators.observable.ObservableLastMaybe.LastObserver:1
//io.reactivex.internal.operators.observable.ObservableLastSingle:1
//io.reactivex.internal.operators.observable.ObservableLastSingle.LastObserver:1
//io.reactivex.internal.operators.observable.ObservableLift:2
//io.reactivex.internal.operators.observable.ObservableMap:2
//io.reactivex.internal.operators.observable.ObservableMap.MapObserver:2
//io.reactivex.internal.operators.observable.ObservableMapNotification:2
//io.reactivex.internal.operators.observable.ObservableMapNotification.MapNotificationObserver:2
//io.reactivex.internal.operators.observable.ObservableMaterialize:1
//io.reactivex.internal.operators.observable.ObservableMaterialize.MaterializeObserver:1
//io.reactivex.internal.operators.observable.ObservableMergeWithCompletable:1
//io.reactivex.internal.operators.observable.ObservableMergeWithCompletable.MergeWithObserver:1
//io.reactivex.internal.operators.observable.ObservableMergeWithMaybe:1
//io.reactivex.internal.operators.observable.ObservableMergeWithMaybe.MergeWithObserver:1
//io.reactivex.internal.operators.observable.ObservableMergeWithMaybe.MergeWithObserver.OtherObserver:1
//io.reactivex.internal.operators.observable.ObservableMergeWithSingle:1
//io.reactivex.internal.operators.observable.ObservableMergeWithSingle.MergeWithObserver:1
//io.reactivex.internal.operators.observable.ObservableMergeWithSingle.MergeWithObserver.OtherObserver:1
//io.reactivex.internal.operators.observable.ObservableObserveOn:1
//io.reactivex.internal.operators.observable.ObservableObserveOn.ObserveOnObserver:1
//io.reactivex.internal.operators.observable.ObservableOnErrorNext:1
//io.reactivex.internal.operators.observable.ObservableOnErrorNext.OnErrorNextObserver:1
//io.reactivex.internal.operators.observable.ObservableOnErrorReturn:1
//io.reactivex.internal.operators.observable.ObservableOnErrorReturn.OnErrorReturnObserver:1
//io.reactivex.internal.operators.observable.ObservablePublish:1
//io.reactivex.internal.operators.observable.ObservablePublish.InnerDisposable:1
//io.reactivex.internal.operators.observable.ObservablePublish.PublishObserver:1
//io.reactivex.internal.operators.observable.ObservablePublish.PublishSource:1
//io.reactivex.internal.operators.observable.ObservablePublishAlt:1
//io.reactivex.internal.operators.observable.ObservablePublishAlt.InnerDisposable:1
//io.reactivex.internal.operators.observable.ObservablePublishAlt.PublishConnection:1
//io.reactivex.internal.operators.observable.ObservablePublishClassic:1
//io.reactivex.internal.operators.observable.ObservablePublishSelector:2
//io.reactivex.internal.operators.observable.ObservablePublishSelector.SourceObserver:2
//io.reactivex.internal.operators.observable.ObservablePublishSelector.TargetObserver:2
//io.reactivex.internal.operators.observable.ObservableReduceMaybe:1
//io.reactivex.internal.operators.observable.ObservableReduceMaybe.ReduceObserver:1
//io.reactivex.internal.operators.observable.ObservableReduceSeedSingle:2
//io.reactivex.internal.operators.observable.ObservableReduceSeedSingle.ReduceSeedObserver:2
//io.reactivex.internal.operators.observable.ObservableReduceWithSingle:2
//io.reactivex.internal.operators.observable.ObservableRefCount:1
//io.reactivex.internal.operators.observable.ObservableRefCount.RefCountObserver:1
//io.reactivex.internal.operators.observable.ObservableRepeat:1
//io.reactivex.internal.operators.observable.ObservableRepeat.RepeatObserver:1
//io.reactivex.internal.operators.observable.ObservableRepeatUntil:1
//io.reactivex.internal.operators.observable.ObservableRepeatUntil.RepeatUntilObserver:1
//io.reactivex.internal.operators.observable.ObservableRepeatWhen:1
//io.reactivex.internal.operators.observable.ObservableRepeatWhen.RepeatWhenObserver:1
//io.reactivex.internal.operators.observable.ObservableReplay:1
//io.reactivex.internal.operators.observable.ObservableReplay.BoundedReplayBuffer:1
//io.reactivex.internal.operators.observable.ObservableReplay.BufferSupplier:1
//io.reactivex.internal.operators.observable.ObservableReplay.DisposeConsumer:1
//io.reactivex.internal.operators.observable.ObservableReplay.InnerDisposable:1
//io.reactivex.internal.operators.observable.ObservableReplay.MulticastReplay:2
//io.reactivex.internal.operators.observable.ObservableReplay.Replay:1
//io.reactivex.internal.operators.observable.ObservableReplay.ReplayBuffer:1
//io.reactivex.internal.operators.observable.ObservableReplay.ReplayBufferSupplier:1
//io.reactivex.internal.operators.observable.ObservableReplay.ReplayObserver:1
//io.reactivex.internal.operators.observable.ObservableReplay.ReplaySource:1
//io.reactivex.internal.operators.observable.ObservableReplay.ScheduledReplaySupplier:1
//io.reactivex.internal.operators.observable.ObservableReplay.SizeAndTimeBoundReplayBuffer:1
//io.reactivex.internal.operators.observable.ObservableReplay.SizeBoundReplayBuffer:1
//io.reactivex.internal.operators.observable.ObservableReplay.UnboundedReplayBuffer:1
//io.reactivex.internal.operators.observable.ObservableRetryBiPredicate:1
//io.reactivex.internal.operators.observable.ObservableRetryBiPredicate.RetryBiObserver:1
//io.reactivex.internal.operators.observable.ObservableRetryPredicate:1
//io.reactivex.internal.operators.observable.ObservableRetryPredicate.RepeatObserver:1
//io.reactivex.internal.operators.observable.ObservableRetryWhen:1
//io.reactivex.internal.operators.observable.ObservableRetryWhen.RepeatWhenObserver:1
//io.reactivex.internal.operators.observable.ObservableSampleTimed:1
//io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedEmitLast:1
//io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedNoLast:1
//io.reactivex.internal.operators.observable.ObservableSampleTimed.SampleTimedObserver:1
//io.reactivex.internal.operators.observable.ObservableSampleWithObservable:1
//io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainEmitLast:1
//io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainNoLast:1
//io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SampleMainObserver:1
//io.reactivex.internal.operators.observable.ObservableSampleWithObservable.SamplerObserver:1
//io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable:1
//io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarXMapObservable:2
//io.reactivex.internal.operators.observable.ObservableScan:1
//io.reactivex.internal.operators.observable.ObservableScan.ScanObserver:1
//io.reactivex.internal.operators.observable.ObservableScanSeed:2
//io.reactivex.internal.operators.observable.ObservableScanSeed.ScanSeedObserver:2
//io.reactivex.internal.operators.observable.ObservableSequenceEqual:1
//io.reactivex.internal.operators.observable.ObservableSequenceEqual.EqualCoordinator:1
//io.reactivex.internal.operators.observable.ObservableSequenceEqual.EqualObserver:1
//io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle:1
//io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle.EqualCoordinator:1
//io.reactivex.internal.operators.observable.ObservableSequenceEqualSingle.EqualObserver:1
//io.reactivex.internal.operators.observable.ObservableSerialized:1
//io.reactivex.internal.operators.observable.ObservableSingleMaybe:1
//io.reactivex.internal.operators.observable.ObservableSingleMaybe.SingleElementObserver:1
//io.reactivex.internal.operators.observable.ObservableSingleSingle:1
//io.reactivex.internal.operators.observable.ObservableSingleSingle.SingleElementObserver:1
//io.reactivex.internal.operators.observable.ObservableSkip:1
//io.reactivex.internal.operators.observable.ObservableSkip.SkipObserver:1
//io.reactivex.internal.operators.observable.ObservableSkipLast:1
//io.reactivex.internal.operators.observable.ObservableSkipLast.SkipLastObserver:1
//io.reactivex.internal.operators.observable.ObservableSkipLastTimed:1
//io.reactivex.internal.operators.observable.ObservableSkipLastTimed.SkipLastTimedObserver:1
//io.reactivex.internal.operators.observable.ObservableSkipUntil:2
//io.reactivex.internal.operators.observable.ObservableSkipUntil.SkipUntilObserver:1
//io.reactivex.internal.operators.observable.ObservableSkipWhile:1
//io.reactivex.internal.operators.observable.ObservableSkipWhile.SkipWhileObserver:1
//io.reactivex.internal.operators.observable.ObservableSubscribeOn:1
//io.reactivex.internal.operators.observable.ObservableSubscribeOn.SubscribeOnObserver:1
//io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty:1
//io.reactivex.internal.operators.observable.ObservableSwitchIfEmpty.SwitchIfEmptyObserver:1
//io.reactivex.internal.operators.observable.ObservableSwitchMap:2
//io.reactivex.internal.operators.observable.ObservableSwitchMap.SwitchMapInnerObserver:2
//io.reactivex.internal.operators.observable.ObservableSwitchMap.SwitchMapObserver:2
//io.reactivex.internal.operators.observable.ObservableTake:1
//io.reactivex.internal.operators.observable.ObservableTake.TakeObserver:1
//io.reactivex.internal.operators.observable.ObservableTakeLast:1
//io.reactivex.internal.operators.observable.ObservableTakeLast.TakeLastObserver:1
//io.reactivex.internal.operators.observable.ObservableTakeLastOne:1
//io.reactivex.internal.operators.observable.ObservableTakeLastOne.TakeLastOneObserver:1
//io.reactivex.internal.operators.observable.ObservableTakeLastTimed:1
//io.reactivex.internal.operators.observable.ObservableTakeLastTimed.TakeLastTimedObserver:1
//io.reactivex.internal.operators.observable.ObservableTakeUntil:2
//io.reactivex.internal.operators.observable.ObservableTakeUntil.TakeUntilMainObserver:2
//io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate:1
//io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate.TakeUntilPredicateObserver:1
//io.reactivex.internal.operators.observable.ObservableTakeWhile:1
//io.reactivex.internal.operators.observable.ObservableTakeWhile.TakeWhileObserver:1
//io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed:1
//io.reactivex.internal.operators.observable.ObservableThrottleFirstTimed.DebounceTimedObserver:1
//io.reactivex.internal.operators.observable.ObservableThrottleLatest:1
//io.reactivex.internal.operators.observable.ObservableThrottleLatest.ThrottleLatestObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeInterval:1
//io.reactivex.internal.operators.observable.ObservableTimeInterval.TimeIntervalObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeout:3
//io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutFallbackObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeout.TimeoutObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeoutTimed:1
//io.reactivex.internal.operators.observable.ObservableTimeoutTimed.FallbackObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutFallbackObserver:1
//io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutObserver:1
//io.reactivex.internal.operators.observable.ObservableToList:2
//io.reactivex.internal.operators.observable.ObservableToList.ToListObserver:2
//io.reactivex.internal.operators.observable.ObservableToListSingle:2
//io.reactivex.internal.operators.observable.ObservableToListSingle.ToListObserver:2
//io.reactivex.internal.operators.observable.ObservableUnsubscribeOn:1
//io.reactivex.internal.operators.observable.ObservableUnsubscribeOn.UnsubscribeObserver:1
//io.reactivex.internal.operators.observable.ObservableUsing:2
//io.reactivex.internal.operators.observable.ObservableUsing.UsingObserver:2
//io.reactivex.internal.operators.observable.ObservableWindow:1
//io.reactivex.internal.operators.observable.ObservableWindow.WindowExactObserver:1
//io.reactivex.internal.operators.observable.ObservableWindow.WindowSkipObserver:1
//io.reactivex.internal.operators.observable.ObservableWindowBoundary:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundary.WindowBoundaryInnerObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundary.WindowBoundaryMainObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector:3
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.OperatorWindowBoundaryCloseObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.OperatorWindowBoundaryOpenObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.WindowBoundaryMainObserver:3
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySelector.WindowOperation:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier.WindowBoundaryInnerObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowBoundarySupplier.WindowBoundaryMainObserver:2
//io.reactivex.internal.operators.observable.ObservableWindowTimed:1
//io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowExactBoundedObserver:1
//io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowExactUnboundedObserver:1
//io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowSkipObserver:1
//io.reactivex.internal.operators.observable.ObservableWindowTimed.WindowSkipObserver.SubjectWork:1
//io.reactivex.internal.operators.observable.ObservableWithLatestFrom:3
//io.reactivex.internal.operators.observable.ObservableWithLatestFrom.WithLatestFromObserver:3
//io.reactivex.internal.operators.observable.ObservableWithLatestFromMany:2
//io.reactivex.internal.operators.observable.ObservableWithLatestFromMany.WithLatestFromObserver:2
//io.reactivex.internal.operators.observable.ObservableZip:2
//io.reactivex.internal.operators.observable.ObservableZip.ZipCoordinator:2
//io.reactivex.internal.operators.observable.ObservableZip.ZipObserver:2
//io.reactivex.internal.operators.observable.ObservableZipIterable:3
//io.reactivex.internal.operators.observable.ObservableZipIterable.ZipIterableObserver:3
//io.reactivex.internal.operators.observable.ObserverResourceWrapper:1
//io.reactivex.internal.operators.parallel.ParallelCollect:2
//io.reactivex.internal.operators.parallel.ParallelCollect.ParallelCollectSubscriber:2
//io.reactivex.internal.operators.parallel.ParallelConcatMap:2
//io.reactivex.internal.operators.parallel.ParallelDoOnNextTry:1
//io.reactivex.internal.operators.parallel.ParallelDoOnNextTry.ParallelDoOnNextConditionalSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelDoOnNextTry.ParallelDoOnNextSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilter:1
//io.reactivex.internal.operators.parallel.ParallelFilter.BaseFilterSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilter.ParallelFilterConditionalSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilter.ParallelFilterSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilterTry:1
//io.reactivex.internal.operators.parallel.ParallelFilterTry.BaseFilterSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilterTry.ParallelFilterConditionalSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFilterTry.ParallelFilterSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelFlatMap:2
//io.reactivex.internal.operators.parallel.ParallelFromArray:1
//io.reactivex.internal.operators.parallel.ParallelFromPublisher:1
//io.reactivex.internal.operators.parallel.ParallelFromPublisher.ParallelDispatcher:1
//io.reactivex.internal.operators.parallel.ParallelJoin:1
//io.reactivex.internal.operators.parallel.ParallelJoin.JoinInnerSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscription:1
//io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionBase:1
//io.reactivex.internal.operators.parallel.ParallelJoin.JoinSubscriptionDelayError:1
//io.reactivex.internal.operators.parallel.ParallelMap:2
//io.reactivex.internal.operators.parallel.ParallelMap.ParallelMapConditionalSubscriber:2
//io.reactivex.internal.operators.parallel.ParallelMap.ParallelMapSubscriber:2
//io.reactivex.internal.operators.parallel.ParallelMapTry:2
//io.reactivex.internal.operators.parallel.ParallelMapTry.ParallelMapTryConditionalSubscriber:2
//io.reactivex.internal.operators.parallel.ParallelMapTry.ParallelMapTrySubscriber:2
//io.reactivex.internal.operators.parallel.ParallelPeek:1
//io.reactivex.internal.operators.parallel.ParallelPeek.ParallelPeekSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelReduce:2
//io.reactivex.internal.operators.parallel.ParallelReduce.ParallelReduceSubscriber:2
//io.reactivex.internal.operators.parallel.ParallelReduceFull:1
//io.reactivex.internal.operators.parallel.ParallelReduceFull.ParallelReduceFullInnerSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelReduceFull.ParallelReduceFullMainSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelReduceFull.SlotPair:1
//io.reactivex.internal.operators.parallel.ParallelRunOn:1
//io.reactivex.internal.operators.parallel.ParallelRunOn.BaseRunOnSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelRunOn.RunOnConditionalSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelRunOn.RunOnSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelSortedJoin:1
//io.reactivex.internal.operators.parallel.ParallelSortedJoin.SortedJoinInnerSubscriber:1
//io.reactivex.internal.operators.parallel.ParallelSortedJoin.SortedJoinSubscription:1
//io.reactivex.internal.operators.single.SingleAmb:1
//io.reactivex.internal.operators.single.SingleAmb.AmbSingleObserver:1
//io.reactivex.internal.operators.single.SingleCache:1
//io.reactivex.internal.operators.single.SingleCache.CacheDisposable:1
//io.reactivex.internal.operators.single.SingleContains:1
//io.reactivex.internal.operators.single.SingleCreate:1
//io.reactivex.internal.operators.single.SingleCreate.Emitter:1
//io.reactivex.internal.operators.single.SingleDefer:1
//io.reactivex.internal.operators.single.SingleDelay:1
//io.reactivex.internal.operators.single.SingleDelayWithCompletable:1
//io.reactivex.internal.operators.single.SingleDelayWithCompletable.OtherObserver:1
//io.reactivex.internal.operators.single.SingleDelayWithObservable:2
//io.reactivex.internal.operators.single.SingleDelayWithObservable.OtherSubscriber:2
//io.reactivex.internal.operators.single.SingleDelayWithPublisher:2
//io.reactivex.internal.operators.single.SingleDelayWithPublisher.OtherSubscriber:2
//io.reactivex.internal.operators.single.SingleDelayWithSingle:2
//io.reactivex.internal.operators.single.SingleDelayWithSingle.OtherObserver:2
//io.reactivex.internal.operators.single.SingleDematerialize:2
//io.reactivex.internal.operators.single.SingleDematerialize.DematerializeObserver:2
//io.reactivex.internal.operators.single.SingleDetach:1
//io.reactivex.internal.operators.single.SingleDetach.DetachSingleObserver:1
//io.reactivex.internal.operators.single.SingleDoAfterSuccess:1
//io.reactivex.internal.operators.single.SingleDoAfterSuccess.DoAfterObserver:1
//io.reactivex.internal.operators.single.SingleDoAfterTerminate:1
//io.reactivex.internal.operators.single.SingleDoAfterTerminate.DoAfterTerminateObserver:1
//io.reactivex.internal.operators.single.SingleDoFinally:1
//io.reactivex.internal.operators.single.SingleDoFinally.DoFinallyObserver:1
//io.reactivex.internal.operators.single.SingleDoOnDispose:1
//io.reactivex.internal.operators.single.SingleDoOnDispose.DoOnDisposeObserver:1
//io.reactivex.internal.operators.single.SingleDoOnError:1
//io.reactivex.internal.operators.single.SingleDoOnEvent:1
//io.reactivex.internal.operators.single.SingleDoOnSubscribe:1
//io.reactivex.internal.operators.single.SingleDoOnSubscribe.DoOnSubscribeSingleObserver:1
//io.reactivex.internal.operators.single.SingleDoOnSuccess:1
//io.reactivex.internal.operators.single.SingleDoOnTerminate:1
//io.reactivex.internal.operators.single.SingleEquals:1
//io.reactivex.internal.operators.single.SingleEquals.InnerObserver:1
//io.reactivex.internal.operators.single.SingleError:1
//io.reactivex.internal.operators.single.SingleFlatMap:2
//io.reactivex.internal.operators.single.SingleFlatMap.SingleFlatMapCallback:2
//io.reactivex.internal.operators.single.SingleFlatMap.SingleFlatMapCallback.FlatMapSingleObserver:1
//io.reactivex.internal.operators.single.SingleFlatMapCompletable:1
//io.reactivex.internal.operators.single.SingleFlatMapCompletable.FlatMapCompletableObserver:1
//io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable:2
//io.reactivex.internal.operators.single.SingleFlatMapIterableFlowable.FlatMapIterableObserver:2
//io.reactivex.internal.operators.single.SingleFlatMapIterableObservable:2
//io.reactivex.internal.operators.single.SingleFlatMapIterableObservable.FlatMapIterableObserver:2
//io.reactivex.internal.operators.single.SingleFlatMapMaybe:2
//io.reactivex.internal.operators.single.SingleFlatMapMaybe.FlatMapMaybeObserver:1
//io.reactivex.internal.operators.single.SingleFlatMapMaybe.FlatMapSingleObserver:2
//io.reactivex.internal.operators.single.SingleFlatMapPublisher:2
//io.reactivex.internal.operators.single.SingleFlatMapPublisher.SingleFlatMapPublisherObserver:2
//io.reactivex.internal.operators.single.SingleFromCallable:1
//io.reactivex.internal.operators.single.SingleFromPublisher:1
//io.reactivex.internal.operators.single.SingleFromPublisher.ToSingleObserver:1
//io.reactivex.internal.operators.single.SingleFromUnsafeSource:1
//io.reactivex.internal.operators.single.SingleHide:1
//io.reactivex.internal.operators.single.SingleHide.HideSingleObserver:1
//io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowableIterable:1
//io.reactivex.internal.operators.single.SingleInternalHelper.ToFlowableIterator:1
//io.reactivex.internal.operators.single.SingleJust:1
//io.reactivex.internal.operators.single.SingleLift:2
//io.reactivex.internal.operators.single.SingleMap:2
//io.reactivex.internal.operators.single.SingleMap.MapSingleObserver:2
//io.reactivex.internal.operators.single.SingleMaterialize:1
//io.reactivex.internal.operators.single.SingleObserveOn:1
//io.reactivex.internal.operators.single.SingleObserveOn.ObserveOnSingleObserver:1
//io.reactivex.internal.operators.single.SingleOnErrorReturn:1
//io.reactivex.internal.operators.single.SingleResumeNext:1
//io.reactivex.internal.operators.single.SingleResumeNext.ResumeMainSingleObserver:1
//io.reactivex.internal.operators.single.SingleSubscribeOn:1
//io.reactivex.internal.operators.single.SingleSubscribeOn.SubscribeOnObserver:1
//io.reactivex.internal.operators.single.SingleTakeUntil:2
//io.reactivex.internal.operators.single.SingleTakeUntil.TakeUntilMainObserver:1
//io.reactivex.internal.operators.single.SingleTimeout:1
//io.reactivex.internal.operators.single.SingleTimeout.TimeoutMainObserver:1
//io.reactivex.internal.operators.single.SingleTimeout.TimeoutMainObserver.TimeoutFallbackObserver:1
//io.reactivex.internal.operators.single.SingleToFlowable:1
//io.reactivex.internal.operators.single.SingleToFlowable.SingleToFlowableObserver:1
//io.reactivex.internal.operators.single.SingleToObservable:1
//io.reactivex.internal.operators.single.SingleToObservable.SingleToObservableObserver:1
//io.reactivex.internal.operators.single.SingleUnsubscribeOn:1
//io.reactivex.internal.operators.single.SingleUnsubscribeOn.UnsubscribeOnSingleObserver:1
//io.reactivex.internal.operators.single.SingleUsing:2
//io.reactivex.internal.operators.single.SingleUsing.UsingSingleObserver:2
//io.reactivex.internal.operators.single.SingleZipArray:2
//io.reactivex.internal.operators.single.SingleZipArray.ZipCoordinator:2
//io.reactivex.internal.operators.single.SingleZipArray.ZipSingleObserver:1
//io.reactivex.internal.operators.single.SingleZipIterable:2
//io.reactivex.internal.queue.MpscLinkedQueue:1
//io.reactivex.internal.queue.MpscLinkedQueue.LinkedQueueNode:1
//io.reactivex.internal.queue.SpscArrayQueue:1
//io.reactivex.internal.queue.SpscLinkedArrayQueue:1
//io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber:2
//io.reactivex.internal.subscribers.BasicFuseableSubscriber:2
//io.reactivex.internal.subscribers.BlockingBaseSubscriber:1
//io.reactivex.internal.subscribers.BlockingFirstSubscriber:1
//io.reactivex.internal.subscribers.BlockingLastSubscriber:1
//io.reactivex.internal.subscribers.BlockingSubscriber:1
//io.reactivex.internal.subscribers.BoundedSubscriber:1
//io.reactivex.internal.subscribers.DeferredScalarSubscriber:2
//io.reactivex.internal.subscribers.ForEachWhileSubscriber:1
//io.reactivex.internal.subscribers.FutureSubscriber:1
//io.reactivex.internal.subscribers.InnerQueuedSubscriber:1
//io.reactivex.internal.subscribers.InnerQueuedSubscriberSupport:1
//io.reactivex.internal.subscribers.LambdaSubscriber:1
//io.reactivex.internal.subscribers.QueueDrainSubscriber:3
//io.reactivex.internal.subscribers.SinglePostCompleteSubscriber:2
//io.reactivex.internal.subscribers.StrictSubscriber:1
//io.reactivex.internal.subscribers.SubscriberResourceWrapper:1
//io.reactivex.internal.subscriptions.BasicIntQueueSubscription:1
//io.reactivex.internal.subscriptions.BasicQueueSubscription:1
//io.reactivex.internal.subscriptions.DeferredScalarSubscription:1
//io.reactivex.internal.subscriptions.ScalarSubscription:1
//io.reactivex.internal.util.AppendOnlyLinkedArrayList:1
//io.reactivex.internal.util.AppendOnlyLinkedArrayList.NonThrowingPredicate:1
//io.reactivex.internal.util.MergerBiFunction:1
//io.reactivex.internal.util.ObservableQueueDrain:2
//io.reactivex.internal.util.OpenHashSet:1
//io.reactivex.internal.util.QueueDrain:2
//io.reactivex.internal.util.SorterFunction:1
//io.reactivex.internal.util.VolatileSizeArrayList:1
//io.reactivex.observables.ConnectableObservable:1
//io.reactivex.observables.GroupedObservable:2
//io.reactivex.observers.BaseTestConsumer:2
//io.reactivex.observers.DefaultObserver:1
//io.reactivex.observers.DisposableMaybeObserver:1
//io.reactivex.observers.DisposableObserver:1
//io.reactivex.observers.DisposableSingleObserver:1
//io.reactivex.observers.ResourceMaybeObserver:1
//io.reactivex.observers.ResourceObserver:1
//io.reactivex.observers.ResourceSingleObserver:1
//io.reactivex.observers.SafeObserver:1
//io.reactivex.observers.SerializedObserver:1
//io.reactivex.observers.TestObserver:1
//io.reactivex.parallel.ParallelFlowable:1
//io.reactivex.parallel.ParallelFlowableConverter:2
//io.reactivex.parallel.ParallelTransformer:2
//io.reactivex.processors.AsyncProcessor:1
//io.reactivex.processors.AsyncProcessor.AsyncSubscription:1
//io.reactivex.processors.BehaviorProcessor:1
//io.reactivex.processors.BehaviorProcessor.BehaviorSubscription:1
//io.reactivex.processors.FlowableProcessor:1
//io.reactivex.processors.MulticastProcessor:1
//io.reactivex.processors.MulticastProcessor.MulticastSubscription:1
//io.reactivex.processors.PublishProcessor:1
//io.reactivex.processors.PublishProcessor.PublishSubscription:1
//io.reactivex.processors.ReplayProcessor:1
//io.reactivex.processors.ReplayProcessor.Node:1
//io.reactivex.processors.ReplayProcessor.ReplayBuffer:1
//io.reactivex.processors.ReplayProcessor.ReplaySubscription:1
//io.reactivex.processors.ReplayProcessor.SizeAndTimeBoundReplayBuffer:1
//io.reactivex.processors.ReplayProcessor.SizeBoundReplayBuffer:1
//io.reactivex.processors.ReplayProcessor.TimedNode:1
//io.reactivex.processors.ReplayProcessor.UnboundedReplayBuffer:1
//io.reactivex.processors.SerializedProcessor:1
//io.reactivex.processors.UnicastProcessor:1
//io.reactivex.schedulers.Timed:1
//io.reactivex.subjects.AsyncSubject:1
//io.reactivex.subjects.AsyncSubject.AsyncDisposable:1
//io.reactivex.subjects.BehaviorSubject:1
//io.reactivex.subjects.BehaviorSubject.BehaviorDisposable:1
//io.reactivex.subjects.MaybeSubject:1
//io.reactivex.subjects.MaybeSubject.MaybeDisposable:1
//io.reactivex.subjects.PublishSubject:1
//io.reactivex.subjects.PublishSubject.PublishDisposable:1
//io.reactivex.subjects.ReplaySubject:1
//io.reactivex.subjects.ReplaySubject.Node:1
//io.reactivex.subjects.ReplaySubject.ReplayBuffer:1
//io.reactivex.subjects.ReplaySubject.ReplayDisposable:1
//io.reactivex.subjects.ReplaySubject.SizeAndTimeBoundReplayBuffer:1
//io.reactivex.subjects.ReplaySubject.SizeBoundReplayBuffer:1
//io.reactivex.subjects.ReplaySubject.TimedNode:1
//io.reactivex.subjects.ReplaySubject.UnboundedReplayBuffer:1
//io.reactivex.subjects.SerializedSubject:1
//io.reactivex.subjects.SingleSubject:1
//io.reactivex.subjects.SingleSubject.SingleDisposable:1
//io.reactivex.subjects.Subject:1
//io.reactivex.subjects.UnicastSubject:1
//io.reactivex.subscribers.DefaultSubscriber:1
//io.reactivex.subscribers.DisposableSubscriber:1
//io.reactivex.subscribers.ResourceSubscriber:1
//io.reactivex.subscribers.SafeSubscriber:1
//io.reactivex.subscribers.SerializedSubscriber:1
//io.reactivex.subscribers.TestSubscriber:1

